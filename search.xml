<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hexo食用手册</title>
    <url>/posts/36231/</url>
    <content><![CDATA[<h4 id="基本指令"><a href="#基本指令" class="headerlink" title="基本指令"></a>基本指令</h4><figure class="highlight haxe"><table><tbody><tr><td class="code"><pre><code class="hljs haxe">hexo g <span class="hljs-meta">#生成文件</span><br>hexo s <span class="hljs-meta">#本地服务器查看</span><br>hexo d <span class="hljs-meta">#部署到github上</span><br>hexo n <span class="hljs-string">"文章标题"</span><br>hexo <span class="hljs-keyword">new</span> <span class="hljs-type">page</span> <span class="hljs-string">"新页面"</span><br></code></pre></td></tr></tbody></table></figure>
<h4 id="文章可以拥有的属性"><a href="#文章可以拥有的属性" class="headerlink" title="文章可以拥有的属性"></a>文章可以拥有的属性</h4><table>
<thead>
<tr>
<th>-</th>
<th>Settings</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>layout</td>
<td>Layout</td>
<td>post or page</td>
</tr>
<tr>
<td>2</td>
<td>title</td>
<td>标题</td>
<td></td>
</tr>
<tr>
<td>3</td>
<td>data</td>
<td>创建日期</td>
<td>文件的创建日期</td>
</tr>
<tr>
<td>4</td>
<td>updated</td>
<td>修改日期</td>
<td>文件的修改日期</td>
</tr>
<tr>
<td>5</td>
<td>comments</td>
<td>是否开启评论</td>
<td>true</td>
</tr>
<tr>
<td>6</td>
<td>tags</td>
<td>标签</td>
<td></td>
</tr>
<tr>
<td>7</td>
<td>categories</td>
<td>分类</td>
<td></td>
</tr>
<tr>
<td>8</td>
<td>permalink</td>
<td>url中的名字</td>
<td>文件名字</td>
</tr>
</tbody></table>
<h3 id="一篇文章的基本框架"><a href="#一篇文章的基本框架" class="headerlink" title="一篇文章的基本框架"></a>一篇文章的基本框架</h3><figure class="highlight yaml"><table><tbody><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">My</span> <span class="hljs-string">awesome</span> <span class="hljs-string">title</span><br><span class="hljs-attr">date:</span> <span class="hljs-number">2023-8</span><span class="hljs-number">-23</span> <span class="hljs-number">18</span><span class="hljs-string">:38:45</span><br><span class="hljs-attr">categories:</span> <br>    <span class="hljs-bullet">-</span> <span class="hljs-string">分类1</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">分类2</span><br><span class="hljs-attr">tags:</span> <br>    <span class="hljs-bullet">-</span> <span class="hljs-string">标签1</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">标签2</span><br><span class="hljs-attr">mp3:</span> <span class="hljs-string">http://domain.com/awesome.mp3</span><br><span class="hljs-attr">cover:</span> <span class="hljs-string">http://domain.com/awesome.jpg</span><br><span class="hljs-meta">---</span><br></code></pre></td></tr></tbody></table></figure>

<h4 id="可能遇见的bug"><a href="#可能遇见的bug" class="headerlink" title="可能遇见的bug"></a>可能遇见的bug</h4><ol>
<li>解决Hexo部署时报错：Error: Spawn failed</li>
</ol>
<p>打开博客主目录配置文件 __config.yml,修改deploy.repo<br>改为如下格式</p>
<figure class="highlight scss"><table><tbody><tr><td class="code"><pre><code class="hljs scss">git<span class="hljs-keyword">@github</span>.<span class="hljs-attribute">com</span>:{用户名}<span class="hljs-selector-class">.github</span><span class="hljs-selector-class">.io</span><br></code></pre></td></tr></tbody></table></figure>
<p>重新执行 hexo clean 等指令</p>
<h6 id="或者"><a href="#或者" class="headerlink" title="或者"></a>或者</h6><p>删除<code>.deplot_git</code>文件夹,在git bash中<code>git config --global core.autocrlf false</code>并且重新执行hexo clean等指令</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>简单配置VScodeC or Cpp环境</title>
    <url>/posts/e139af66/</url>
    <content><![CDATA[<h2 id="下载VScode"><a href="#下载VScode" class="headerlink" title="下载VScode"></a>下载VScode</h2><p>下载链接<a href="https://code.visualstudio.com/">Visual Studio Code - Code Editing. Redefined</a></p>
<p><img src="https://pic.imgdb.cn/item/65e6ab2a9f345e8d03900119.png" alt="img"></p>
<p>注意一下最后一项，必须是勾 - <strong>添加到PATH</strong></p>
<h2 id="安装mingw64"><a href="#安装mingw64" class="headerlink" title="安装mingw64"></a>安装mingw64</h2><p>到mingw64官网<a href="https://www.mingw-w64.org/downloads/">MinGW-w64</a><br><img src="https://pic.imgdb.cn/item/65e6ac179f345e8d03922f8d.png" alt="img"><br>点进SourceForge,进去下载对应版本就行。<br>保存到本地一个不会忘记的地方。</p>
<h2 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h2><p>win + Q 搜索环境变量<br><img src="https://pic.imgdb.cn/item/65e6ac909f345e8d03934322.png" alt="img"></p>
<p>点击环境变量<br><img src="https://pic.imgdb.cn/item/65e6acc49f345e8d0393c132.png" alt="img"><br>进入编辑Path<br><img src="https://pic.imgdb.cn/item/65e6ad139f345e8d0394764e.png" alt="img"><br>新建一个，路径就填写刚刚下载下来的mingw64的bin目录,如果你电脑上有dev可以直接填写dev的自带环境的路径。</p>
<h2 id="配置VScode"><a href="#配置VScode" class="headerlink" title="配置VScode"></a>配置VScode</h2><p>点击拓展，下载 Chinese (Simplified) (简体中文) Language Pack for Visual Studio Code 进行汉化。<br>之后下载 C/C++ Compile Run拓展。</p>
<p><img src="https://pic.imgdb.cn/item/65e6ae209f345e8d0396f7e5.png" alt="img"><br><img src="https://pic.imgdb.cn/item/65e6ae599f345e8d0397815e.png" alt="img"></p>
<p>创建一个cpp文件，写上对应代码即可。</p>
<p>如果喜欢黑窗口，可以进入Compile Run 的拓展设置里面，更改<br><img src="https://pic.imgdb.cn/item/65e6ae999f345e8d03981b6e.png" alt="img"><br>即可。</p>
<h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p>本文并没有使用C/C++ 拓展传统的几件套，因为配置.vscode文件夹里面的那三个文件较为麻烦，效果也不是很理想。而且那是专门用来写项目的时候才安装的，对于算法竞赛，轻量级即可。</p>
]]></content>
      <categories>
        <category>vscode</category>
      </categories>
      <tags>
        <tag>vscode</tag>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>算法模板</title>
    <url>/posts/2cc2fa98/</url>
    <content><![CDATA[<h2 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h2><ul>
<li><p>[[#基础算法]]</p>
<ul>
<li>[[#前缀和与差分]]</li>
<li>[[#二分]]</li>
</ul>
</li>
<li><p>[[#数据结构]]</p>
<ul>
<li>[[#并查集]]<ul>
<li>[[#普通并查集]]</li>
<li>[[#带权并查集]]</li>
<li>[[#拓展域并查集]]</li>
</ul>
</li>
<li>[[#树状数组]]</li>
</ul>
</li>
<li><p>[[#图论]]</p>
<ul>
<li>[[#最小生成树]]<ul>
<li>[[#Kruskal算法]]</li>
</ul>
</li>
<li>[[#全源最短路]]<ul>
<li>[[#Djkstra堆优化(正权稀疏图)]]</li>
<li>[[#Djkstra(正权稠密图)]]</li>
<li>[[#Bellman_Ford]]</li>
<li>[[#Spfa]]</li>
<li>[[#Floyd]]</li>
</ul>
</li>
<li>[[#拓扑排序]]</li>
<li>[[#LCA最近公共祖先]]</li>
</ul>
</li>
<li><p>[[#数论]]</p>
<ul>
<li>[[#快速幂]]</li>
<li>[[#组合数]]</li>
<li>[[#欧几里得算法]]</li>
<li>[[#质数]]<ul>
<li>[[#试除法]]</li>
<li>[[#线性筛]]</li>
</ul>
</li>
</ul>
</li>
<li><p>[[#杂项]]</p>
<ul>
<li>[[#莫队]]<ul>
<li>[[#带修莫队]]</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="基础算法"><a href="#基础算法" class="headerlink" title="基础算法"></a>基础算法</h3><h4 id="前缀和与差分"><a href="#前缀和与差分" class="headerlink" title="前缀和与差分"></a>前缀和与差分</h4><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a[],p[],d[]<br><span class="hljs-comment">//前缀和</span><br>p[i] = p[i<span class="hljs-number">-1</span>] + a[i] <span class="hljs-comment">//构造</span><br><span class="hljs-built_in">sum</span>(l,r) = p[r] - p[l - <span class="hljs-number">1</span>] <span class="hljs-comment">//查询</span><br><br>p[x][y] = p[x<span class="hljs-number">-1</span>][y] + p[x][y<span class="hljs-number">-1</span>] - p[x<span class="hljs-number">-1</span>][y<span class="hljs-number">-1</span>] + a[x][y] <span class="hljs-comment">//构造</span><br><span class="hljs-built_in">sum</span>(<span class="hljs-built_in">point</span>(<span class="hljs-number">1</span>),<span class="hljs-built_in">point</span>(<span class="hljs-number">2</span>)) = p[x2][y2] + p[x1<span class="hljs-number">-1</span>][y1<span class="hljs-number">-1</span>] - p[x1<span class="hljs-number">-1</span>][y2] - p[x2][y1<span class="hljs-number">-1</span>] <span class="hljs-comment">//查询</span><br><br><span class="hljs-comment">//差分</span><br><span class="hljs-built_in">diff</span>(l,r,c)<br>{<br>	d[l] += c<br>	d[r + <span class="hljs-number">1</span>] -= c<br>}<br><br><span class="hljs-built_in">diff</span>(<span class="hljs-built_in">point</span>(<span class="hljs-number">1</span>),<span class="hljs-built_in">point</span>(<span class="hljs-number">2</span>),c)<br>{<br>	d[x1][y1]+=c<br>	d[x2+<span class="hljs-number">1</span>][y1]-=c<br>	d[x1][y2+<span class="hljs-number">1</span>]-=c<br>	d[x2+<span class="hljs-number">1</span>][y2+<span class="hljs-number">1</span>]+=c<br>}<br></code></pre></td></tr></tbody></table></figure>

<h4 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h4><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>{<span class="hljs-comment">/* ... */</span>} <span class="hljs-comment">// 检查x是否满足某种性质</span><br><br><span class="hljs-comment">// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bsearch_1</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-keyword">while</span> (l &lt; r)<br>    {<br>        <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid)) r = mid;    <span class="hljs-comment">// check()判断mid是否满足性质</span><br>        <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>    }<br>    <span class="hljs-keyword">return</span> l;<br>}<br><span class="hljs-comment">// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bsearch_2</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-keyword">while</span> (l &lt; r)<br>    {<br>        <span class="hljs-type">int</span> mid = l + r + <span class="hljs-number">1</span> &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid)) l = mid;<br>        <span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>;<br>    }<br>    <span class="hljs-keyword">return</span> l;<br>}<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span> </span>{<span class="hljs-comment">/* ... */</span>} <span class="hljs-comment">// 检查x是否满足某种性质</span><br><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">bsearch_3</span><span class="hljs-params">(<span class="hljs-type">double</span> l, <span class="hljs-type">double</span> r)</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-type">const</span> <span class="hljs-type">double</span> eps = <span class="hljs-number">1e-6</span>;   <span class="hljs-comment">// eps 表示精度，取决于题目对精度的要求</span><br>    <span class="hljs-keyword">while</span> (r - l &gt; eps)<br>    {<br>        <span class="hljs-type">double</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid)) r = mid;<br>        <span class="hljs-keyword">else</span> l = mid;<br>    }<br>    <span class="hljs-keyword">return</span> l;<br>}<br><br><span class="hljs-built_in">lower_bound</span>(begin,end,num,rule) 第一个大于等于(小于等于)<br><span class="hljs-built_in">upper_bound</span>(begin,end,num,rule) 第一个大于(小于)<br></code></pre></td></tr></tbody></table></figure>

<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><h4 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h4><h5 id="普通并查集"><a href="#普通并查集" class="headerlink" title="普通并查集"></a>普通并查集</h5><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">DSU</span><br>{<br>&nbsp; &nbsp; std::vector&lt;<span class="hljs-type">int</span>&gt; p, siz;<br>&nbsp; &nbsp; <span class="hljs-built_in">DSU</span>() {}<br>&nbsp; &nbsp; <span class="hljs-built_in">DSU</span>(<span class="hljs-type">int</span> n) { <span class="hljs-built_in">init</span>(n); }<br>&nbsp; &nbsp; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function">&nbsp; &nbsp; </span>{<br>&nbsp; &nbsp; &nbsp; &nbsp; p.<span class="hljs-built_in">resize</span>(n);<br>&nbsp; &nbsp; &nbsp; &nbsp; std::<span class="hljs-built_in">iota</span>(p.<span class="hljs-built_in">begin</span>(), p.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>);<br>&nbsp; &nbsp; &nbsp; &nbsp; siz.<span class="hljs-built_in">assign</span>(n, <span class="hljs-number">1</span>);<br>&nbsp; &nbsp; }<br>&nbsp; &nbsp; <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function">&nbsp; &nbsp; </span>{<br>&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">while</span> (x != p[x])<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; x = p[x] = p[p[x]];<br>&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">return</span> x;<br>&nbsp; &nbsp; }<br>&nbsp; &nbsp; <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">same</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>{ <span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(x) == <span class="hljs-built_in">find</span>(y); }<br>&nbsp; &nbsp; <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function">&nbsp; &nbsp; </span>{<br>&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-type">int</span> px = <span class="hljs-built_in">find</span>(x);<br>&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-type">int</span> py = <span class="hljs-built_in">find</span>(y);<br>&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">if</span> (px == py) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&nbsp; &nbsp; &nbsp; &nbsp; siz[px] += siz[py];<br>&nbsp; &nbsp; &nbsp; &nbsp; p[py] = px;<br>&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&nbsp; &nbsp; }<br>&nbsp; &nbsp; <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">size</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>{ <span class="hljs-keyword">return</span> siz[<span class="hljs-built_in">find</span>(x)]; }<br>};<br></code></pre></td></tr></tbody></table></figure>

<h5 id="带权并查集"><a href="#带权并查集" class="headerlink" title="带权并查集"></a>带权并查集</h5><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">DSUV</span><br>{<br>&nbsp; &nbsp; std::vector&lt;<span class="hljs-type">int</span>&gt; p, siz, d;<br>&nbsp; &nbsp; <span class="hljs-built_in">DSUV</span>() {}<br>&nbsp; &nbsp; <span class="hljs-built_in">DSUV</span>(<span class="hljs-type">int</span> n) { <span class="hljs-built_in">init</span>(n); }<br>&nbsp; &nbsp; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function">&nbsp; &nbsp; </span>{<br>&nbsp; &nbsp; &nbsp; &nbsp; p.<span class="hljs-built_in">resize</span>(n);<br>&nbsp; &nbsp; &nbsp; &nbsp; std::<span class="hljs-built_in">iota</span>(p.<span class="hljs-built_in">begin</span>(), p.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>);<br>&nbsp; &nbsp; &nbsp; &nbsp; siz.<span class="hljs-built_in">assign</span>(n, <span class="hljs-number">1</span>);<br>&nbsp; &nbsp; &nbsp; &nbsp; d.<span class="hljs-built_in">assign</span>(n, <span class="hljs-number">0</span>);<br>&nbsp; &nbsp; }<br>&nbsp; &nbsp; <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function">&nbsp; &nbsp; </span>{<br>&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">if</span> (p[x] != x)<br>&nbsp; &nbsp; &nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-type">int</span> u = <span class="hljs-built_in">find</span>(p[x]);<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; d[x] += d[p[x]]; <span class="hljs-comment">// 按情况修改</span><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p[x] = u;<br>&nbsp; &nbsp; &nbsp; &nbsp; }<br>&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">return</span> p[x];<br>&nbsp; &nbsp; }<br>&nbsp; &nbsp; <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">same</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>{ <span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(x) == <span class="hljs-built_in">find</span>(y); }<br>&nbsp; &nbsp; <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> s)</span></span><br><span class="hljs-function">&nbsp; &nbsp; </span>{<br>&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-type">int</span> px = <span class="hljs-built_in">find</span>(x);<br>&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-type">int</span> py = <span class="hljs-built_in">find</span>(y);<br>&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">if</span> (px == py) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&nbsp; &nbsp; &nbsp; &nbsp; siz[px] += siz[py];<br>&nbsp; &nbsp; &nbsp; &nbsp; p[py] = px;<br>&nbsp; &nbsp; &nbsp; &nbsp; d[py] = (d[x] - d[y] + s); <span class="hljs-comment">// s为偏移量，按情况修改</span><br>&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&nbsp; &nbsp; }<br>&nbsp; &nbsp; <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">size</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>{ <span class="hljs-keyword">return</span> siz[<span class="hljs-built_in">find</span>(x)]; }<br>};<br></code></pre></td></tr></tbody></table></figure>
<h5 id="拓展域并查集"><a href="#拓展域并查集" class="headerlink" title="拓展域并查集"></a>拓展域并查集</h5><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//利用p[x + k *n] 来对应不同的情况</span><br><span class="hljs-comment">//例题</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">DSU</span><br>{<br>	std::vector&lt;<span class="hljs-type">int</span>&gt; p, siz;<br>	<span class="hljs-built_in">DSU</span>() {}<br>	<span class="hljs-built_in">DSU</span>(<span class="hljs-type">int</span> n) { <span class="hljs-built_in">init</span>(n); }<br>	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function">	</span>{<br>		p.<span class="hljs-built_in">resize</span>(n);<br>		std::<span class="hljs-built_in">iota</span>(p.<span class="hljs-built_in">begin</span>(), p.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>);<br>		siz.<span class="hljs-built_in">assign</span>(n, <span class="hljs-number">1</span>);<br>	}<br>	<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function">	</span>{<br>		<span class="hljs-keyword">while</span> (x != p[x])<br>		{<br>			x = p[x] = p[p[x]];<br>		}<br>		<span class="hljs-keyword">return</span> x;<br>	}<br>	<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">same</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>{ <span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(x) == <span class="hljs-built_in">find</span>(y); }<br>	<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function">	</span>{<br>		<span class="hljs-type">int</span> px = <span class="hljs-built_in">find</span>(x);<br>		<span class="hljs-type">int</span> py = <span class="hljs-built_in">find</span>(y);<br>		<span class="hljs-keyword">if</span> (px == py)<br>		{<br>			<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>		}<br>		siz[px] += siz[py];<br>		p[py] = px;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>	}<br>	<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">size</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>{ <span class="hljs-keyword">return</span> siz[<span class="hljs-built_in">find</span>(x)]; }<br>};<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>	<span class="hljs-type">int</span> n, k, res = <span class="hljs-number">0</span>;<br>	cin &gt;&gt; n &gt;&gt; k;<br>	<span class="hljs-function">DSU <span class="hljs-title">dsu</span><span class="hljs-params">(<span class="hljs-number">3</span> * (n + <span class="hljs-number">1</span>))</span></span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, d, x, y; i &lt; k; ++i)<br>	{<br>		cin &gt;&gt; d &gt;&gt; x &gt;&gt; y;<br>		<span class="hljs-keyword">if</span> (x &gt; n || y &gt; n)<br>		{<br>			res++;<br>			<span class="hljs-keyword">continue</span>;<br>		}<br>		<span class="hljs-keyword">if</span> (d &amp; <span class="hljs-number">1</span>)<br>		{<br>			<span class="hljs-keyword">if</span> (dsu.<span class="hljs-built_in">same</span>(x + n, y) || dsu.<span class="hljs-built_in">same</span>(x + n + n, y))<br>			{<br>				res++;<br>			}<br>			<span class="hljs-keyword">else</span><br>			{<br>				dsu.<span class="hljs-built_in">merge</span>(x, y);<br>				dsu.<span class="hljs-built_in">merge</span>(x + n, y + n);<br>				dsu.<span class="hljs-built_in">merge</span>(x + n + n, y + n + n);<br>			}<br>		}<br>		<span class="hljs-keyword">else</span><br>		{<br>			<span class="hljs-keyword">if</span> (dsu.<span class="hljs-built_in">same</span>(x + n + n, y) || dsu.<span class="hljs-built_in">same</span>(x, y))<br>			{<br>				res++;<br>			}<br>			<span class="hljs-keyword">else</span><br>			{<br>				dsu.<span class="hljs-built_in">merge</span>(x + n, y);<br>				dsu.<span class="hljs-built_in">merge</span>(x + n + n, y + n);<br>				dsu.<span class="hljs-built_in">merge</span>(x, y + n + n);<br>			}<br>		}<br>	}<br>	cout &lt;&lt; res &lt;&lt; endl;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>

<h4 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h4><p>基础封装 $Onlogn$</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">BIT</span><br>{<br>&nbsp; &nbsp; <span class="hljs-type">int</span> n;<br>&nbsp; &nbsp; vector&lt;<span class="hljs-type">int</span>&gt; w;<br>&nbsp; &nbsp; <span class="hljs-built_in">BIT</span>(<span class="hljs-type">int</span> n)<br>&nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">this</span>-&gt;n = n; <span class="hljs-comment">// 这里必须写 n ，否则会RE</span><br>&nbsp; &nbsp; &nbsp; &nbsp; w.<span class="hljs-built_in">resize</span>(n + <span class="hljs-number">1</span>);<br>&nbsp; &nbsp; }<br>&nbsp; &nbsp; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> k)</span></span><br><span class="hljs-function">&nbsp; &nbsp; </span>{<br>&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">for</span> (; x &lt;= n; x += x &amp; -x)<br>&nbsp; &nbsp; &nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; w[x] += k;<br>&nbsp; &nbsp; &nbsp; &nbsp; }<br>&nbsp; &nbsp; }<br><br>&nbsp; &nbsp; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> k)</span></span><br><span class="hljs-function">&nbsp; &nbsp; </span>{ <span class="hljs-comment">// 区间修改</span><br>&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-built_in">add</span>(x, k), <span class="hljs-built_in">add</span>(y, -k);<br>&nbsp; &nbsp; }<br>&nbsp; &nbsp; <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ask</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function">&nbsp; &nbsp; </span>{<br>&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">for</span> (; x; x -= x &amp; -x)<br>&nbsp; &nbsp; &nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ans += w[x];<br>&nbsp; &nbsp; &nbsp; &nbsp; }<br>&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">return</span> ans;<br>&nbsp; &nbsp; }<br>&nbsp; &nbsp; <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ask</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function">&nbsp; &nbsp; </span>{ <span class="hljs-comment">// 区间查询</span><br>&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">return</span> <span class="hljs-built_in">ask</span>(y) - <span class="hljs-built_in">ask</span>(x - <span class="hljs-number">1</span>);<br>&nbsp; &nbsp; }<br>&nbsp; &nbsp; <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">kth</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span></span><br><span class="hljs-function">&nbsp; &nbsp; </span>{ <span class="hljs-comment">// ex: 查找第k大的值</span><br>&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = __lg(n); i &gt;= <span class="hljs-number">0</span>; i--)<br>&nbsp; &nbsp; &nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-type">int</span> val = ans + (<span class="hljs-number">1</span> &lt;&lt; i);<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">if</span> (val &lt; n &amp;&amp; w[val] &lt; k)<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; k -= w[val];<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ans = val;<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br>&nbsp; &nbsp; &nbsp; &nbsp; }<br>&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">return</span> ans + <span class="hljs-number">1</span>;<br>&nbsp; &nbsp; }<br>};<br></code></pre></td></tr></tbody></table></figure>

<h3 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h3><h4 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h4><h5 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h5><p>$O(mlogm)$</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">DSU</span><br>{<br>	std::vector&lt;<span class="hljs-type">int</span>&gt; p, siz;<br>	<span class="hljs-built_in">DSU</span>() {}<br>	<span class="hljs-built_in">DSU</span>(<span class="hljs-type">int</span> n) { <span class="hljs-built_in">init</span>(n); }<br>	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function">	</span>{<br>		p.<span class="hljs-built_in">resize</span>(n);<br>		std::<span class="hljs-built_in">iota</span>(p.<span class="hljs-built_in">begin</span>(), p.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>);<br>		siz.<span class="hljs-built_in">assign</span>(n, <span class="hljs-number">1</span>);<br>	}<br>	<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function">	</span>{<br>		<span class="hljs-keyword">while</span> (x != p[x])<br>		{<br>			x = p[x] = p[p[x]];<br>		}<br>		<span class="hljs-keyword">return</span> x;<br>	}<br>	<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">same</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>{ <span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(x) == <span class="hljs-built_in">find</span>(y); }<br>	<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function">	</span>{<br>		<span class="hljs-type">int</span> px = <span class="hljs-built_in">find</span>(x);<br>		<span class="hljs-type">int</span> py = <span class="hljs-built_in">find</span>(y);<br>		<span class="hljs-keyword">if</span> (px == py)<br>		{<br>			<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>		}<br>		siz[px] += siz[py];<br>		p[py] = px;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>	}<br>	<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">size</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>{ <span class="hljs-keyword">return</span> siz[<span class="hljs-built_in">find</span>(x)]; }<br>};<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MST</span><br>{<br>	<span class="hljs-keyword">using</span> TII = tuple&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;;<br>	<span class="hljs-type">int</span> n;<br>	priority_queue&lt;TII,vector&lt;TII&gt;,greater&lt;TII&gt;&gt; eg;<br>	<span class="hljs-built_in">MST</span>(<span class="hljs-type">int</span> n) : <span class="hljs-built_in">n</span>(n){}<br>	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> w)</span></span><br><span class="hljs-function">	</span>{<br>		eg.<span class="hljs-built_in">emplace</span>(w,x,y);<br>	}<br>	<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">kruskal</span><span class="hljs-params">()</span></span><br><span class="hljs-function">	</span>{<br>		<span class="hljs-function">DSU <span class="hljs-title">dsu</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>		<span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>,cnt = <span class="hljs-number">0</span>,w,x,y;<br>		<span class="hljs-keyword">while</span>(eg.<span class="hljs-built_in">size</span>())<br>		{<br>			<span class="hljs-built_in">tie</span>(w,x,y) = eg.<span class="hljs-built_in">top</span>();<br>			eg.<span class="hljs-built_in">pop</span>();<br>			<span class="hljs-keyword">if</span>(dsu.<span class="hljs-built_in">same</span>(x,y)) <span class="hljs-keyword">continue</span>;<br>			dsu.<span class="hljs-built_in">merge</span>(x,y);<br>			ans += w;<br>			cnt ++ ;<br>		}<br>		<span class="hljs-keyword">if</span>(cnt &lt; n - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> INF;<br>		<span class="hljs-keyword">return</span> ans;<br>	}<br>};<br></code></pre></td></tr></tbody></table></figure>

<h4 id="全源最短路"><a href="#全源最短路" class="headerlink" title="全源最短路"></a>全源最短路</h4><h5 id="Djkstra堆优化-正权稀疏图"><a href="#Djkstra堆优化-正权稀疏图" class="headerlink" title="Djkstra堆优化(正权稀疏图)"></a>Djkstra堆优化(正权稀疏图)</h5><p>$O(MlogN)$</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dis</span><span class="hljs-params">(n + <span class="hljs-number">1</span>,<span class="hljs-number">0x3f3f3f3f</span>)</span></span>;<br><span class="hljs-keyword">auto</span> dijkstra = [&amp;](<span class="hljs-type">int</span> s = <span class="hljs-number">1</span>) -&gt;<span class="hljs-type">void</span><br>{<br>	<span class="hljs-type">int</span> y,w;<br>	<span class="hljs-keyword">using</span> PII = pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;;<br>	priority_queue&lt;PII,vector&lt;PII&gt;,greater&lt;PII&gt; &gt; q;<br>	q.<span class="hljs-built_in">emplace</span>(<span class="hljs-number">0</span>,s);<br>	dis[s] = <span class="hljs-number">0</span>;<br>	<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">st</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>	<span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>())<br>	{<br>		<span class="hljs-type">int</span> x = q.<span class="hljs-built_in">top</span>().second;<br>		q.<span class="hljs-built_in">pop</span>();<br>		<span class="hljs-keyword">if</span>(st[x]) <span class="hljs-keyword">continue</span>;<br>		st[x] = <span class="hljs-number">1</span>;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> el : h[x])<br>		{<br>			<span class="hljs-built_in">tie</span>(y,w) = el;<br>			<span class="hljs-keyword">if</span>(dis[y] &gt; dis[x] + w)<br>			{<br>				dis[y] = dis[x] + w;<br>				q.<span class="hljs-built_in">emplace</span>(dis[y],y);<br>			}<br>		}<br>	}<br>};<br></code></pre></td></tr></tbody></table></figure>
<h5 id="Djkstra-正权稠密图"><a href="#Djkstra-正权稠密图" class="headerlink" title="Djkstra(正权稠密图)"></a>Djkstra(正权稠密图)</h5><p>$O(n^2)$</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">3010</span>;<br><span class="hljs-type">int</span> n,m,g[N][N];<br><span class="hljs-type">int</span> d[N],st[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dji</span><span class="hljs-params">(<span class="hljs-type">int</span> s = <span class="hljs-number">1</span>)</span></span>{<br>	<span class="hljs-built_in">memset</span>(d,<span class="hljs-number">0x3f</span>,<span class="hljs-keyword">sizeof</span> d); d[s] = <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>	{<br>		<span class="hljs-type">int</span> x = <span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;++j)<br>		{<br>			<span class="hljs-keyword">if</span>(st[j]) <span class="hljs-keyword">continue</span>;<br>			<span class="hljs-keyword">if</span>(x == <span class="hljs-number">0</span>|| d[j] &lt; d[x]) x = j;<br>		}<br>		st[x] = <span class="hljs-number">1</span>;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;++j) d[j] = <span class="hljs-built_in">min</span>(d[j],d[x] + g[x][j]);<br>	}<br>}<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>	cin &gt;&gt; n &gt;&gt; m;<br>	<span class="hljs-built_in">memset</span>(g,<span class="hljs-number">0x3f</span>,<span class="hljs-keyword">sizeof</span> g);<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i)<br>	{<br>		<span class="hljs-type">int</span> x,y,w;cin &gt;&gt; x &gt;&gt; y &gt;&gt; w;<br>		g[x][y] = <span class="hljs-built_in">min</span>(g[x][y],w);<span class="hljs-comment">//考虑重边</span><br>		g[y][x] = <span class="hljs-built_in">min</span>(g[y][x],w);<span class="hljs-comment">//无向图</span><br>	}<br>	<span class="hljs-built_in">dji</span>();<br>	<span class="hljs-keyword">if</span>(d[n] == INF) cout &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; endl;<br>	<span class="hljs-keyword">else</span> cout &lt;&lt; d[n] &lt;&lt; endl;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>
<h5 id="Bellman-Ford"><a href="#Bellman-Ford" class="headerlink" title="Bellman_Ford"></a>Bellman_Ford</h5><p>使用结构体存边（该算法无需存图），以&nbsp;$O(NM)$的复杂度计算,当所求点的路径上存在负环时，所求点的答案无法得到，但是会比 INF 小。</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//求解从&nbsp;1 到&nbsp;n&nbsp;号节点的、最多经过&nbsp;k&nbsp;条边的最短距离。</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">510</span>,M = <span class="hljs-number">10010</span>;<br><span class="hljs-type">int</span> dis[N],backup[N];<br>vector&lt;tuple&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; &gt; eg;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bellman_ford</span><span class="hljs-params">(<span class="hljs-type">int</span> s = <span class="hljs-number">1</span>)</span></span><br><span class="hljs-function"></span>{<br>&nbsp; &nbsp; <span class="hljs-type">int</span> u,v,w;<br>&nbsp; &nbsp; <span class="hljs-built_in">memset</span>(dis,<span class="hljs-number">0x3f</span>,<span class="hljs-keyword">sizeof</span> dis);<br>&nbsp; &nbsp; dis[s] = <span class="hljs-number">0</span>;<br>&nbsp; &nbsp; <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;k;++i)<br>&nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-built_in">memcpy</span>(backup,dis,<span class="hljs-keyword">sizeof</span> dis);<br>&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;m; ++ j)<br>&nbsp; &nbsp; &nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-built_in">tie</span>(u,v,w) = eg[j];<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dis[v] = <span class="hljs-built_in">min</span>(dis[v],backup[u] + w);<br>&nbsp; &nbsp; &nbsp; &nbsp; }<br>&nbsp; &nbsp; }<br>}<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>&nbsp; &nbsp; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;<br>&nbsp; &nbsp; <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,a,b,w;i&lt;m;++i)<br>&nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; &nbsp; cin &gt;&gt; a &gt;&gt; b &gt;&gt; w;<br>&nbsp; &nbsp; &nbsp; &nbsp; eg.<span class="hljs-built_in">emplace_back</span>(a,b,w);<br>&nbsp; &nbsp; }<br>&nbsp; &nbsp; <span class="hljs-built_in">bellman_ford</span>();<br>&nbsp; &nbsp; <span class="hljs-keyword">if</span>(dis[n] &gt; INF / <span class="hljs-number">2</span>) <span class="hljs-built_in">puts</span>(<span class="hljs-string">"impossible"</span>);<br>&nbsp; &nbsp; <span class="hljs-keyword">else</span> cout &lt;&lt; dis[n] &lt;&lt; endl;<br>&nbsp; &nbsp; <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>

<h5 id="Spfa"><a href="#Spfa" class="headerlink" title="Spfa"></a>Spfa</h5><p>以&nbsp;$O(KM)$的复杂度计算，其中&nbsp;$K$&nbsp;虽然为常数，但是可以通过特殊的构造退化成接近&nbsp;$N$&nbsp;，需要注意被卡,注意判断负环，dis数组里面值必须一致。</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dis</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">0x3f3f3f3f</span>)</span></span>;<br><span class="hljs-keyword">auto</span> spfa = [&amp;](<span class="hljs-type">int</span> s = <span class="hljs-number">1</span>) -&gt; <span class="hljs-type">bool</span> {<br>    <span class="hljs-type">int</span> y, w;<br>    <span class="hljs-keyword">using</span> PII = pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">st</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">cnt</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    q.<span class="hljs-built_in">emplace</span>(s);<span class="hljs-comment">//</span><br>    dis[s] = <span class="hljs-number">0</span>;<span class="hljs-comment">//</span><br>    st[s] = <span class="hljs-number">1</span>;<span class="hljs-comment">//</span><br>    <span class="hljs-comment">// for(int i=1;i&lt;=n;++i) q.emplace(i),st[i] = 1;//判断负环，一般要全部点加入</span><br>    <span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">size</span>()) {<br>        <span class="hljs-keyword">auto</span> x = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        st[x] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> el : h[x]) {<br>            <span class="hljs-comment">// tie(y,w) = el; // tie开销更大可能会超时</span><br>            y = el.first, w = el.second;<br>            <span class="hljs-keyword">if</span> (dis[y] &gt; dis[x] + w) {<br>                dis[y] = dis[x] + w;<br>                cnt[y] = cnt[x] + <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span> (cnt[y] &gt;= n)<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">if</span> (!st[y])<br>                    q.<span class="hljs-built_in">emplace</span>(y), st[y] = <span class="hljs-number">1</span>;<br>            }<br>        }<br>    }<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>};<br><br></code></pre></td></tr></tbody></table></figure>
<h5 id="Floyd"><a href="#Floyd" class="headerlink" title="Floyd"></a>Floyd</h5><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//初始化：</span><br>&nbsp; &nbsp; <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++ )<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">if</span> (i == j) d[i][j] = <span class="hljs-number">0</span>;<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">else</span> d[i][j] = INF;<br><span class="hljs-comment">// 算法结束后，d[a][b]表示a到b的最短距离</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">floyd</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>&nbsp; &nbsp; <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= n; k ++ )<br>&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++ )<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; d[i][j] = <span class="hljs-built_in">min</span>(d[i][j], d[i][k] + d[k][j]);<br>}<br></code></pre></td></tr></tbody></table></figure>
<h4 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h4><p>时间复杂度 $O(V+E)$</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><code class="hljs c++">vector&lt;<span class="hljs-type">int</span>&gt; h[N];<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">d</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>vector&lt;<span class="hljs-type">int</span>&gt; ans;<br><span class="hljs-keyword">auto</span> topsort = [&amp;]() -&gt; <span class="hljs-type">void</span><br>{<br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>&nbsp; &nbsp; <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)<br>&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">if</span> (!d[i])<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; q.<span class="hljs-built_in">push</span>(i);<br>&nbsp; &nbsp; <span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">size</span>())<br>&nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">auto</span> t = q.<span class="hljs-built_in">front</span>();<br>&nbsp; &nbsp; &nbsp; &nbsp; q.<span class="hljs-built_in">pop</span>();<br>&nbsp; &nbsp; &nbsp; &nbsp; ans.<span class="hljs-built_in">push_back</span>(t);<br>&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> el : h[t])<br>&nbsp; &nbsp; &nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">if</span>( -- d[el] == <span class="hljs-number">0</span>)<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; q.<span class="hljs-built_in">push</span>(el);<br>&nbsp; &nbsp; &nbsp; &nbsp; }<br>&nbsp; &nbsp; }<br>};<br></code></pre></td></tr></tbody></table></figure>
<h4 id="LCA最近公共祖先"><a href="#LCA最近公共祖先" class="headerlink" title="LCA最近公共祖先"></a>LCA最近公共祖先</h4><p>预处理时间复杂度&nbsp;$O(NlogN)$&nbsp;；单次查询&nbsp;$O(logN)$</p>
<h5 id="基础封装，无权图"><a href="#基础封装，无权图" class="headerlink" title="基础封装，无权图"></a>基础封装，无权图</h5><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">LCA</span> {<br>&nbsp; &nbsp; <span class="hljs-type">int</span> n;<br>&nbsp; &nbsp; vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; h,f;<span class="hljs-comment">//存图，从i开始向上走2^j步到的点</span><br>&nbsp; &nbsp; vector&lt;<span class="hljs-type">int</span>&gt; dep,lg;<br>&nbsp; &nbsp; <span class="hljs-built_in">LCA</span>(<span class="hljs-type">int</span> n) {<br>&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">this</span>-&gt;n = n;<br>&nbsp; &nbsp; &nbsp; &nbsp; h.<span class="hljs-built_in">resize</span>(n + <span class="hljs-number">1</span>);<br>&nbsp; &nbsp; &nbsp; &nbsp; f.<span class="hljs-built_in">resize</span>(n + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">30</span>));<br>&nbsp; &nbsp; &nbsp; &nbsp; dep.<span class="hljs-built_in">resize</span>(n + <span class="hljs-number">1</span>);<br>&nbsp; &nbsp; &nbsp; &nbsp; lg.<span class="hljs-built_in">resize</span>(n + <span class="hljs-number">1</span>);<br>&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lg[i] = lg[i<span class="hljs-number">-1</span>] + (<span class="hljs-number">1</span> &lt;&lt; lg[i<span class="hljs-number">-1</span>] == i);<br>&nbsp; &nbsp; }<br>&nbsp; &nbsp; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>{ <span class="hljs-comment">// 建立双向边</span><br>&nbsp; &nbsp; &nbsp; &nbsp; h[x].<span class="hljs-built_in">push_back</span>(y);<br>&nbsp; &nbsp; &nbsp; &nbsp; h[y].<span class="hljs-built_in">push_back</span>(x);<br>&nbsp; &nbsp; }<br>&nbsp; &nbsp; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> fa)</span> </span>{<br>&nbsp; &nbsp; &nbsp; &nbsp; f[x][<span class="hljs-number">0</span>] = fa; <span class="hljs-comment">// 储存 x 的父节点</span><br>&nbsp; &nbsp; &nbsp; &nbsp; dep[x] = dep[fa] + <span class="hljs-number">1</span>;<br>&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= lg[dep[x]]; i++) {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; f[x][i] = f[f[x][i - <span class="hljs-number">1</span>]][i - <span class="hljs-number">1</span>];<br>&nbsp; &nbsp; &nbsp; &nbsp; }<br>&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : h[x]) {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">if</span> (y == fa) <span class="hljs-keyword">continue</span>;<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-built_in">dfs</span>(y, x);<br>&nbsp; &nbsp; &nbsp; &nbsp; }<br>&nbsp; &nbsp; }<br>&nbsp; &nbsp; <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lca</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>{<br>&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">if</span> (dep[x] &lt; dep[y]) <span class="hljs-built_in">swap</span>(x, y);<span class="hljs-comment">//保证x更深</span><br>&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">while</span> (dep[x] &gt; dep[y]) {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; x = f[x][lg[dep[x] - dep[y]] - <span class="hljs-number">1</span>];<br>&nbsp; &nbsp; &nbsp; &nbsp; }<br>&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">if</span> (x == y) <span class="hljs-keyword">return</span> x;<br>&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = lg[dep[x]] - <span class="hljs-number">1</span>; k &gt;= <span class="hljs-number">0</span>; k--) {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">if</span> (f[x][k] == f[y][k]) <span class="hljs-keyword">continue</span>;<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; x = f[x][k];<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; y = f[y][k];<br>&nbsp; &nbsp; &nbsp; &nbsp; }<br>&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">return</span> f[x][<span class="hljs-number">0</span>];<br>&nbsp; &nbsp; }<br>&nbsp; &nbsp; <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">clac</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>{ <span class="hljs-comment">// 倍增查询两点间距离</span><br>&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">return</span> dep[x] + dep[y] - <span class="hljs-number">2</span> * dep[<span class="hljs-built_in">lca</span>(x, y)];<br>&nbsp; &nbsp; }<br>&nbsp; &nbsp; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">(<span class="hljs-type">int</span> root = <span class="hljs-number">1</span>)</span> </span>{ <span class="hljs-comment">// 在此初始化</span><br>&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-built_in">dfs</span>(root, <span class="hljs-number">0</span>);<br>&nbsp; &nbsp; }<br>};<br></code></pre></td></tr></tbody></table></figure>

<h3 id="数论"><a href="#数论" class="headerlink" title="数论"></a>数论</h3><h4 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h4><p>求 m^k mod p，时间复杂度 O(logk)</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">qmi</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> p)</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">1</span> % p, t = m;<br>    <span class="hljs-keyword">while</span> (k)<br>    {<br>        <span class="hljs-keyword">if</span> (k&amp;<span class="hljs-number">1</span>) res = res * t % p;<br>        t = t * t % p;<br>        k &gt;&gt;= <span class="hljs-number">1</span>;<br>    }<br>    <span class="hljs-keyword">return</span> res;<br>}<br></code></pre></td></tr></tbody></table></figure>
<h4 id="组合数"><a href="#组合数" class="headerlink" title="组合数"></a>组合数</h4><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">C</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>{<br>&nbsp; &nbsp; LL res = <span class="hljs-number">1</span>;<br>&nbsp; &nbsp; <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=a,j=<span class="hljs-number">1</span>;j&lt;=b;i--,j++)<br>&nbsp; &nbsp; &nbsp; &nbsp; res = res * i/j;<br>&nbsp; &nbsp; <span class="hljs-keyword">return</span> res;<br>}<br></code></pre></td></tr></tbody></table></figure>

<h4 id="欧几里得算法"><a href="#欧几里得算法" class="headerlink" title="欧几里得算法"></a>欧几里得算法</h4><h5 id="gcd"><a href="#gcd" class="headerlink" title="gcd"></a>gcd</h5><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>{<br>	<span class="hljs-keyword">return</span> b ? <span class="hljs-built_in">gcd</span>(b,a % b) : a;<br>}<br></code></pre></td></tr></tbody></table></figure>
<h5 id="lcm"><a href="#lcm" class="headerlink" title="lcm"></a>lcm</h5><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lcm</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>{<br>	<span class="hljs-keyword">return</span> a / <span class="hljs-built_in">gcd</span>(a,b) *b;<br>}<br></code></pre></td></tr></tbody></table></figure>
<h5 id="拓展欧几里得算法"><a href="#拓展欧几里得算法" class="headerlink" title="拓展欧几里得算法"></a>拓展欧几里得算法</h5><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">exgcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span> &amp;x,<span class="hljs-type">int</span> &amp;y)</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-keyword">if</span>(!b)<br>    {<br>        x = <span class="hljs-number">1</span>,y = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> a;<br>    }<br>    <span class="hljs-type">int</span> d = <span class="hljs-built_in">exgcd</span>(b,a%b,y,x);<br>    y -= a / b * x;<span class="hljs-comment">//公式</span><br>    <span class="hljs-keyword">return</span> d;<br>}<br></code></pre></td></tr></tbody></table></figure>

<h4 id="质数"><a href="#质数" class="headerlink" title="质数"></a>质数</h4><h5 id="试除法"><a href="#试除法" class="headerlink" title="试除法"></a>试除法</h5><p>时间复杂度$O(\sqrt n)$ </p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Is_prime</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-keyword">if</span>(n&lt;<span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n/i;++i)<br>        <span class="hljs-keyword">if</span>(n%i==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>
<h5 id="线性筛"><a href="#线性筛" class="headerlink" title="线性筛"></a>线性筛</h5><p>时间复杂度$O(n)$ </p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> primes[N],cnt;<span class="hljs-comment">//存所有质数</span><br><span class="hljs-type">bool</span> st[N];<span class="hljs-comment">//记录i有没有被筛过</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get_primes</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span><span class="hljs-comment">//筛选2~n的素数</span></span><br><span class="hljs-function"></span>{<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;++i)<br>	{<br>		<span class="hljs-keyword">if</span>(!st[i]) primes[cnt++] = i;<span class="hljs-comment">//如果没有被筛过,证明是素数</span><br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;primes[j] * i &lt;=n;j++)<br>		{<br>		<span class="hljs-comment">/*p[j]一定小于等于i的质因子*/</span><br>			st[primes[j] * i] = <span class="hljs-literal">true</span>;<span class="hljs-comment">//用最小质因子筛掉合数</span><br>			<span class="hljs-keyword">if</span>(i%primes[j] == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>		}<br>	}<br>}<br></code></pre></td></tr></tbody></table></figure>
<p>存最小质因子</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> primes[N],cnt;<span class="hljs-comment">//存所有质数</span><br><span class="hljs-type">bool</span> st[N];<span class="hljs-comment">//记录i有没有被筛过</span><br><span class="hljs-comment">//****</span><br><span class="hljs-type">int</span> minp[N];<span class="hljs-comment">//每个数的最小质因子</span><br><span class="hljs-comment">//****</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get_primes</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span><span class="hljs-comment">//筛选2~n的素数</span></span><br><span class="hljs-function"></span>{<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;++i)<br>	{<br>		<span class="hljs-keyword">if</span>(!st[i]) minp[i]=i,primes[cnt++] = i;<span class="hljs-comment">//如果没有被筛过,证明是素数</span><br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;primes[j] * i &lt;=n;j++)<br>		{<br>		<span class="hljs-comment">/*p[j]一定小于等于i的质因子*/</span><br>			st[primes[j] * i] = <span class="hljs-literal">true</span>;<span class="hljs-comment">//用最小质因子筛掉合数</span><br>			minp[primes[j] * i] = primes[j];<br>			<span class="hljs-keyword">if</span>(i%primes[j] == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>		}<br>	}<br>}<br></code></pre></td></tr></tbody></table></figure>
<p>存储约数个数及其i的最小素因子个数</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">2e7</span>+<span class="hljs-number">3</span>;<br><span class="hljs-type">int</span> primes[N],cnt;<span class="hljs-comment">//存所有质数</span><br><span class="hljs-type">bool</span> st[N];<span class="hljs-comment">//记录i有没有被筛过</span><br><span class="hljs-comment">//****</span><br><span class="hljs-type">int</span> minp[N];<span class="hljs-comment">//每个数的最小质因子</span><br><span class="hljs-type">int</span> d[N];<span class="hljs-comment">//表示i的约数的个数</span><br><span class="hljs-type">int</span> num[N];<span class="hljs-comment">//表示i的最小素因子的个数</span><br><span class="hljs-comment">//****</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get_primes</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span><span class="hljs-comment">//筛选2~n的素数</span></span><br><span class="hljs-function"></span>{<br>    d[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;++i)<br>	{<br>		<span class="hljs-keyword">if</span>(!st[i]) minp[i]=i,primes[cnt++] = i,num[i] = <span class="hljs-number">1</span>,d[i] = <span class="hljs-number">2</span>;<span class="hljs-comment">//如果没有被筛过,证明是素数</span><br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;primes[j] * i &lt;=n;j++)<br>		{<br>		<span class="hljs-comment">/*p[j]一定小于等于i的质因子*/</span><br>			st[primes[j] * i] = <span class="hljs-literal">true</span>;<span class="hljs-comment">//用最小质因子筛掉合数</span><br>			minp[primes[j] * i] = primes[j];<br>			<span class="hljs-keyword">if</span>(i%primes[j] == <span class="hljs-number">0</span>)<br>            {<br>                num[primes[j] * i] = num[i] + <span class="hljs-number">1</span>;<br>                d[primes[j] * i] = d[i] / num[primes[j] * i] * (num[primes[j]*i] + <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">break</span>;<br>            }<br>            num[primes[j] * i] = <span class="hljs-number">1</span>;<br>            d[primes[j] * i] = d[i] * <span class="hljs-number">2</span>;<br>		}<br>	}<br>}<br></code></pre></td></tr></tbody></table></figure>


<h3 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h3><h5 id="莫队"><a href="#莫队" class="headerlink" title="莫队"></a>莫队</h5><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>&nbsp; &nbsp; <span class="hljs-type">int</span> n, m;<br>&nbsp; &nbsp; cin &gt;&gt; n &gt;&gt; m;<br>&nbsp; &nbsp; i64 kn = n / <span class="hljs-built_in">min</span>&lt;<span class="hljs-type">int</span>&gt;(n, <span class="hljs-built_in">sqrt</span>(m));<br>&nbsp; &nbsp; <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">K</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>&nbsp; &nbsp; <span class="hljs-function">vector&lt;i64&gt; <span class="hljs-title">ans</span><span class="hljs-params">(m + <span class="hljs-number">1</span>)</span></span>;<br>&nbsp; &nbsp; vector&lt;array&lt;<span class="hljs-type">int</span>, 3&gt;&gt; <span class="hljs-built_in">query</span>(m + <span class="hljs-number">1</span>);<br>&nbsp; &nbsp; <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)<br>&nbsp; &nbsp; &nbsp; &nbsp; cin &gt;&gt; v[i], K[i] = (i - <span class="hljs-number">1</span>) / kn + <span class="hljs-number">1</span>;<br>&nbsp; &nbsp; <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++i)<br>&nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-type">int</span> l, r;<br>&nbsp; &nbsp; &nbsp; &nbsp; cin &gt;&gt; l &gt;&gt; r;<br>&nbsp; &nbsp; &nbsp; &nbsp; query[i] = {l, r, i};<br>&nbsp; &nbsp; }<br>&nbsp; &nbsp; <span class="hljs-built_in">sort</span>(query.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">1</span>, query.<span class="hljs-built_in">end</span>(), [&amp;](<span class="hljs-keyword">auto</span> x, <span class="hljs-keyword">auto</span> y)<br>&nbsp; &nbsp; &nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">if</span>(K[x[<span class="hljs-number">0</span>]] != K[y[<span class="hljs-number">0</span>]]) <span class="hljs-keyword">return</span> x[<span class="hljs-number">0</span>] &lt; y[<span class="hljs-number">0</span>];<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">if</span>(K[x[<span class="hljs-number">0</span>]] &amp; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> x[<span class="hljs-number">1</span>] &lt; y[<span class="hljs-number">1</span>];<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">return</span> x[<span class="hljs-number">1</span>] &gt; y[<span class="hljs-number">1</span>];<br>&nbsp; &nbsp; &nbsp; &nbsp; });<br>&nbsp; &nbsp; <span class="hljs-type">int</span> l = <span class="hljs-number">1</span>, r = <span class="hljs-number">0</span>, val = <span class="hljs-number">0</span>;<br>&nbsp; &nbsp; <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++i)<br>&nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">auto</span> &amp;e = query[i];<br>&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-type">int</span> ql = e[<span class="hljs-number">0</span>], qr = e[<span class="hljs-number">1</span>], id = e[<span class="hljs-number">2</span>];<br>&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">auto</span> add = [&amp;](<span class="hljs-type">int</span> x) -&gt; <span class="hljs-type">void</span> {<br>&nbsp; <br>		};<br>&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">auto</span> sub = [&amp;](<span class="hljs-type">int</span> x) -&gt; <span class="hljs-type">void</span> {<br>  <br>&nbsp; &nbsp; &nbsp; &nbsp; };<br>&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">while</span> (l &gt; ql) <span class="hljs-built_in">add</span>(v[--l]);<br>&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">while</span> (r &lt; qr) <span class="hljs-built_in">add</span>(v[++r]);<br>&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">while</span> (l &lt; ql) <span class="hljs-built_in">sub</span>(v[l++]);<br>&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">while</span> (r &gt; qr) <span class="hljs-built_in">sub</span>(v[r--]);<br>&nbsp; &nbsp; &nbsp; &nbsp; ans[id] = val;<br>&nbsp; &nbsp; }<br>&nbsp; &nbsp; <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++i) cout &lt;&lt; ans[i] &lt;&lt; endl;<br>&nbsp; &nbsp; <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>

<h5 id="带修莫队"><a href="#带修莫队" class="headerlink" title="带修莫队"></a>带修莫队</h5><p>单点修改</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-type">int</span> n,m;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-type">int</span> kn = <span class="hljs-built_in">pow</span>(n,<span class="hljs-number">0.6666</span>);<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>,<span class="hljs-title">K</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>    vector&lt;array&lt;<span class="hljs-type">int</span>,4&gt;&gt; query = {{}};<span class="hljs-comment">//l,r,time,id</span><br>    vector&lt;array&lt;<span class="hljs-type">int</span>,2&gt;&gt; modify = {{}};<span class="hljs-comment">//下标，值</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) cin &gt;&gt; v[i],K[i] = (i<span class="hljs-number">-1</span>)/kn + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i)<br>    {<br>        string s;<span class="hljs-type">int</span> x,y;cin &gt;&gt; s &gt;&gt; x &gt;&gt; y;<br>        <span class="hljs-keyword">if</span>(s == <span class="hljs-string">"Q"</span>) query.<span class="hljs-built_in">emplace_back</span>(x,y,(<span class="hljs-type">int</span>)modify.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>,(<span class="hljs-type">int</span>)query.<span class="hljs-built_in">size</span>());<br>        <span class="hljs-keyword">else</span> modify.<span class="hljs-built_in">emplace_back</span>(x,y);<br>    }<br>    <span class="hljs-built_in">sort</span>(query.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">1</span>,query.<span class="hljs-built_in">end</span>(),[&amp;](<span class="hljs-keyword">auto</span> x,<span class="hljs-keyword">auto</span> y){<br>        <span class="hljs-keyword">if</span>(K[x[<span class="hljs-number">0</span>]] != K[y[<span class="hljs-number">0</span>]]) <span class="hljs-keyword">return</span> x[<span class="hljs-number">0</span>] &lt; y[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">if</span>(K[x[<span class="hljs-number">1</span>]] != K[y[<span class="hljs-number">1</span>]]) <span class="hljs-keyword">return</span> x[<span class="hljs-number">1</span>] &lt; y[<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">return</span> x[<span class="hljs-number">3</span>] &lt; y[<span class="hljs-number">3</span>];<br>    });<br>    <span class="hljs-type">int</span> l = <span class="hljs-number">1</span>,r = <span class="hljs-number">0</span>,val = <span class="hljs-number">0</span>,t = <span class="hljs-number">0</span>;<span class="hljs-comment">//t为累计修改次数</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;query.<span class="hljs-built_in">size</span>(); ++ i)<br>    {<br>        <span class="hljs-keyword">auto</span> &amp;e = query[i];<br>        <span class="hljs-type">int</span> ql = e[<span class="hljs-number">0</span>],qr = e[<span class="hljs-number">1</span>],qt = e[<span class="hljs-number">2</span>],id = e[<span class="hljs-number">3</span>];<br>        <span class="hljs-keyword">auto</span> add = [&amp;](<span class="hljs-type">int</span> x) -&gt; <span class="hljs-type">void</span> {<br><br>        };<br>        <span class="hljs-keyword">auto</span> sub = [&amp;](<span class="hljs-type">int</span> x) -&gt; <span class="hljs-type">void</span> {<br><br>        };<br>        <span class="hljs-keyword">auto</span> time = [&amp;](<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r) -&gt; <span class="hljs-type">void</span> {<br>            <span class="hljs-type">int</span> &amp;w = modify[x][<span class="hljs-number">1</span>], id = modify[x][<span class="hljs-number">0</span>];<span class="hljs-comment">//记得引用</span><br>            <span class="hljs-keyword">if</span>(l &lt;= id &amp;&amp; id &lt;= r)<br>            {<br>                <span class="hljs-built_in">sub</span>(v[id]);<br>                <span class="hljs-built_in">add</span>(w);<br>            }<br>            <span class="hljs-built_in">swap</span>(v[id],w);<br>        };<br>        <span class="hljs-keyword">while</span> (l &gt; ql) <span class="hljs-built_in">add</span>(w[--l]);<br>        <span class="hljs-keyword">while</span> (r &lt; qr) <span class="hljs-built_in">add</span>(w[++r]);<br>        <span class="hljs-keyword">while</span> (l &lt; ql) <span class="hljs-built_in">sub</span>(w[l++]);<br>        <span class="hljs-keyword">while</span> (r &gt; qr) <span class="hljs-built_in">sub</span>(w[r--]);<br>        <span class="hljs-keyword">while</span> (t &lt; qt) <span class="hljs-built_in">time</span>(++t, ql, qr);<br>        <span class="hljs-keyword">while</span> (t &gt; qt) <span class="hljs-built_in">time</span>(t--, ql, qr);<br>        ans[id] = val;<br>    }<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=ans.<span class="hljs-built_in">size</span>();++i) cout &lt;&lt; ans[i] &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br><br></code></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>算法模板</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>资料分析</title>
    <url>/posts/9362be7c/</url>
    <content><![CDATA[<h1 id="资料分析"><a href="#资料分析" class="headerlink" title="资料分析"></a>资料分析</h1><h2 id="考点"><a href="#考点" class="headerlink" title="考点"></a>考点</h2><ol>
<li>ABRX</li>
</ol>
<h2 id="ABRX类"><a href="#ABRX类" class="headerlink" title="ABRX类"></a>ABRX类</h2><h3 id="基本公式"><a href="#基本公式" class="headerlink" title="基本公式"></a>基本公式</h3><p>$$基期A = \frac{B}{1+R} = \frac{X}{R}$$<br>$$现期B = A+A<em>R$$<br>$$增量X = B-A = \frac{B}{1+R} * R = A * R$$<br>$$隔年增长率q=q_1+q_2+q_1</em>q_2$$</p>
<h3 id="A类"><a href="#A类" class="headerlink" title="A类"></a>A类</h3><ul>
<li>一般基期：代入、直除、假设分配；</li>
<li>间隔基期：求出隔年增长率，即变成第一类考法；</li>
<li>基期差值：假设分配法求得两个基期作差。</li>
<li>已知变化情况求基期：利用$A = \frac{X}{R}$求出基期。</li>
</ul>
<h3 id="B类"><a href="#B类" class="headerlink" title="B类"></a>B类</h3><ul>
<li>假设增量求后期：求出 $X$，列不等式即可；</li>
<li>假设增速求后期：利用公式“$B＝A＋AR$”依次求出后一年，一般两到三次即可求得答案；</li>
<li>按照实际增长率求后期：根据名义增长率求得基期后，在利用实际增长率求后期。</li>
</ul>
<h3 id="X类"><a href="#X类" class="headerlink" title="X类"></a>X类</h3><ul>
<li>一般增长量（求 $X$）：$R$ 靠近某分数可使用 $415$ 份数法，$R$ 极小可直接 $BR$，其他可假设分配；</li>
<li>两期增长量倍数或比值（$X_1/X_2$）：依次求得 $X_1$、$X_2$，再求比值即可；</li>
<li>整体增量/部分增量（$X＝X_1＋X_2＋X_3…$）：各部分增量相加等于总增量。</li>
</ul>
<h3 id="R类"><a href="#R类" class="headerlink" title="R类"></a>R类</h3><ul>
<li>一般增长率：直接套用公式“$R＝X/A$”即可；</li>
<li>隔年增长率：已知今年较去年增长 $R_1$，去年较前年增长 $R_2$，则今年较前年增长 $R_1＋R_2＋R_1R_2$；</li>
<li>比值增长率：符合表达式 $A＝B/C$，材料中有 $B$、$C$ 增长率，求 $A$ 的增长率，即为比值增长率（多以平均数增长率形式出现），公式为$\frac{R_b−R_c}{1+R_C}$； </li>
<li>乘积增长率：符合表达式 $A＝B×C$，材料中有 $B$、$C$ 增长率，求 $A$ 的增长率，即为乘积增长率（多以实际含义关系式和部分增长率形式出现），公式为 $R_b＋R_c＋R_b×R_c$(比重的也可以用，部分=整体*占比)。</li>
</ul>
]]></content>
      <categories>
        <category>行测</category>
      </categories>
      <tags>
        <tag>行测</tag>
      </tags>
  </entry>
  <entry>
    <title>算法总览</title>
    <url>/posts/755d7fda/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本站算法总览，不是超链接的即为还未更新。</p>
<h2 id="基础算法"><a href="#基础算法" class="headerlink" title="基础算法"></a>基础算法</h2><ul>
<li><a href="/posts/37060/" title="前缀和与差分">前缀和与差分</a></li>
<li><a href="/posts/3510/" title="二分法">二分法</a></li>
</ul>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><ul>
<li><a href="/posts/c517589e/" title="并查集">并查集</a></li>
<li><a href="/posts/dbe7e802/" title="带权并查集">带权并查集</a></li>
<li><a href="/posts/b6627a60/" title="拓展域并查集">拓展域并查集</a></li>
<li><a href="/posts/59a0de58/" title="树状数组">树状数组</a></li>
<li><a href="/posts/8893d943/" title="线段树">线段树</a></li>
</ul>
<h2 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h2><ul>
<li><a href="/posts/eadfe50d/" title="图论基础">图论基础</a></li>
<li><a href="/posts/c4fedc02/" title="Dijkstra算法">Dijkstra算法</a></li>
<li><a href="/posts/c856449e/" title="SPFA算法">SPFA算法</a></li>
<li><a href="/posts/d7becff4/" title="Floyd算法">Floyd算法</a></li>
<li><a href="/posts/8708cb74/" title="Kruskal算法">Kruskal算法</a></li>
<li><a href="/posts/fb40efc5/" title="拓扑排序">拓扑排序</a></li>
<li><a href="/posts/7cc481cf/" title="LCA最近公共祖先">LCA最近公共祖先</a></li>
</ul>
<h2 id="数论"><a href="#数论" class="headerlink" title="数论"></a>数论</h2><ul>
<li><a href="/posts/41f16002/" title="GCD与LCM">GCD与LCM</a></li>
<li><a href="/posts/20c47d09/" title="快速幂">快速幂</a></li>
<li><a href="/posts/9aab0fcd/" title="组合计数">组合计数</a></li>
<li><a href="/posts/996e4f07/" title="筛质数">筛质数</a></li>
<li>欧拉函数</li>
<li><a href="/posts/68bc28a9/" title="拓展欧几里得">拓展欧几里得</a></li>
</ul>
<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><ul>
<li>背包</li>
<li>线性DP</li>
<li><a href="/posts/628fb573/" title="区间DP">区间DP</a></li>
<li><a href="/posts/9ba26914/" title="树形DP">树形DP</a></li>
<li><a href="/posts/cb5e0eb8/" title="记忆化搜索">记忆化搜索</a></li>
<li>状压DP</li>
<li>状态机DP</li>
</ul>
<h2 id="博弈论"><a href="#博弈论" class="headerlink" title="博弈论"></a>博弈论</h2><ul>
<li>Nim游戏</li>
</ul>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><ul>
<li>字符串哈希</li>
<li>KMP算法</li>
<li>Manacher算法</li>
</ul>
<h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><ul>
<li><a href="/posts/3006dc10/" title="STL">STL</a></li>
<li><a href="/posts/a072cd53/" title="普通莫队">普通莫队</a></li>
<li><a href="/posts/84c587e8/" title="带修莫队">带修莫队</a></li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>bitset</title>
    <url>/posts/9dd4d1cb/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>bitset存储二进制数位。</p>
<p>bitset就像一个bool类型的数组一样，但是有空间优化——bitset中的一个元素一般只占1 bit，相当于一个char元素所占空间的八分之一。</p>
<h3 id="主要特点"><a href="#主要特点" class="headerlink" title="主要特点"></a>主要特点</h3><ol>
<li><strong>固定大小</strong>：<code>bitset</code> 是一个固定大小的位集合，大小在编译时确定，无法在运行时改变。</li>
<li><strong>位操作</strong>：<code>bitset</code> 提供了一组操作符和成员函数，用于高效地进行位操作。</li>
<li><strong>内存紧凑</strong>：<code>bitset</code> 使用一个或多个整数来存储位，因此在内存中非常紧凑。</li>
<li><strong>位设置</strong>：<code>bitset</code> 允许设置、重置和测试单个位的状态。</li>
</ol>
<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><h3 id="1-创建和初始化"><a href="#1-创建和初始化" class="headerlink" title="1. 创建和初始化"></a>1. 创建和初始化</h3><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bitset&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    bitset&lt;8&gt; b1; <span class="hljs-comment">// 创建一个大小为 8 的 bitset，所有位初始为 0</span><br>    <span class="hljs-function">bitset&lt;8&gt; <span class="hljs-title">b2</span><span class="hljs-params">(<span class="hljs-number">0b10101010</span>)</span></span>; <span class="hljs-comment">// 使用二进制字面值初始化</span><br><br>    cout &lt;&lt; b1 &lt;&lt; endl; <span class="hljs-comment">// 输出: 00000000</span><br>    cout &lt;&lt; b2 &lt;&lt; endl; <span class="hljs-comment">// 输出: 10101010</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br><br><br></code></pre></td></tr></tbody></table></figure>
<h3 id="2-位操作"><a href="#2-位操作" class="headerlink" title="2.位操作"></a>2.位操作</h3><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bitset&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-function">bitset&lt;8&gt; <span class="hljs-title">b</span><span class="hljs-params">(<span class="hljs-number">0b10101010</span>)</span></span>;<br><br>    <span class="hljs-comment">// 设置位</span><br>    b.<span class="hljs-built_in">set</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// 设置第 1 位为 1</span><br>    b.<span class="hljs-built_in">set</span>(<span class="hljs-number">4</span>, <span class="hljs-number">0</span>); <span class="hljs-comment">// 设置第 4 位为 0</span><br><br>    <span class="hljs-comment">// 重置位</span><br>    b.<span class="hljs-built_in">reset</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// 将第 1 位重置为 0</span><br><br>    <span class="hljs-comment">// 切换位</span><br>    b.<span class="hljs-built_in">flip</span>(<span class="hljs-number">2</span>); <span class="hljs-comment">// 切换第 2 位</span><br><br>    <span class="hljs-comment">// 访问位</span><br>    cout &lt;&lt; <span class="hljs-string">"Bit 2: "</span> &lt;&lt; b[<span class="hljs-number">2</span>] &lt;&lt; endl; <span class="hljs-comment">// 输出: 1</span><br>    cout &lt;&lt; <span class="hljs-string">"Bit 4: "</span> &lt;&lt; b.<span class="hljs-built_in">test</span>(<span class="hljs-number">4</span>) &lt;&lt; endl; <span class="hljs-comment">// 输出: 0</span><br><br>    <span class="hljs-comment">// 输出 bitset</span><br>    cout &lt;&lt; b &lt;&lt; endl; <span class="hljs-comment">// 输出: 10100000</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br><br></code></pre></td></tr></tbody></table></figure>

<h3 id="3-其他操作"><a href="#3-其他操作" class="headerlink" title="3. 其他操作"></a>3. 其他操作</h3><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bitset&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-function">bitset&lt;8&gt; <span class="hljs-title">b1</span><span class="hljs-params">(<span class="hljs-number">0b10101010</span>)</span></span>;<br>    <span class="hljs-function">bitset&lt;8&gt; <span class="hljs-title">b2</span><span class="hljs-params">(<span class="hljs-number">0b11001100</span>)</span></span>;<br><br>    <span class="hljs-comment">// 位与运算</span><br>    bitset&lt;8&gt; b3 = b1 &amp; b2; <span class="hljs-comment">// 位与</span><br>    cout &lt;&lt; <span class="hljs-string">"b1 &amp; b2: "</span> &lt;&lt; b3 &lt;&lt; endl; <span class="hljs-comment">// 输出: 10001000</span><br><br>    <span class="hljs-comment">// 位或运算</span><br>    bitset&lt;8&gt; b4 = b1 | b2; <span class="hljs-comment">// 位或</span><br>    cout &lt;&lt; <span class="hljs-string">"b1 | b2: "</span> &lt;&lt; b4 &lt;&lt; endl; <span class="hljs-comment">// 输出: 11101110</span><br><br>    <span class="hljs-comment">// 位异或运算</span><br>    bitset&lt;8&gt; b5 = b1 ^ b2; <span class="hljs-comment">// 位异或</span><br>    cout &lt;&lt; <span class="hljs-string">"b1 ^ b2: "</span> &lt;&lt; b5 &lt;&lt; endl; <span class="hljs-comment">// 输出: 01100110</span><br><br>    <span class="hljs-comment">// 位非运算</span><br>    bitset&lt;8&gt; b6 = ~b1; <span class="hljs-comment">// 位非</span><br>    cout &lt;&lt; <span class="hljs-string">"~b1: "</span> &lt;&lt; b6 &lt;&lt; endl; <span class="hljs-comment">// 输出: 01010101</span><br><br>    <span class="hljs-comment">// 计数位</span><br>    cout &lt;&lt; <span class="hljs-string">"Number of 1s in b1: "</span> &lt;&lt; b1.<span class="hljs-built_in">count</span>() &lt;&lt; endl; <span class="hljs-comment">// 输出: 4</span><br><br>    <span class="hljs-comment">// 转换为字符串</span><br>    string str = b1.<span class="hljs-built_in">to_string</span>();<br>    cout &lt;&lt; <span class="hljs-string">"b1 as string: "</span> &lt;&lt; str &lt;&lt; endl; <span class="hljs-comment">// 输出: 10101010</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br><br></code></pre></td></tr></tbody></table></figure>


<h3 id="常用成员函数"><a href="#常用成员函数" class="headerlink" title="常用成员函数"></a>常用成员函数</h3><ul>
<li><p><strong>位操作</strong>：</p>
<ul>
<li><code>set(size_t pos, bool value = true)</code>：设置指定位置的位为 <code>value</code>（默认 <code>true</code>）。</li>
<li><code>reset(size_t pos)</code>：将指定位置的位重置为 <code>0</code>。</li>
<li><code>flip(size_t pos)</code>：切换指定位置的位（<code>0</code> 变为 <code>1</code>，<code>1</code> 变为 <code>0</code>）。</li>
<li><code>test(size_t pos)</code>：测试指定位置的位，返回 <code>true</code> 如果该位为 <code>1</code>，否则返回 <code>false</code>。</li>
</ul>
</li>
<li><p><strong>访问和查询</strong>：</p>
<ul>
<li><code>operator[]</code>：访问指定位置的位（返回 <code>bool</code>）。</li>
<li><code>count()</code>：返回 <code>1</code> 的数量，即设置为 <code>1</code> 的位的数量。</li>
<li><code>size()</code>：返回 <code>bitset</code> 的大小（位的总数）。</li>
<li><code>to_string()</code>：返回 <code>bitset</code> 的字符串表示形式。</li>
</ul>
</li>
<li><p><strong>位运算</strong>：</p>
<ul>
<li><code>operator&amp;</code>：位与运算。</li>
<li><code>operator|</code>：位或运算。</li>
<li><code>operator^</code>：位异或运算。</li>
<li><code>operator~</code>：位非运算。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>STL</category>
      </categories>
      <tags>
        <tag>STL</tag>
        <tag>bitset</tag>
        <tag>二进制</tag>
      </tags>
  </entry>
  <entry>
    <title>queue</title>
    <url>/posts/7ffd7f63/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>STL（标准模板库）中的 <code>queue</code> 是 C++ 中的队列容器。实现了队列的基本功能 $FIFO$。</p>
<h3 id="主要特点"><a href="#主要特点" class="headerlink" title="主要特点"></a>主要特点</h3><ol>
<li>**先进先出 (FIFO)**：<code>queue</code> 是一种先进先出（FIFO）数据结构，元素的插入在队尾进行，元素的移除在队首进行。</li>
<li><strong>底层实现</strong>：<code>queue</code> 通常使用双端队列（<code>deque</code>）或链表作为底层实现。</li>
<li><strong>限制操作</strong>：只能访问队首元素（<code>front()</code>）、队尾元素（<code>back()</code>），以及执行入队（<code>push()</code>）和出队（<code>pop()</code>）操作。</li>
</ol>
<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><h3 id="1-创建和初始化"><a href="#1-创建和初始化" class="headerlink" title="1. 创建和初始化"></a>1. 创建和初始化</h3><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    queue&lt;<span class="hljs-type">int</span>&gt; q; <span class="hljs-comment">// 创建一个空的 queue</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br><br></code></pre></td></tr></tbody></table></figure>

<h3 id="2-元素操作"><a href="#2-元素操作" class="headerlink" title="2. 元素操作"></a>2. 元素操作</h3><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br><br>    <span class="hljs-comment">// 入队</span><br>    q.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// 在队尾插入 1</span><br>    q.<span class="hljs-built_in">push</span>(<span class="hljs-number">2</span>); <span class="hljs-comment">// 在队尾插入 2</span><br>    q.<span class="hljs-built_in">push</span>(<span class="hljs-number">3</span>); <span class="hljs-comment">// 在队尾插入 3</span><br><br>    <span class="hljs-comment">// 访问队首和队尾元素</span><br>    cout &lt;&lt; <span class="hljs-string">"Front: "</span> &lt;&lt; q.<span class="hljs-built_in">front</span>() &lt;&lt; endl; <span class="hljs-comment">// 输出队首元素 1</span><br>    cout &lt;&lt; <span class="hljs-string">"Back: "</span> &lt;&lt; q.<span class="hljs-built_in">back</span>() &lt;&lt; endl;   <span class="hljs-comment">// 输出队尾元素 3</span><br><br>    <span class="hljs-comment">// 出队</span><br>    q.<span class="hljs-built_in">pop</span>(); <span class="hljs-comment">// 删除队首元素 1</span><br><br>    <span class="hljs-comment">// 访问修改后的队首和队尾元素</span><br>    cout &lt;&lt; <span class="hljs-string">"Front: "</span> &lt;&lt; q.<span class="hljs-built_in">front</span>() &lt;&lt; endl; <span class="hljs-comment">// 输出新的队首元素 2</span><br>    cout &lt;&lt; <span class="hljs-string">"Back: "</span> &lt;&lt; q.<span class="hljs-built_in">back</span>() &lt;&lt; endl;   <span class="hljs-comment">// 输出队尾元素 3</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br><br></code></pre></td></tr></tbody></table></figure>

<h3 id="3-队列状态"><a href="#3-队列状态" class="headerlink" title="3. 队列状态"></a>3. 队列状态</h3><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br><br>    <span class="hljs-comment">// 检查队列是否为空</span><br>    <span class="hljs-keyword">if</span> (q.<span class="hljs-built_in">empty</span>()) {<br>        cout &lt;&lt; <span class="hljs-string">"Queue is empty."</span> &lt;&lt; endl;<br>    }<br><br>    <span class="hljs-comment">// 入队</span><br>    q.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<br><br>    <span class="hljs-comment">// 检查队列大小</span><br>    cout &lt;&lt; <span class="hljs-string">"Size: "</span> &lt;&lt; q.<span class="hljs-built_in">size</span>() &lt;&lt; endl; <span class="hljs-comment">// 输出队列的大小</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br><br></code></pre></td></tr></tbody></table></figure>


<h3 id="常用成员函数"><a href="#常用成员函数" class="headerlink" title="常用成员函数"></a>常用成员函数</h3><ul>
<li><p><strong>元素操作</strong>：</p>
<ul>
<li><code>push(const T&amp; value)</code>：在队尾插入一个元素。</li>
<li><code>pop()</code>：移除队首元素。</li>
<li><code>front()</code>：返回队首元素的引用。</li>
<li><code>back()</code>：返回队尾元素的引用。</li>
</ul>
</li>
<li><p><strong>状态检查</strong>：</p>
<ul>
<li><code>empty()</code>：检查队列是否为空，返回布尔值。</li>
<li><code>size()</code>：返回队列中元素的数量。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>STL</category>
      </categories>
      <tags>
        <tag>STL</tag>
        <tag>queue</tag>
        <tag>队列</tag>
        <tag>FIFO</tag>
      </tags>
  </entry>
  <entry>
    <title>set</title>
    <url>/posts/e61425dc/</url>
    <content><![CDATA[<h2 id="SET概念"><a href="#SET概念" class="headerlink" title="SET概念"></a>SET概念</h2><h3 id="主要特点"><a href="#主要特点" class="headerlink" title="主要特点"></a>主要特点</h3><ol>
<li><strong>唯一元素</strong>：<code>set</code> 是一种不允许重复元素的集合，每个元素在集合中只能出现一次。</li>
<li><strong>有序</strong>：<code>set</code> 中的元素是按照特定的顺序自动排列的，默认情况下是升序排列。</li>
<li><strong>底层实现</strong>：<code>set</code> 通常使用红黑树或其他平衡树结构作为底层实现。</li>
<li><strong>查找效率</strong>：由于底层实现为平衡树，<code>set</code> 提供对元素的对数时间复杂度的查找、插入和删除操作。</li>
</ol>
<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><h3 id="1-创建和初始化"><a href="#1-创建和初始化" class="headerlink" title="1. 创建和初始化"></a>1. 创建和初始化</h3><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    set&lt;<span class="hljs-type">int</span>&gt; s; <span class="hljs-comment">// 创建一个空的 set</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br><br><br></code></pre></td></tr></tbody></table></figure>

<h3 id="2-元素操作"><a href="#2-元素操作" class="headerlink" title="2. 元素操作"></a>2. 元素操作</h3><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    set&lt;<span class="hljs-type">int</span>&gt; s;<br><br>    <span class="hljs-comment">// 插入元素</span><br>    s.<span class="hljs-built_in">insert</span>(<span class="hljs-number">3</span>);<br>    s.<span class="hljs-built_in">insert</span>(<span class="hljs-number">1</span>);<br>    s.<span class="hljs-built_in">insert</span>(<span class="hljs-number">2</span>);<br>    s.<span class="hljs-built_in">insert</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// 插入重复元素不会有任何效果</span><br><br>    <span class="hljs-comment">// 输出所有元素</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x : s) {<br>        cout &lt;&lt; x &lt;&lt; <span class="hljs-string">" "</span>;<br>    }<br>    cout &lt;&lt; endl; <span class="hljs-comment">// 输出: 1 2 3</span><br><br>    <span class="hljs-comment">// 查找元素</span><br>    <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">find</span>(<span class="hljs-number">2</span>) != s.<span class="hljs-built_in">end</span>()) {<br>        cout &lt;&lt; <span class="hljs-string">"2 is in the set."</span> &lt;&lt; endl;<br>    }<br><br>    <span class="hljs-comment">// 删除元素</span><br>    s.<span class="hljs-built_in">erase</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// 删除元素 1</span><br><br>    <span class="hljs-comment">// 输出所有元素</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x : s) {<br>        cout &lt;&lt; x &lt;&lt; <span class="hljs-string">" "</span>;<br>    }<br>    cout &lt;&lt; endl; <span class="hljs-comment">// 输出: 2 3</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br><br></code></pre></td></tr></tbody></table></figure>


<h3 id="3-迭代器的使用"><a href="#3-迭代器的使用" class="headerlink" title="3. 迭代器的使用"></a>3. 迭代器的使用</h3><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    set&lt;<span class="hljs-type">int</span>&gt; s = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>};<br><br>    <span class="hljs-comment">// 使用迭代器遍历</span><br>    <span class="hljs-keyword">for</span> (set&lt;<span class="hljs-type">int</span>&gt;::iterator it = s.<span class="hljs-built_in">begin</span>(); it != s.<span class="hljs-built_in">end</span>(); ++it) {<br>        cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">" "</span>;<br>    }<br>    cout &lt;&lt; endl; <span class="hljs-comment">// 输出: 1 2 3 4 5</span><br><br>    <span class="hljs-comment">// 使用范围 for 循环遍历</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x : s) {<br>        cout &lt;&lt; x &lt;&lt; <span class="hljs-string">" "</span>;<br>    }<br>    cout &lt;&lt; endl; <span class="hljs-comment">// 输出: 1 2 3 4 5</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br><br></code></pre></td></tr></tbody></table></figure>



<h3 id="常用成员函数"><a href="#常用成员函数" class="headerlink" title="常用成员函数"></a>常用成员函数</h3><ul>
<li><p><strong>元素操作</strong>：</p>
<ul>
<li><code>insert(const T&amp; value)</code>：插入一个元素，如果元素已存在，则不会重复插入。</li>
<li><code>erase(const T&amp; value)</code>：删除指定的元素。</li>
<li><code>find(const T&amp; value)</code>：查找指定的元素，返回指向该元素的迭代器，如果未找到则返回 <code>end()</code>。</li>
</ul>
</li>
<li><p><strong>状态检查</strong>：</p>
<ul>
<li><code>empty()</code>：检查 <code>set</code> 是否为空，返回布尔值。</li>
<li><code>size()</code>：返回 <code>set</code> 中元素的数量。</li>
</ul>
</li>
<li><p><strong>迭代器</strong>：</p>
<ul>
<li><code>begin()</code>：返回指向第一个元素的迭代器。</li>
<li><code>end()</code>：返回指向 <code>set</code> 尾部之后的位置的迭代器。</li>
</ul>
</li>
<li><p><strong>其他操作</strong>：</p>
<ul>
<li><code>count(const T&amp; value)</code>：返回集合中与 <code>value</code> 匹配的元素的数量（<code>set</code> 中要么是 0，要么是 1）。</li>
<li><code>lower_bound(const T&amp; value)</code>：返回指向第一个不小于 <code>value</code> 的元素的迭代器。</li>
<li><code>upper_bound(const T&amp; value)</code>：返回指向第一个大于 <code>value</code> 的元素的迭代器。</li>
<li><code>equal_range(const T&amp; value)</code>：返回一个 <code>pair</code>，包含 <code>value</code> 的 <code>lower_bound</code> 和 <code>upper_bound</code> 迭代器。</li>
</ul>
</li>
</ul>
<h2 id="MAP概念"><a href="#MAP概念" class="headerlink" title="MAP概念"></a>MAP概念</h2><p>类似于py里面的字典</p>
<h3 id="主要特点-1"><a href="#主要特点-1" class="headerlink" title="主要特点"></a>主要特点</h3><ol>
<li><strong>键值对存储</strong>：<code>map</code> 存储的是键值对，每个元素由一个键和一个对应的值组成。</li>
<li><strong>唯一键</strong>：<code>map</code> 中的每个键都是唯一的，不允许重复。如果插入一个已有键的元素，会更新该键的值。</li>
<li><strong>有序</strong>：<code>map</code> 中的键是按照特定的顺序自动排列的，默认情况下是升序排列。</li>
<li><strong>底层实现</strong>：<code>map</code> 通常使用红黑树或其他平衡树结构作为底层实现。</li>
<li><strong>查找效率</strong>：由于底层实现为平衡树，<code>map</code> 提供对元素的对数时间复杂度的查找、插入和删除操作。</li>
</ol>
<h3 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h3><h4 id="1-创建和初始化-1"><a href="#1-创建和初始化-1" class="headerlink" title="1. 创建和初始化"></a>1. 创建和初始化</h4><pre><code class="cpp">#include &lt;map&gt;
#include &lt;iostream&gt;

using namespace std;

int main() {
    map&lt;int, string&gt; m; // 创建一个空的 map

    return 0;
}
</code></pre>
]]></content>
      <categories>
        <category>STL</category>
      </categories>
      <tags>
        <tag>STL</tag>
        <tag>set</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>stack</title>
    <url>/posts/41a87b6a/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>STL（标准模板库）中的 <code>stack</code> 是 C++ 中的栈容器。实现了栈的基本功能。</p>
<h3 id="主要特点"><a href="#主要特点" class="headerlink" title="主要特点"></a>主要特点</h3><ol>
<li>**先进后出 (LIFO)**：<code>stack</code> 是一种先进后出（LIFO）数据结构，元素的插入和删除都在同一端进行，即栈顶。</li>
<li><strong>底层实现</strong>：<code>stack</code> 通常使用双端队列（<code>deque</code>）或链表作为底层实现。</li>
<li><strong>限制操作</strong>：只能访问栈顶元素（<code>top()</code>）、进行入栈（<code>push()</code>）和出栈（<code>pop()</code>）操作。</li>
</ol>
<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><h3 id="1-创建和初始化"><a href="#1-创建和初始化" class="headerlink" title="1. 创建和初始化"></a>1. 创建和初始化</h3><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    stack&lt;<span class="hljs-type">int</span>&gt; s; <span class="hljs-comment">// 创建一个空的 stack</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br><br></code></pre></td></tr></tbody></table></figure>

<h3 id="2-元素操作"><a href="#2-元素操作" class="headerlink" title="2. 元素操作"></a>2. 元素操作</h3><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    stack&lt;<span class="hljs-type">int</span>&gt; s;<br><br>    <span class="hljs-comment">// 入栈</span><br>    s.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// 在栈顶插入 1</span><br>    s.<span class="hljs-built_in">push</span>(<span class="hljs-number">2</span>); <span class="hljs-comment">// 在栈顶插入 2</span><br>    s.<span class="hljs-built_in">push</span>(<span class="hljs-number">3</span>); <span class="hljs-comment">// 在栈顶插入 3</span><br><br>    <span class="hljs-comment">// 访问栈顶元素</span><br>    cout &lt;&lt; <span class="hljs-string">"Top: "</span> &lt;&lt; s.<span class="hljs-built_in">top</span>() &lt;&lt; endl; <span class="hljs-comment">// 输出栈顶元素 3</span><br><br>    <span class="hljs-comment">// 出栈</span><br>    s.<span class="hljs-built_in">pop</span>(); <span class="hljs-comment">// 删除栈顶元素 3</span><br><br>    <span class="hljs-comment">// 访问修改后的栈顶元素</span><br>    cout &lt;&lt; <span class="hljs-string">"Top: "</span> &lt;&lt; s.<span class="hljs-built_in">top</span>() &lt;&lt; endl; <span class="hljs-comment">// 输出新的栈顶元素 2</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br><br></code></pre></td></tr></tbody></table></figure>

<h3 id="3-检查栈的状态"><a href="#3-检查栈的状态" class="headerlink" title="3. 检查栈的状态"></a>3. 检查栈的状态</h3><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    stack&lt;<span class="hljs-type">int</span>&gt; s;<br><br>    <span class="hljs-comment">// 检查栈是否为空</span><br>    <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">empty</span>()) {<br>        cout &lt;&lt; <span class="hljs-string">"Stack is empty."</span> &lt;&lt; endl;<br>    }<br><br>    <span class="hljs-comment">// 入栈</span><br>    s.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<br><br>    <span class="hljs-comment">// 检查栈大小</span><br>    cout &lt;&lt; <span class="hljs-string">"Size: "</span> &lt;&lt; s.<span class="hljs-built_in">size</span>() &lt;&lt; endl; <span class="hljs-comment">// 输出栈的大小</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br><br></code></pre></td></tr></tbody></table></figure>

<h3 id="常用成员函数"><a href="#常用成员函数" class="headerlink" title="常用成员函数"></a>常用成员函数</h3><ul>
<li><p><strong>元素操作</strong>：</p>
<ul>
<li><code>push(const T&amp; value)</code>：在栈顶插入一个元素。</li>
<li><code>pop()</code>：移除栈顶元素。</li>
<li><code>top()</code>：返回栈顶元素的引用。</li>
</ul>
</li>
<li><p><strong>状态检查</strong>：</p>
<ul>
<li><code>empty()</code>：检查栈是否为空，返回布尔值。</li>
<li><code>size()</code>：返回栈中元素的数量。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>STL</category>
      </categories>
      <tags>
        <tag>STL</tag>
        <tag>stack</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>vector</title>
    <url>/posts/1b6e485b/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>STL（标准模板库）中的 <code>vector</code> 是 C++ 中一个非常常用的容器类。它是一个动态数组，可以自动调整大小，并提供了类似于数组的随机访问功能。</p>
<h2 id="主要特点"><a href="#主要特点" class="headerlink" title="主要特点"></a>主要特点</h2><ol>
<li><strong>动态大小</strong>：<code>vector</code> 会根据需要自动调整其大小，允许在运行时增加或减少元素。</li>
<li><strong>连续存储</strong>：<code>vector</code> 的元素在内存中是连续存储的，这意味着可以通过偏移量进行高效的随机访问。</li>
<li><strong>自动管理内存</strong>：<code>vector</code> 会自动管理其所需的内存，因此无需手动分配或释放内存。</li>
<li><strong>丰富的接口</strong>：<code>vector</code> 提供了一组丰富的成员函数，用于插入、删除、访问和修改元素。</li>
</ol>
<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><h3 id="1-创建和初始化"><a href="#1-创建和初始化" class="headerlink" title="1. 创建和初始化"></a>1. 创建和初始化</h3><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    vector&lt;<span class="hljs-type">int</span>&gt; v1; <span class="hljs-comment">// 创建一个空的 vector</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v2</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>; <span class="hljs-comment">// 创建一个包含 10 个默认值（0）的 vector</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v3</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">5</span>)</span></span>; <span class="hljs-comment">// 创建一个包含 10 个值为 5 的元素的 vector</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; v4 = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>}; <span class="hljs-comment">// 使用初始化列表进行初始化</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>

<h3 id="2-元素访问"><a href="#2-元素访问" class="headerlink" title="2. 元素访问"></a>2. 元素访问</h3><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    vector&lt;<span class="hljs-type">int</span>&gt; v = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>};<br><br>    <span class="hljs-comment">// 通过下标访问元素</span><br>    cout &lt;&lt; v[<span class="hljs-number">0</span>] &lt;&lt; endl; <span class="hljs-comment">// 输出第一个元素</span><br>    cout &lt;&lt; v.<span class="hljs-built_in">at</span>(<span class="hljs-number">1</span>) &lt;&lt; endl; <span class="hljs-comment">// 输出第二个元素（带边界检查）</span><br><br>    <span class="hljs-comment">// 访问第一个和最后一个元素</span><br>    cout &lt;&lt; v.<span class="hljs-built_in">front</span>() &lt;&lt; endl; <span class="hljs-comment">// 第一个元素</span><br>    cout &lt;&lt; v.<span class="hljs-built_in">back</span>() &lt;&lt; endl; <span class="hljs-comment">// 最后一个元素</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br><br></code></pre></td></tr></tbody></table></figure>

<h3 id="3-插入和删除元素"><a href="#3-插入和删除元素" class="headerlink" title="3. 插入和删除元素"></a>3. 插入和删除元素</h3><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    vector&lt;<span class="hljs-type">int</span>&gt; v;<br><br>    <span class="hljs-comment">// 插入元素</span><br>    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// 在末尾插入 1</span><br>    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">2</span>); <span class="hljs-comment">// 在末尾插入 2</span><br><br>    <span class="hljs-comment">// 删除元素</span><br>    v.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">// 删除最后一个元素</span><br><br>    <span class="hljs-comment">// 插入到指定位置</span><br>    v.<span class="hljs-built_in">insert</span>(v.<span class="hljs-built_in">begin</span>(), <span class="hljs-number">0</span>); <span class="hljs-comment">// 在开头插入 0</span><br><br>    <span class="hljs-comment">// 删除指定位置的元素</span><br>    v.<span class="hljs-built_in">erase</span>(v.<span class="hljs-built_in">begin</span>()); <span class="hljs-comment">// 删除开头的元素</span><br><br>    <span class="hljs-comment">// 清空 vector</span><br>    v.<span class="hljs-built_in">clear</span>(); <span class="hljs-comment">// 移除所有元素</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br><br></code></pre></td></tr></tbody></table></figure>

<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    vector&lt;<span class="hljs-type">int</span>&gt; v = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>};<br><br>    <span class="hljs-comment">// 使用迭代器遍历</span><br>    <span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-type">int</span>&gt;::iterator it = v.<span class="hljs-built_in">begin</span>(); it != v.<span class="hljs-built_in">end</span>(); ++it) {<br>        cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">" "</span>;<br>    }<br>    cout &lt;&lt; endl;<br><br>    <span class="hljs-comment">// 使用范围 for 循环遍历</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> n : v) {<br>        cout &lt;&lt; n &lt;&lt; <span class="hljs-string">" "</span>;<br>    }<br>    cout &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br><br></code></pre></td></tr></tbody></table></figure>


<h3 id="常用成员函数"><a href="#常用成员函数" class="headerlink" title="常用成员函数"></a>常用成员函数</h3><ul>
<li><strong>容量管理</strong>：<ul>
<li><code>size()</code>：返回当前元素数量。</li>
<li><code>capacity()</code>：返回当前分配的存储空间的容量。</li>
<li><code>reserve(size_type n)</code>：请求至少能容纳 <code>n</code> 个元素的存储空间。</li>
<li><code>shrink_to_fit()</code>：减少容量以适应当前大小。</li>
</ul>
</li>
<li><strong>元素访问</strong>：<ul>
<li><code>operator[]</code>：无边界检查的元素访问。</li>
<li><code>at(size_type n)</code>：带边界检查的元素访问。</li>
<li><code>front()</code>：返回第一个元素的引用。</li>
<li><code>back()</code>：返回最后一个元素的引用。</li>
</ul>
</li>
<li><strong>修改容器</strong>：<ul>
<li><code>push_back(const T&amp; value)</code>：在末尾插入元素。</li>
<li><code>pop_back()</code>：删除末尾的元素。</li>
<li><code>insert(iterator pos, const T&amp; value)</code>：在指定位置插入元素。</li>
<li><code>erase(iterator pos)</code>：删除指定位置的元素。</li>
<li><code>clear()</code>：清空容器。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>STL</category>
      </categories>
      <tags>
        <tag>STL</tag>
        <tag>vector</tag>
      </tags>
  </entry>
  <entry>
    <title>string</title>
    <url>/posts/9ebeb2a9/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>可以代替传统的char数组。</p>
<h3 id="主要特点"><a href="#主要特点" class="headerlink" title="主要特点"></a>主要特点</h3><ol>
<li><strong>动态大小</strong>：<code>string</code> 是一个动态大小的字符序列，能够根据需要自动调整大小。</li>
<li><strong>标准字符集</strong>：<code>string</code> 默认使用 ASCII 字符集，但也支持 Unicode。</li>
<li><strong>丰富的接口</strong>：<code>string</code> 提供了丰富的成员函数和操作符，用于处理字符串的各种操作。</li>
<li><strong>内存管理</strong>：<code>string</code> 自动管理其所需的内存，因此无需手动分配或释放内存。</li>
</ol>
<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><h3 id="1-创建和初始化"><a href="#1-创建和初始化" class="headerlink" title="1. 创建和初始化"></a>1. 创建和初始化</h3><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    string s1; <span class="hljs-comment">// 创建一个空的 string</span><br>    string s2 = <span class="hljs-string">"Hello"</span>; <span class="hljs-comment">// 使用字符串字面值初始化</span><br>    <span class="hljs-function">string <span class="hljs-title">s3</span><span class="hljs-params">(<span class="hljs-string">"World"</span>)</span></span>; <span class="hljs-comment">// 使用构造函数初始化</span><br>    string s4 = s2 + <span class="hljs-string">" "</span> + s3; <span class="hljs-comment">// 字符串连接</span><br><br>    cout &lt;&lt; s4 &lt;&lt; endl; <span class="hljs-comment">// 输出: Hello World</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br><br><br></code></pre></td></tr></tbody></table></figure>
<h3 id="2-字符串操作"><a href="#2-字符串操作" class="headerlink" title="2. 字符串操作"></a>2. 字符串操作</h3><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    string s = <span class="hljs-string">"Hello World"</span>;<br><br>    <span class="hljs-comment">// 访问单个字符</span><br>    cout &lt;&lt; s[<span class="hljs-number">0</span>] &lt;&lt; endl; <span class="hljs-comment">// 输出: H</span><br>    cout &lt;&lt; s.<span class="hljs-built_in">at</span>(<span class="hljs-number">1</span>) &lt;&lt; endl; <span class="hljs-comment">// 输出: e</span><br><br>    <span class="hljs-comment">// 子字符串</span><br>    string sub = s.<span class="hljs-built_in">substr</span>(<span class="hljs-number">6</span>, <span class="hljs-number">5</span>); <span class="hljs-comment">// 从位置 6 开始，长度为 5 的子字符串</span><br>    cout &lt;&lt; sub &lt;&lt; endl; <span class="hljs-comment">// 输出: World</span><br><br>    <span class="hljs-comment">// 查找子字符串</span><br>    <span class="hljs-type">size_t</span> pos = s.<span class="hljs-built_in">find</span>(<span class="hljs-string">"World"</span>);<br>    <span class="hljs-keyword">if</span> (pos != string::npos) {<br>        cout &lt;&lt; <span class="hljs-string">"Found at position: "</span> &lt;&lt; pos &lt;&lt; endl;<br>    }<br><br>    <span class="hljs-comment">// 替换子字符串</span><br>    s.<span class="hljs-built_in">replace</span>(<span class="hljs-number">6</span>, <span class="hljs-number">5</span>, <span class="hljs-string">"C++"</span>);<br>    cout &lt;&lt; s &lt;&lt; endl; <span class="hljs-comment">// 输出: Hello C++</span><br><br>    <span class="hljs-comment">// 删除子字符串</span><br>    s.<span class="hljs-built_in">erase</span>(<span class="hljs-number">6</span>, <span class="hljs-number">3</span>); <span class="hljs-comment">// 从位置 6 开始，删除长度为 3 的子字符串</span><br>    cout &lt;&lt; s &lt;&lt; endl; <span class="hljs-comment">// 输出: Hello C</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br><br></code></pre></td></tr></tbody></table></figure>

<h3 id="3-字符串的比较和拼接"><a href="#3-字符串的比较和拼接" class="headerlink" title="3. 字符串的比较和拼接"></a>3. 字符串的比较和拼接</h3><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    string s1 = <span class="hljs-string">"Hello"</span>;<br>    string s2 = <span class="hljs-string">"World"</span>;<br><br>    <span class="hljs-comment">// 比较字符串</span><br>    <span class="hljs-keyword">if</span> (s1 == <span class="hljs-string">"Hello"</span>) {<br>        cout &lt;&lt; <span class="hljs-string">"s1 is Hello"</span> &lt;&lt; endl;<br>    }<br><br>    <span class="hljs-keyword">if</span> (s1 &lt; s2) {<br>        cout &lt;&lt; <span class="hljs-string">"s1 is less than s2"</span> &lt;&lt; endl;<br>    }<br><br>    <span class="hljs-comment">// 拼接字符串</span><br>    string s3 = s1 + <span class="hljs-string">" "</span> + s2;<br>    cout &lt;&lt; s3 &lt;&lt; endl; <span class="hljs-comment">// 输出: Hello World</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br><br></code></pre></td></tr></tbody></table></figure>

<h3 id="常用成员函数"><a href="#常用成员函数" class="headerlink" title="常用成员函数"></a>常用成员函数</h3><ul>
<li><p><strong>基本操作</strong>：</p>
<ul>
<li><code>size()</code>：返回字符串的长度。</li>
<li><code>length()</code>：返回字符串的长度（与 <code>size()</code> 等效）。</li>
<li><code>empty()</code>：检查字符串是否为空，返回布尔值。</li>
<li><code>clear()</code>：清空字符串。</li>
</ul>
</li>
<li><p><strong>字符访问</strong>：</p>
<ul>
<li><code>operator[]</code>：访问指定位置的字符。</li>
<li><code>at(size_t pos)</code>：访问指定位置的字符，带边界检查。</li>
<li><code>front()</code>：返回第一个字符的引用。</li>
<li><code>back()</code>：返回最后一个字符的引用。</li>
</ul>
</li>
<li><p><strong>子字符串和查找</strong>：</p>
<ul>
<li><code>substr(size_t pos = 0, size_t len = npos)</code>：返回从 <code>pos</code> 开始长度为 <code>len</code> 的子字符串。</li>
<li><code>find(const string&amp; str, size_t pos = 0)</code>：查找子字符串 <code>str</code>，返回第一次出现的位置，如果未找到返回 <code>string::npos</code>。</li>
<li><code>rfind(const string&amp; str, size_t pos = npos)</code>：从后向前查找子字符串 <code>str</code>，返回最后一次出现的位置，如果未找到返回 <code>string::npos</code>。</li>
<li><code>replace(size_t pos, size_t len, const string&amp; str)</code>：替换从 <code>pos</code> 开始长度为 <code>len</code> 的子字符串为 <code>str</code>。</li>
<li><code>erase(size_t pos = 0, size_t len = npos)</code>：从 <code>pos</code> 开始删除长度为 <code>len</code> 的子字符串。</li>
</ul>
</li>
<li><p><strong>拼接和转换</strong>：</p>
<ul>
<li><code>append(const string&amp; str)</code>：在字符串末尾追加 <code>str</code>。</li>
<li><code>insert(size_t pos, const string&amp; str)</code>：在 <code>pos</code> 位置插入 <code>str</code>。</li>
<li><code>to_string()</code>：将其他类型转换为字符串（需要包含 <code>&lt;string&gt;</code> 头文件）。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>STL</category>
      </categories>
      <tags>
        <tag>STL</tag>
        <tag>字符串</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title>简单搜索</title>
    <url>/posts/38402/</url>
    <content><![CDATA[<h3 id="kuangbin专题一"><a href="#kuangbin专题一" class="headerlink" title="kuangbin专题一"></a>kuangbin专题一</h3><h4 id="简单搜索"><a href="#简单搜索" class="headerlink" title="简单搜索"></a>简单搜索</h4><hr>
<ol>
<li>棋盘问题<br>大致的解法就是，通过枚举每一行,之后选定列，选定之后再将该列标记，以免之后的行上面选到这一列
    <div class="fold">
      <div class="fold-title fold-default collapsed" data-toggle="collapse" href="#collapse-8f7bdefe" role="button" aria-expanded="false" aria-controls="collapse-8f7bdefe">
        <div class="fold-arrow">▶</div>代码
      </div>
      <div class="fold-collapse collapse" id="collapse-8f7bdefe">
        <div class="fold-content">
          <figure class="highlight c++"><table><tbody><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">11</span>;<br><span class="hljs-type">char</span> g[N][N];<br><span class="hljs-type">int</span> n,k;<br><span class="hljs-type">int</span> m;<br><span class="hljs-type">int</span> ans;<br><span class="hljs-type">bool</span> line[N];<span class="hljs-comment">//存列也没有其他棋子</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-keyword">if</span>( m == k)<br>    {<br>        ans++;<br>        <span class="hljs-keyword">return</span> ;<br>    }<br>    <span class="hljs-keyword">if</span>(u == n) <span class="hljs-keyword">return</span> ;<span class="hljs-comment">//防止越界</span><br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)<span class="hljs-comment">//枚举</span><br>    {<br>        <span class="hljs-keyword">if</span>(!line[i] &amp;&amp; g[u][i] == <span class="hljs-string">'#'</span>)<br>        {<br>            line[i] = <span class="hljs-literal">true</span>;<br>            m++;<br>            <span class="hljs-built_in">dfs</span>(u+<span class="hljs-number">1</span>);<br>            m--;<br>            line[i] = <span class="hljs-literal">false</span>;<br>        }<br>    }<br>    <span class="hljs-built_in">dfs</span>(u+<span class="hljs-number">1</span>);<span class="hljs-comment">//</span><br><br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>   <span class="hljs-keyword">while</span>(cin&gt;&gt;n&gt;&gt;k , n!=<span class="hljs-number">-1</span> &amp;&amp; k != <span class="hljs-number">-1</span>)<br>   {<br>        m = ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j= <span class="hljs-number">0</span>;j&lt;n;++j)<br>                cin&gt;&gt;g[i][j];<br>        <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>);<span class="hljs-comment">//枚举行数</span><br>        cout&lt;&lt;ans&lt;&lt;endl;<br>   }<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>
        </div>
      </div>
    </div></li>
</ol>
<hr>
<ol start="2">
<li>地牢大师<br>抛去三维不谈，这就是一道简单的板子题，可是这个是一道三维题，其中的坐标偏移量和平常所做的大不相同，所以得注意一下
    <div class="fold">
      <div class="fold-title fold-default collapsed" data-toggle="collapse" href="#collapse-b870a72b" role="button" aria-expanded="false" aria-controls="collapse-b870a72b">
        <div class="fold-arrow">▶</div>代码
      </div>
      <div class="fold-collapse collapse" id="collapse-b870a72b">
        <div class="fold-content">
          <figure class="highlight c++"><table><tbody><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">110</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">map</span><br>{<br>   <span class="hljs-type">int</span> l , r, c;   <br>};<br>map st,ed;<br><span class="hljs-type">int</span> l,c,r;<br><span class="hljs-type">char</span> g[N][N][N];<br><span class="hljs-type">int</span> dist[N][N][N];<br><span class="hljs-type">int</span> dx[] = {<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>};<br><span class="hljs-type">int</span> dy[] = {<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>};<br><span class="hljs-type">int</span> dz[] = {<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>};<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>   queue&lt;map&gt; q;<br>   <span class="hljs-built_in">memset</span>(dist ,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span> dist);<br>   q.<span class="hljs-built_in">push</span>(st);<br>   dist[st.l][st.r][st.c] = <span class="hljs-number">0</span>;<br>   <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>())<br>   {<br>      <span class="hljs-keyword">auto</span> t = q.<span class="hljs-built_in">front</span>();<br>      q.<span class="hljs-built_in">pop</span>();<br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">6</span>;++i)<br>      {<br>         <span class="hljs-type">int</span> x = t.l+dx[i];<br>         <span class="hljs-type">int</span> y = t.r+dy[i];<br>         <span class="hljs-type">int</span> z = t.c+dz[i];<br>         <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span> || x&gt;=l || y&lt;<span class="hljs-number">0</span> || y&gt;=r || z&lt;<span class="hljs-number">0</span> || z&gt;=c) <span class="hljs-keyword">continue</span>;<br>         <span class="hljs-keyword">if</span>(g[x][y][z] == <span class="hljs-string">'#'</span>) <span class="hljs-keyword">continue</span>;<br>         <span class="hljs-keyword">if</span>(dist[x][y][z] != <span class="hljs-number">-1</span>) <span class="hljs-keyword">continue</span>;<br>         dist[x][y][z] = dist[t.l][t.r][t.c] + <span class="hljs-number">1</span>;<br>         q.<span class="hljs-built_in">push</span>({x,y,z});<br>         <span class="hljs-keyword">if</span>(x == ed.l &amp;&amp; y == ed.r &amp;&amp; z == ed.c) <span class="hljs-keyword">return</span> dist[x][y][z];<br>         <br>      }<br>   }<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>   <span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d%d"</span>,&amp;l,&amp;r,&amp;c),l||r||c)<br>   {<br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;l;++i)<br>         <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j&lt;r;++j)<br>            {<br>                <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s"</span>,g[i][j]);<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>;k&lt;c;++k)<br>                {<br>                    <span class="hljs-type">char</span> cc = g[i][j][k];<br>                    <span class="hljs-keyword">if</span>(cc == <span class="hljs-string">'S'</span>) st = {i,j,k};<br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cc == <span class="hljs-string">'E'</span>) ed = {i,j,k};<br>                }<br>            }<br>      <span class="hljs-type">int</span> t = <span class="hljs-built_in">bfs</span>();<br>      <span class="hljs-keyword">if</span>(t == <span class="hljs-number">-1</span>) <span class="hljs-built_in">puts</span>(<span class="hljs-string">"Trapped!"</span>);<br>      <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Escaped in %d minute(s).\n"</span>,t);<br>   }<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br><br></code></pre></td></tr></tbody></table></figure>
        </div>
      </div>
    </div></li>
</ol>
<hr>
<ol start="3">
<li>抓住那头牛<br> 农夫有三种移动方式，分别是x+1,x-1,x*2<br> 求的是最短什么时候能抓住牛，dist[i]的含义就是从农夫的起点到i点所花费的最少时间，我们可以得出第一次走到这个点的时候就是从起点到这个点的最短时间。所以我们通过bfs进行搜索，搜索到了牛的点即停下来。
    <div class="fold">
      <div class="fold-title fold-default collapsed" data-toggle="collapse" href="#collapse-e064c6af" role="button" aria-expanded="false" aria-controls="collapse-e064c6af">
        <div class="fold-arrow">▶</div>代码
      </div>
      <div class="fold-collapse collapse" id="collapse-e064c6af">
        <div class="fold-content">
          <figure class="highlight c++"><table><tbody><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> x first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> y second</span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; PII;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> n,k;<br><span class="hljs-type">int</span> dist[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>	queue&lt;<span class="hljs-type">int</span>&gt; q;<br>	q.<span class="hljs-built_in">push</span>(n);<br>	<span class="hljs-built_in">memset</span>(dist,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span> dist);<br>	dist[n] = <span class="hljs-number">0</span> ;<br>	<span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())<br>	{<br>		<span class="hljs-keyword">auto</span> t = q.<span class="hljs-built_in">front</span>();<br>		q.<span class="hljs-built_in">pop</span>();<br>		<span class="hljs-keyword">if</span>(t == k) <span class="hljs-keyword">return</span> dist[k];<br>		<span class="hljs-keyword">if</span>(t+<span class="hljs-number">1</span> &lt; N &amp;&amp; dist[t+<span class="hljs-number">1</span>] == <span class="hljs-number">-1</span>) dist[t+<span class="hljs-number">1</span>] = dist[t] + <span class="hljs-number">1</span>,q.<span class="hljs-built_in">push</span>(t+<span class="hljs-number">1</span>);<br>		<span class="hljs-keyword">if</span>(t+<span class="hljs-number">-1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; dist[t<span class="hljs-number">-1</span>] == <span class="hljs-number">-1</span>) dist[t<span class="hljs-number">-1</span>] = dist[t] + <span class="hljs-number">1</span>,q.<span class="hljs-built_in">push</span>(t<span class="hljs-number">-1</span>);<br>		<span class="hljs-keyword">if</span>(t*<span class="hljs-number">2</span> &lt; N &amp;&amp; dist[t*<span class="hljs-number">2</span>] == <span class="hljs-number">-1</span>) dist[t*<span class="hljs-number">2</span>] = dist[t] + <span class="hljs-number">1</span>,q.<span class="hljs-built_in">push</span>(t*<span class="hljs-number">2</span>);<br>	} <br>	<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>}<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>	cin &gt;&gt; n &gt;&gt; k ;<br>	cout &lt;&lt; <span class="hljs-built_in">bfs</span>() &lt;&lt; endl;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br><br></code></pre></td></tr></tbody></table></figure>
        </div>
      </div>
    </div></li>
</ol>
<hr>
<ol start="4">
<li>翻转<br>因为按下一个会影响他周围4个的值，所以我们先单独考虑。如果第一排的按下状态是固定的，我们就考虑第二排，因为我们最终是想要得到一个全0的状态，所以当第二排的某个位置对应的第一排有1的时候，我们必须按下第二排的那个位置，才能改变上一排那个位置的值。<br>所以我们可以通过枚举第一排的状态，剩下的排的状态都是固定的，都是根据它上一排的状态而定，我们只需要判断是不是全0就知道第一排的状态是否正确，这里我采用二进制枚举的方式进行枚举第一排。
    <div class="fold">
      <div class="fold-title fold-default collapsed" data-toggle="collapse" href="#collapse-e6304534" role="button" aria-expanded="false" aria-controls="collapse-e6304534">
        <div class="fold-arrow">▶</div>代码
      </div>
      <div class="fold-collapse collapse" id="collapse-e6304534">
        <div class="fold-content">
          <figure class="highlight c++"><table><tbody><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">16</span>;<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> g[N][N];<br><span class="hljs-type">int</span> dx[] = {<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>};<br><span class="hljs-type">int</span> dy[] = {<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>};<br><span class="hljs-type">int</span> back[N][N];<br><span class="hljs-type">int</span> zero[N][N];<br><span class="hljs-type">int</span> ans[N][N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>    cin&gt;&gt;n&gt;&gt;m;<br><br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;m;++j)<br>            cin&gt;&gt;g[i][j];<br>    <span class="hljs-built_in">memcpy</span>(back,g,<span class="hljs-keyword">sizeof</span> g);<br>    <br>    <span class="hljs-keyword">auto</span> turn = [&amp;](<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y){<br>        g[x][y] ^=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;++i)<br>        {<br>            <span class="hljs-type">int</span> tx = x+dx[i];<br>            <span class="hljs-type">int</span> ty = y+dy[i];<br>            <span class="hljs-keyword">if</span>(tx&lt;<span class="hljs-number">0</span> || tx&gt;n || ty&lt;<span class="hljs-number">0</span> || ty&gt;m) <span class="hljs-keyword">continue</span>;<br>            g[tx][ty]^=<span class="hljs-number">1</span>;<br>        }<br>    };<br>    <span class="hljs-type">bool</span> find = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;(<span class="hljs-number">1</span>&lt;&lt;m);++i)<br>    {<br>        <span class="hljs-built_in">memcpy</span>(g,back,<span class="hljs-keyword">sizeof</span> back);<br>        <span class="hljs-built_in">memset</span>(ans,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span> ans);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;m;++j)<span class="hljs-comment">//</span><br>            <span class="hljs-keyword">if</span>(i&gt;&gt;j &amp;<span class="hljs-number">1</span>) <span class="hljs-built_in">turn</span>(<span class="hljs-number">0</span>,j),ans[<span class="hljs-number">0</span>][j] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n<span class="hljs-number">-1</span>;++j)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;m;++k)<br>                <span class="hljs-keyword">if</span>(g[j][k])<br>                    <span class="hljs-built_in">turn</span>(j+<span class="hljs-number">1</span>,k),ans[j+<span class="hljs-number">1</span>][k] = <span class="hljs-number">1</span>;<br>        <span class="hljs-type">bool</span> flag_check = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>;k&lt;m;++k)<br>            <span class="hljs-keyword">if</span>(g[n<span class="hljs-number">-1</span>][k])<br>                flag_check = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span>(flag_check)<br>        {<br>            find = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">break</span>;<br>        }<br>    }<br>    <span class="hljs-keyword">if</span>(find)<br>    {<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)<br>        {    <br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;m;++j)<br>            {<br>                cout&lt;&lt;ans[i][j]&lt;&lt;<span class="hljs-string">' '</span>;<br>            }<br>            cout&lt;&lt;endl;<br>        }   <br>    }<br>    <span class="hljs-keyword">else</span><br>    {<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">"IMPOSSIBLE"</span>);<br>    }<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br><br></code></pre></td></tr></tbody></table></figure>
        </div>
      </div>
    </div></li>
</ol>
<hr>
<ol start="5">
<li>找倍数<br>题意很简单，找到一个只由01构造的x的非零倍数,也就是说这个数字必须被x整除<br>我们直接从1开始拓展，只能拓展成两种状态,加1或者加0<br>因为数据太大，有$10^{100}$,根本存不下来，但是根据(a*b) % p = (a%p * b%p) % p，我们可以边计算边取模，并不会影响我们的答案。
    <div class="fold">
      <div class="fold-title fold-default collapsed" data-toggle="collapse" href="#collapse-61560f9f" role="button" aria-expanded="false" aria-controls="collapse-61560f9f">
        <div class="fold-arrow">▶</div>代码
      </div>
      <div class="fold-collapse collapse" id="collapse-61560f9f">
        <div class="fold-content">
          <figure class="highlight c++"><table><tbody><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> x;<br><span class="hljs-keyword">typedef</span> pair&lt;string,<span class="hljs-type">int</span>&gt; PII;<br><br><br><span class="hljs-function">string <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>{<br>    queue&lt;PII&gt; q;<br>    q.<span class="hljs-built_in">push</span>({<span class="hljs-string">"1"</span>,<span class="hljs-number">1</span>});<span class="hljs-comment">//从1开始拓展</span><br>    <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>())<br>    {<br>        PII t = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">if</span>(!t.second) <span class="hljs-keyword">return</span> t.first;<br>        q.<span class="hljs-built_in">push</span>({t.first+<span class="hljs-string">"0"</span> , (t.second * <span class="hljs-number">10</span> ) % x});<br>        q.<span class="hljs-built_in">push</span>({t.first+<span class="hljs-string">"1"</span> , (t.second * <span class="hljs-number">10</span> + <span class="hljs-number">1</span> ) % x});<br>    }<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">"-1"</span>;<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-keyword">while</span>(cin&gt;&gt;x,x)<br>    {<br>        cout&lt;&lt;<span class="hljs-built_in">bfs</span>(x)&lt;&lt;endl;<br>    }<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>
        </div>
      </div>
    </div></li>
</ol>
<hr>
<ol start="6">
<li>质数路径<br>题意就是给我们一个数a，b让我们求多少步才能做到，并且要求每一步得到的数都是一个质数。<br>我们可以先把所有在数据范围内的质数筛出来，可以更方便的判断，之后就是bfs，状态就是10个数字和更换的位置，因为数据范围特殊，所以这个所谓的二重循环很小。注意细节上的判断即可,前导0等。
    <div class="fold">
      <div class="fold-title fold-default collapsed" data-toggle="collapse" href="#collapse-2b769b72" role="button" aria-expanded="false" aria-controls="collapse-2b769b72">
        <div class="fold-arrow">▶</div>代码
      </div>
      <div class="fold-collapse collapse" id="collapse-2b769b72">
        <div class="fold-content">
          <figure class="highlight c++"><table><tbody><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;deque&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _fio                      \</span><br><span class="hljs-meta">	ios_base::sync_with_stdio(0); \</span><br><span class="hljs-meta">	cin.tie(0);                   \</span><br><span class="hljs-meta">	cout.tie(0);</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> all(x) (x).begin(), (x).end()</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> allr(x) (x).rbegin(), (x).rend()</span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; PII;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span> nl = <span class="hljs-string">'\n'</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span>;<br><span class="hljs-type">int</span> primes[N], cnt;<br><span class="hljs-type">bool</span> st[N];<br><span class="hljs-type">int</span> d[<span class="hljs-number">4</span>]={<span class="hljs-number">1</span>,<span class="hljs-number">10</span>,<span class="hljs-number">100</span>,<span class="hljs-number">1000</span>};<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get_primes</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>{<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; ++i)<br>	{<br>		<span class="hljs-keyword">if</span> (!st[i])<br>			primes[cnt++] = i;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; primes[j] * i &lt;= n; ++j)<br>		{<br>			st[primes[j] * i] = <span class="hljs-literal">true</span>;<br>			<span class="hljs-keyword">if</span> (i % primes[j] == <span class="hljs-number">0</span>)<br>				<span class="hljs-keyword">break</span>;<br>		}<br>	}<br>}<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>	<span class="hljs-type">int</span> a,b;<br>	cin &gt;&gt; a &gt;&gt; b;<br>	<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dist</span><span class="hljs-params">(N,<span class="hljs-number">-1</span>)</span></span>;<br>	dist[a] = <span class="hljs-number">0</span>;<br>	queue&lt;<span class="hljs-type">int</span>&gt; q;<br>	q.<span class="hljs-built_in">push</span>(a);<br>	<span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>())<br>	{<br>		<span class="hljs-type">int</span> t = q.<span class="hljs-built_in">front</span>();<br>		q.<span class="hljs-built_in">pop</span>();<br>		<span class="hljs-type">int</span> t2 = t;<br>		<span class="hljs-keyword">if</span>(t == b)<br>		{<br>			cout &lt;&lt; dist[t] &lt;&lt; nl;<br>			<span class="hljs-keyword">return</span> ;<br>		}<br>		vector&lt;<span class="hljs-type">int</span>&gt; bit;<br>		<span class="hljs-keyword">while</span>(t2)<span class="hljs-comment">//3才为最高位</span><br>		{<br>			bit.<span class="hljs-built_in">push_back</span>(t2%<span class="hljs-number">10</span>);<br>			t2/=<span class="hljs-number">10</span>;<br>		}<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=<span class="hljs-number">9</span>;++i)<br>		{<br>			<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">4</span>;++j)<br>			{<br>				<span class="hljs-keyword">auto</span> &amp;x = bit[j];<span class="hljs-comment">//将要替换的数字</span><br>				<span class="hljs-keyword">if</span>(x == i) <span class="hljs-keyword">continue</span>;<span class="hljs-comment">//数字相同</span><br>				<span class="hljs-keyword">if</span>(i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> &amp;&amp; j == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<span class="hljs-comment">//最低位是偶数，则跳过</span><br>				<span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span> &amp;&amp; j == <span class="hljs-number">3</span>) <span class="hljs-keyword">continue</span>;<span class="hljs-comment">//不能有前导0</span><br>				<span class="hljs-type">int</span> num = t - (x * d[j]) + (i * d[j]);<span class="hljs-comment">//新的数</span><br>				<span class="hljs-keyword">if</span>(num &lt; <span class="hljs-number">1000</span>) <span class="hljs-keyword">continue</span>;<br>				<span class="hljs-keyword">if</span>(st[num]) <span class="hljs-keyword">continue</span>;<span class="hljs-comment">//不是素数</span><br>				<span class="hljs-keyword">if</span>(dist[num] != <span class="hljs-number">-1</span>) <span class="hljs-keyword">continue</span>;<span class="hljs-comment">//更新过了</span><br>				dist[num] = dist[t] + <span class="hljs-number">1</span>;<br>				q.<span class="hljs-built_in">push</span>(num);<br>				<br>			}<br>		}<br>	}<br>}<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>	<span class="hljs-built_in">get_primes</span>(N + <span class="hljs-number">1</span>);<br>	<span class="hljs-type">int</span> t;<br>	cin &gt;&gt; t;<br>	<span class="hljs-keyword">while</span> (t--)<br>		<span class="hljs-built_in">fun</span>();<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br><br></code></pre></td></tr></tbody></table></figure>
        </div>
      </div>
    </div></li>
</ol>
<hr>
<ol start="7">
<li>洗牌<br>就是对两个字符串的操作，问能不能变成指定状态，给了一个指定的状态转移，我们直接模拟实现这一步即可，就是很普通的搜索。
    <div class="fold">
      <div class="fold-title fold-default collapsed" data-toggle="collapse" href="#collapse-ee3b64fe" role="button" aria-expanded="false" aria-controls="collapse-ee3b64fe">
        <div class="fold-arrow">▶</div>代码
      </div>
      <div class="fold-collapse collapse" id="collapse-ee3b64fe">
        <div class="fold-content">
          <figure class="highlight c++"><table><tbody><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;deque&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _fio                      \</span><br><span class="hljs-meta">    ios_base::sync_with_stdio(0); \</span><br><span class="hljs-meta">    cin.tie(0);                   \</span><br><span class="hljs-meta">    cout.tie(0);</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> all(x) (x).begin(), (x).end()</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> allr(x) (x).rbegin(), (x).rend()</span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; PII;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span> nl = <span class="hljs-string">'\n'</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-type">int</span> n;<br>string a, b, s;<br><span class="hljs-function">string <span class="hljs-title">str_change</span><span class="hljs-params">(string a, string b)</span></span><br><span class="hljs-function"></span>{<br>    string tm;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>    {<br>        tm += b[i];<br>        tm += a[i];<br>    }<br>    <span class="hljs-keyword">return</span> tm;<br>}<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>    cin &gt;&gt; n &gt;&gt; a &gt;&gt; b &gt;&gt; s;<br>    unordered_map&lt;string, <span class="hljs-type">int</span>&gt; dist;<br>    string start = <span class="hljs-built_in">str_change</span>(a, b);<br>    dist[start] = <span class="hljs-number">1</span>;<br>    queue&lt;string&gt; q;<br>    q.<span class="hljs-built_in">push</span>(start);<br>    <span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">size</span>())<br>    {<br>        <span class="hljs-keyword">auto</span> t = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">if</span>(t == s)<br>            <span class="hljs-keyword">return</span> dist[t]; <br>        string new_str = <span class="hljs-built_in">str_change</span>(t.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>,n),t.<span class="hljs-built_in">substr</span>(n));<br>        <span class="hljs-keyword">if</span>(dist.<span class="hljs-built_in">count</span>(new_str)) <span class="hljs-keyword">continue</span>;<br>        dist[new_str] = dist[t] + <span class="hljs-number">1</span>;<br>        q.<span class="hljs-built_in">push</span>(new_str);<br>    }<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>}<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-type">int</span> t;<br>    cin &gt;&gt; t;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=t;++i)<br>    {<br>        cout &lt;&lt; i &lt;&lt; <span class="hljs-string">" "</span>;<br>        cout &lt;&lt; <span class="hljs-built_in">fun</span>() &lt;&lt; nl;<br>    }<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>
        </div>
      </div>
    </div></li>
</ol>
<hr>
<ol start="8">
<li>罐子<br>两个罐子，一共有六种状态,状态存储，使用一个二维数组来存储，i是第一个罐子的状态，j是第二个。值得注意的是边界的判断很重要，不然可能不是最优解,导致心态炸裂。
    <div class="fold">
      <div class="fold-title fold-default collapsed" data-toggle="collapse" href="#collapse-cb71f24e" role="button" aria-expanded="false" aria-controls="collapse-cb71f24e">
        <div class="fold-arrow">▶</div>代码
      </div>
      <div class="fold-collapse collapse" id="collapse-cb71f24e">
        <div class="fold-content">
          <figure class="highlight c++"><table><tbody><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;deque&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _fio                      \</span><br><span class="hljs-meta">    ios_base::sync_with_stdio(0); \</span><br><span class="hljs-meta">    cin.tie(0);                   \</span><br><span class="hljs-meta">    cout.tie(0);</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> all(x) (x).begin(), (x).end()</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> allr(x) (x).rbegin(), (x).rend()</span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; PII;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span> nl = <span class="hljs-string">'\n'</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> INF = <span class="hljs-number">0x3f3f3f3f</span>;<br>string choice[] = {<span class="hljs-string">"NULL"</span>, <span class="hljs-string">"FILL(1)"</span>, <span class="hljs-string">"FILL(2)"</span>, <span class="hljs-string">"DROP(1)"</span>, <span class="hljs-string">"DROP(2)"</span>, <span class="hljs-string">"POUR(1,2)"</span>, <span class="hljs-string">"POUR(2,1)"</span>};<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">110</span>;<br>string s[N][N];<br><span class="hljs-type">bool</span> d[N][N];<br>string ans;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span></span><br><span class="hljs-function"></span>{<br>    queue&lt;PII&gt; q;<br>    q.<span class="hljs-built_in">push</span>({<span class="hljs-number">0</span>, <span class="hljs-number">0</span>});<br>    d[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">size</span>())<br>    {<br>        <span class="hljs-keyword">auto</span> t = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">auto</span> &amp;x = t.first;<br>        <span class="hljs-keyword">auto</span> &amp;y = t.second;<br>        <span class="hljs-keyword">if</span> (x == c || y == c)<br>        {<br>            ans = s[x][y];<br>            <span class="hljs-keyword">break</span>;<br>        }<br>        string &amp;ns = s[x][y];<br>        <span class="hljs-comment">// FILL和DROP</span><br>        <span class="hljs-keyword">if</span> (!d[a][y])<br>            d[a][y] = <span class="hljs-number">1</span>, q.<span class="hljs-built_in">push</span>({a, y}), s[a][y] = ns + <span class="hljs-string">'1'</span>;<br>        <span class="hljs-keyword">if</span> (!d[x][b])<br>            d[x][b] = <span class="hljs-number">1</span>, q.<span class="hljs-built_in">push</span>({x, b}), s[x][b] = ns + <span class="hljs-string">'2'</span>;<br>        <span class="hljs-keyword">if</span> (!d[<span class="hljs-number">0</span>][y])<br>            d[<span class="hljs-number">0</span>][y] = <span class="hljs-number">1</span>, q.<span class="hljs-built_in">push</span>({<span class="hljs-number">0</span>, y}), s[<span class="hljs-number">0</span>][y] = ns + <span class="hljs-string">'3'</span>;<br>        <span class="hljs-keyword">if</span> (!d[x][<span class="hljs-number">0</span>])<br>            d[x][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>, q.<span class="hljs-built_in">push</span>({x, <span class="hljs-number">0</span>}), s[x][<span class="hljs-number">0</span>] = ns + <span class="hljs-string">'4'</span>;<br>        <span class="hljs-comment">// POUR</span><br>        <span class="hljs-keyword">if</span> (x &gt; <span class="hljs-number">0</span> &amp;&amp; y &lt; b)<br>        {<br>            <span class="hljs-type">int</span> w = <span class="hljs-built_in">min</span>(x, b - y);<br>            <span class="hljs-keyword">if</span> (!d[x - w][y + w])<br>            {<br>                d[x - w][y + w] = <span class="hljs-number">1</span>;<br>                q.<span class="hljs-built_in">push</span>({x - w, y + w});<br>                s[x - w][y + w] = ns + <span class="hljs-string">'5'</span>;<br>            }<br>        }<br>        <span class="hljs-keyword">if</span> (x &lt; a &amp;&amp; y &gt; <span class="hljs-number">0</span>)<br>        {<br>            <span class="hljs-type">int</span> w = <span class="hljs-built_in">min</span>(a - x, y);<br>            <span class="hljs-keyword">if</span> (!d[x + w][y - w])<br>            {<br>                d[x + w][y - w] = <span class="hljs-number">1</span>;<br>                q.<span class="hljs-built_in">push</span>({x + w, y - w});<br>                s[x + w][y - w] = ns + <span class="hljs-string">'6'</span>;<br>            }<br>        }<br>    }<br>    <span class="hljs-keyword">if</span> (ans.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>)<br>    {<br>        cout &lt;&lt; <span class="hljs-string">"impossible"</span> &lt;&lt; nl;<br>    }<br>    <span class="hljs-keyword">else</span><br>    {<br>        cout &lt;&lt; ans.<span class="hljs-built_in">size</span>() &lt;&lt; nl;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; ans.<span class="hljs-built_in">size</span>(); ++i)<br>        {<br>            <span class="hljs-type">int</span> x = ans[i] - <span class="hljs-string">'0'</span>;<br>            cout &lt;&lt; choice[x] &lt;&lt; nl;<br>        }<br>    }<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-type">int</span> a, b, c;<br>    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;<br>    <span class="hljs-built_in">bfs</span>(a, b, c);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>
        </div>
      </div>
    </div></li>
</ol>
<hr>
<ol start="9">
<li>点火游戏<br>题意大概是，有草地和空地，让我们点燃一块或者两块草地，问最少需要多少时间可以让所有草地燃烧，空地不能被点燃。最优解肯定是能选两个就选两个，但是如果没办法就只能选0个或者不选（没有草地）。要小心一些特殊例子，不然很容易WA掉。还要注意草地循环的方式，得优化一半，不然会TLE。
    <div class="fold">
      <div class="fold-title fold-default collapsed" data-toggle="collapse" href="#collapse-a9dad5c9" role="button" aria-expanded="false" aria-controls="collapse-a9dad5c9">
        <div class="fold-arrow">▶</div>代码
      </div>
      <div class="fold-collapse collapse" id="collapse-a9dad5c9">
        <div class="fold-content">
          <figure class="highlight c++"><table><tbody><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;deque&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _fio ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> all(x) (x).begin(), (x).end()</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> allr(x) (x).rbegin(), (x).rend()</span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL ;<br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; PII;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span> nl = <span class="hljs-string">'\n'</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">11</span>;<br><span class="hljs-type">int</span> g[N][N];<span class="hljs-comment">//1代表空地，0代表草地</span><br><span class="hljs-type">int</span> d[N][N];<br><span class="hljs-type">int</span> n,m,tot;<span class="hljs-comment">//tot代表草地的数量</span><br><span class="hljs-type">int</span> dx[]={<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>};<br><span class="hljs-type">int</span> dy[]={<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>};<br>PII gress[N * N * <span class="hljs-number">2</span>];<span class="hljs-comment">//草地的坐标</span><br><span class="hljs-type">int</span> ans;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-type">int</span> tmp_ans = <span class="hljs-number">-2</span>;<br>    <span class="hljs-type">int</span> fire = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">memset</span>(d,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span> d);<br>    <span class="hljs-keyword">auto</span> &amp;u = gress[a];<br>    <span class="hljs-keyword">auto</span> &amp;v = gress[b];<br>    queue&lt;PII&gt; q;<br>    q.<span class="hljs-built_in">push</span>(u);<br>    q.<span class="hljs-built_in">push</span>(v);<span class="hljs-comment">//防止重复</span><br>    <span class="hljs-keyword">if</span>(u == v) q.<span class="hljs-built_in">pop</span>();<br>    d[u.first][u.second] = <span class="hljs-number">0</span>;<br>    d[v.first][v.second] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>())<br>    {<br>        <span class="hljs-keyword">auto</span> t = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        fire ++ ;<br>        tmp_ans = <span class="hljs-built_in">max</span>(tmp_ans,d[t.first][t.second]);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;++i)<br>        {<br>            <span class="hljs-type">int</span> x = dx[i] + t.first;<br>            <span class="hljs-type">int</span> y = dy[i] + t.second;<br>            <span class="hljs-keyword">if</span>(x &lt; <span class="hljs-number">0</span> || y &lt; <span class="hljs-number">0</span> || x&gt;=n || y&gt;=m) <span class="hljs-keyword">continue</span>;<span class="hljs-comment">//界限</span><br>            <span class="hljs-keyword">if</span>(g[x][y]) <span class="hljs-keyword">continue</span>;<span class="hljs-comment">//空地</span><br>            <span class="hljs-keyword">if</span>(d[x][y] != <span class="hljs-number">-1</span>) <span class="hljs-keyword">continue</span>;<span class="hljs-comment">//有火</span><br><br>            d[x][y] = d[t.first][t.second] + <span class="hljs-number">1</span>;<br>            q.<span class="hljs-built_in">push</span>({x,y});<br>        }<br>    }<br>    <span class="hljs-keyword">if</span>(tot != fire) {<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;}<br>    <span class="hljs-keyword">return</span> tmp_ans;<br>}<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>    ans = <span class="hljs-number">0x3f3f3f3f</span>;<br>    tot = <span class="hljs-number">0</span>;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;m;++j)<br>        {<br>            <span class="hljs-type">char</span> tmp;cin &gt;&gt; tmp;<br>            <span class="hljs-keyword">if</span>(tmp == <span class="hljs-string">'#'</span>) g[i][j] = <span class="hljs-number">0</span>,gress[tot ++ ] = {i,j};<br>            <span class="hljs-keyword">else</span> g[i][j] = <span class="hljs-number">1</span>;<br>        }<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>;a&lt;tot;++a)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> b=a;b&lt;tot;++b)<br>        {<br>            <span class="hljs-type">int</span> sw = <span class="hljs-built_in">bfs</span>(a,b);<br>            <span class="hljs-keyword">if</span>(sw &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>            ans = <span class="hljs-built_in">min</span>(ans,sw);<br>        }<br>    <span class="hljs-keyword">if</span>(ans == <span class="hljs-number">0x3f3f3f3f</span>) cout &lt;&lt; <span class="hljs-string">"-1\n"</span>;<br>    <span class="hljs-keyword">else</span> cout &lt;&lt; ans &lt;&lt; nl;<br>}<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>    _fio<br>    <span class="hljs-type">int</span> t;cin &gt;&gt; t;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=t;++i){<br>        cout &lt;&lt; <span class="hljs-string">"Case "</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">": "</span>;<br>        <span class="hljs-built_in">fun</span>();<br>    }<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br><br></code></pre></td></tr></tbody></table></figure>
        </div>
      </div>
    </div></li>
</ol>
<hr>
<ol start="10">
<li>起火迷宫<br>搜索两次,先预处理火到每个点的位置，之后搜索人能不能逃出去的路径，边界处理很重要，而且比较难调。wa过很多次。s
    <div class="fold">
      <div class="fold-title fold-default collapsed" data-toggle="collapse" href="#collapse-22ba614d" role="button" aria-expanded="false" aria-controls="collapse-22ba614d">
        <div class="fold-arrow">▶</div>代码
      </div>
      <div class="fold-collapse collapse" id="collapse-22ba614d">
        <div class="fold-content">
          <figure class="highlight c++"><table><tbody><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;deque&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _fio ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL ;<br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; PII;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><span class="hljs-type">int</span> g[N][N],d[N][N],f[N][N];<br><span class="hljs-type">int</span> dx[] = {<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">1</span>}, dy[] = {<span class="hljs-number">-1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>};<br><span class="hljs-type">int</span> n,m;<span class="hljs-type">char</span> c;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>    _fio<br>    <span class="hljs-type">int</span> T;cin &gt;&gt; T;<br>    <span class="hljs-keyword">while</span>(T -- )<br>    {<br>        <span class="hljs-built_in">memset</span>(g,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span> g);<br>        <span class="hljs-built_in">memset</span>(d,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span> d);<br>        <span class="hljs-built_in">memset</span>(f,<span class="hljs-number">0x3f</span>,<span class="hljs-keyword">sizeof</span> f);<br>        cin &gt;&gt; n &gt;&gt; m ;<br>        queue&lt;PII&gt; Q,F;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;++j)<br>                <span class="hljs-keyword">if</span>(cin &gt;&gt; c &amp;&amp; c == <span class="hljs-string">'#'</span>) g[i][j] = <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c == <span class="hljs-string">'J'</span>) Q.<span class="hljs-built_in">push</span>({i,j}),d[i][j] = <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c == <span class="hljs-string">'F'</span>) F.<span class="hljs-built_in">push</span>({i,j}),f[i][j] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(F.<span class="hljs-built_in">size</span>())<br>        {<br>            <span class="hljs-keyword">auto</span> t = F.<span class="hljs-built_in">front</span>();<br>            F.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;++i)<br>            {<br>                <span class="hljs-type">int</span> a = dx[i] + t.first,b = dy[i] + t.second;<br>                <span class="hljs-keyword">if</span>(g[a][b]) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">if</span>(f[a][b] == <span class="hljs-number">0x3f3f3f3f</span>)<br>                {<br>                    f[a][b] = f[t.first][t.second] + <span class="hljs-number">1</span>;<br>                    <span class="hljs-keyword">if</span>(!(!a||!b||a == n+<span class="hljs-number">1</span> || b == m + <span class="hljs-number">1</span>)) F.<span class="hljs-built_in">push</span>({a,b});<br>                }<br>            }<br>        }<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">1e9</span>;<br>        <span class="hljs-keyword">while</span>(Q.<span class="hljs-built_in">size</span>())<br>        {<br>            <span class="hljs-keyword">auto</span> t = Q.<span class="hljs-built_in">front</span>();<br>            Q.<span class="hljs-built_in">pop</span>();<br><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;++i)<br>            {<br>                <span class="hljs-type">int</span> a = dx[i] + t.first,b = dy[i] + t.second;<br>                <span class="hljs-keyword">if</span>(g[a][b] || d[t.first][t.second] + <span class="hljs-number">1</span> &gt;= f[a][b]) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">if</span>(d[a][b] == <span class="hljs-number">0</span>)<br>                {<br>                    d[a][b] = d[t.first][t.second] + <span class="hljs-number">1</span>;<br>                    <span class="hljs-keyword">if</span>(!(!a||!b||a == n+<span class="hljs-number">1</span> || b == m + <span class="hljs-number">1</span>)) Q.<span class="hljs-built_in">push</span>({a,b});<br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(d[a][b] &lt; f[a][b]) ans = <span class="hljs-built_in">min</span>(ans,d[a][b]);<br>                }<br>            }<br>        }<br>        <span class="hljs-keyword">if</span>(ans == <span class="hljs-number">1e9</span>) cout &lt;&lt; <span class="hljs-string">"IMPOSSIBLE\n"</span>;<br>        <span class="hljs-keyword">else</span> cout &lt;&lt; ans - <span class="hljs-number">1</span> &lt;&lt; endl;<br>    }<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br><br></code></pre></td></tr></tbody></table></figure>
        </div>
      </div>
    </div></li>
</ol>
<hr>
<ol start="11">
<li>迷宫问题<br>本题就是考察一个记录迷宫路径问题，可以经常回顾。
    <div class="fold">
      <div class="fold-title fold-default collapsed" data-toggle="collapse" href="#collapse-07aa5f77" role="button" aria-expanded="false" aria-controls="collapse-07aa5f77">
        <div class="fold-arrow">▶</div>代码
      </div>
      <div class="fold-collapse collapse" id="collapse-07aa5f77">
        <div class="fold-content">
          <figure class="highlight c++"><table><tbody><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> x first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> y second</span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; PII;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> dx[] = {<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>};<br><span class="hljs-type">int</span> dy[] = {<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>};<br><span class="hljs-type">int</span> g[N][N];<br>queue&lt;PII&gt; q;<br>PII pre[N][N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-type">int</span> sx,<span class="hljs-type">int</span> sy)</span></span><br><span class="hljs-function"></span>{<br>	q.<span class="hljs-built_in">push</span>({sx,sy});<br>	<span class="hljs-built_in">memset</span>(pre, <span class="hljs-number">-1</span> , <span class="hljs-keyword">sizeof</span> pre);<br>	pre[sx][sy] = {<span class="hljs-number">0</span>,<span class="hljs-number">0</span>};<br>	<span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())<br>	{<br>		<span class="hljs-keyword">auto</span> t = q.<span class="hljs-built_in">front</span>();<br>		q.<span class="hljs-built_in">pop</span>();<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;++i)<br>		{<br>			<span class="hljs-type">int</span> a = t.x + dx[i];<br>			<span class="hljs-type">int</span> b = t.y + dy[i];<br>			<span class="hljs-keyword">if</span>(a &lt; <span class="hljs-number">0</span> || a&gt;=n || b&lt;<span class="hljs-number">0</span> || b&gt;=n) <span class="hljs-keyword">continue</span>;<br>			<span class="hljs-keyword">if</span>(g[a][b]) <span class="hljs-keyword">continue</span>;<br>			<span class="hljs-keyword">if</span>(pre[a][b].x != <span class="hljs-number">-1</span>) <span class="hljs-keyword">continue</span>;<br>			q.<span class="hljs-built_in">push</span>({a,b});<br>			pre[a][b] = t;<br>		}<br>	}<br>}<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n);<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;++j)<br>			<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;g[i][j]);<br>	<span class="hljs-built_in">bfs</span>(n<span class="hljs-number">-1</span>,n<span class="hljs-number">-1</span>);<br>	<span class="hljs-function">PII <span class="hljs-title">end</span><span class="hljs-params">(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)</span></span>;<br>	<span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)<br>	{<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d %d\n"</span>,end.x,end.y);<br>		<span class="hljs-keyword">if</span>(end.x == n<span class="hljs-number">-1</span> &amp;&amp; end.y == n<span class="hljs-number">-1</span>) <span class="hljs-keyword">break</span>;<br>		end = pre[end.x][end.y];<br>	}<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br><br></code></pre></td></tr></tbody></table></figure>
        </div>
      </div>
    </div></li>
</ol>
<hr>
<ol start="12">
<li>石油储备<br>经典Flood Fill问题,大致思路就是选一个点，遍历完周围所有点，结束时去下一个位置，一直检索，数出来连通块的个数。
    <div class="fold">
      <div class="fold-title fold-default collapsed" data-toggle="collapse" href="#collapse-4dd1c025" role="button" aria-expanded="false" aria-controls="collapse-4dd1c025">
        <div class="fold-arrow">▶</div>代码
      </div>
      <div class="fold-collapse collapse" id="collapse-4dd1c025">
        <div class="fold-content">
          <figure class="highlight c++"><table><tbody><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;deque&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _fio                      \</span><br><span class="hljs-meta">    ios_base::sync_with_stdio(0); \</span><br><span class="hljs-meta">    cin.tie(0);                   \</span><br><span class="hljs-meta">    cout.tie(0);</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> all(x) (x).begin(), (x).end()</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> allr(x) (x).rbegin(), (x).rend()</span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; PII;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span> nl = <span class="hljs-string">'\n'</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">110</span>;<br><span class="hljs-type">int</span> n, m, cnt;<br><span class="hljs-type">char</span> g[N][N];<br><span class="hljs-type">bool</span> st[N][N];<br><span class="hljs-type">int</span> dx[] = {<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>};<br><span class="hljs-type">int</span> dy[] = {<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>};<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function"></span>{<br>    queue&lt;PII&gt; q;<br>    q.<span class="hljs-built_in">push</span>({x,y});<br>    <span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">size</span>())<br>    {<br>        <span class="hljs-keyword">auto</span> t = q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++)<br>        {<br>            <span class="hljs-type">int</span> a = dx[i] + t.first;<br>            <span class="hljs-type">int</span> b = dy[i] + t.second;<br>            <span class="hljs-keyword">if</span>(a &lt; <span class="hljs-number">0</span> || b &lt; <span class="hljs-number">0</span> || a&gt;=n || b&gt;=m) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span>(g[a][b] == <span class="hljs-string">'*'</span>) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span>(st[a][b]) <span class="hljs-keyword">continue</span>;<br><br>            q.<span class="hljs-built_in">push</span>({a,b});<br>            st[a][b] = <span class="hljs-number">1</span>; <br>        }<br>        <br>    }<br>    <br>}<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-keyword">while</span> (cin &gt;&gt; n &gt;&gt; m, n,m)<br>    {<br>        cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">memset</span>(st,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span> st);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>            cin &gt;&gt; g[i];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; ++j)<br>            {<br>                <span class="hljs-keyword">if</span> (!st[i][j] &amp;&amp; g[i][j] == <span class="hljs-string">'@'</span>)<br>                {<br>                    st[i][j] = <span class="hljs-number">1</span>;<br>                    <span class="hljs-built_in">bfs</span>(i, j);<br>                    cnt ++ ;<br>                }<br>            }<br>        cout &lt;&lt; cnt &lt;&lt; nl;<br>    }<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>
        </div>
      </div>
    </div></li>
</ol>
<hr>
<ol start="13">
<li>非常可乐<br>类似于罐子那道题，条件比较难想
    <div class="fold">
      <div class="fold-title fold-default collapsed" data-toggle="collapse" href="#collapse-d0178fdf" role="button" aria-expanded="false" aria-controls="collapse-d0178fdf">
        <div class="fold-arrow">▶</div>代码
      </div>
      <div class="fold-collapse collapse" id="collapse-d0178fdf">
        <div class="fold-content">
          <figure class="highlight c++"><table><tbody><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;deque&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _fio ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> all(x) (x).begin(), (x).end()</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> allr(x) (x).rbegin(), (x).rend()</span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL ;<br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; PII;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span> nl = <span class="hljs-string">'\n'</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">110</span>;<br><span class="hljs-type">bool</span> st[N][N][N];<br><span class="hljs-type">int</span> v[<span class="hljs-number">3</span>];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span><br>{<br>    <span class="hljs-type">int</span> a,b,c,w;<br>};<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>    queue&lt;Node&gt; q;<br>    <span class="hljs-built_in">memset</span>(st,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span> st);<br>    q.<span class="hljs-built_in">push</span>({v[<span class="hljs-number">0</span>],<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>});<br>    st[v[<span class="hljs-number">0</span>]][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>())<br>    {<br>        <span class="hljs-keyword">auto</span> t = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-type">int</span> u[<span class="hljs-number">3</span>] = {t.a,t.b,t.c};<br>        <span class="hljs-keyword">if</span>((u[<span class="hljs-number">0</span>] == u[<span class="hljs-number">1</span>] &amp;&amp; !u[<span class="hljs-number">2</span>]) ||<br>            (u[<span class="hljs-number">1</span>] == u[<span class="hljs-number">2</span>] &amp;&amp; !u[<span class="hljs-number">0</span>]) ||<br>            (u[<span class="hljs-number">2</span>] == u[<span class="hljs-number">0</span>] &amp;&amp; !u[<span class="hljs-number">1</span>]))<br>            {<br>                <span class="hljs-keyword">return</span> t.w;<br>            }<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">3</span>;++i)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">3</span>;++j)<br>                <span class="hljs-keyword">if</span>(i!=j &amp;&amp; u[i] &amp;&amp; u[j] != v[j])<span class="hljs-comment">//pour each other</span><br>                {<br>                    <span class="hljs-comment">//backup</span><br>                    <span class="hljs-type">int</span> ui = u[i];<br>                    <span class="hljs-type">int</span> uj = u[j];<br>                    <span class="hljs-comment">//i -&gt; j</span><br>                    <span class="hljs-keyword">if</span>(v[j]-u[j]&lt;=u[i])<br>                    {<br>                        <span class="hljs-comment">//no pour all</span><br>                        u[i] -= v[j] - u[j];<br>                        u[j] = v[j];<br>                    }<br>                    <span class="hljs-keyword">else</span><br>                    {<br>                        <span class="hljs-comment">//pour all</span><br>                        u[j] += u[i];<br>                        u[i] = <span class="hljs-number">0</span>;<br>                    }<br>                    <span class="hljs-keyword">if</span>(!st[u[<span class="hljs-number">0</span>]][u[<span class="hljs-number">1</span>]][u[<span class="hljs-number">2</span>]])<br>                    {<br>                        st[u[<span class="hljs-number">0</span>]][u[<span class="hljs-number">1</span>]][u[<span class="hljs-number">2</span>]] = <span class="hljs-literal">true</span>;<br>                        q.<span class="hljs-built_in">push</span>(Node{u[<span class="hljs-number">0</span>],u[<span class="hljs-number">1</span>],u[<span class="hljs-number">2</span>],t.w + <span class="hljs-number">1</span>});<br>                    } <br>                    u[i] = ui;<br>                    u[j] = uj;  <br>                }<br>    }<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br>}<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-keyword">while</span>(cin &gt;&gt; v[<span class="hljs-number">0</span>] &gt;&gt; v[<span class="hljs-number">1</span>] &gt;&gt; v[<span class="hljs-number">2</span>],v[<span class="hljs-number">0</span>],v[<span class="hljs-number">1</span>],v[<span class="hljs-number">2</span>])<br>    {<br>        <span class="hljs-type">int</span> ans = <span class="hljs-built_in">bfs</span>();<br>        <span class="hljs-keyword">if</span>(ans == <span class="hljs-number">-1</span>) cout &lt;&lt; <span class="hljs-string">"NO"</span> &lt;&lt; nl;<br>        <span class="hljs-keyword">else</span> cout &lt;&lt; ans &lt;&lt; nl;<br>    }<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br><br></code></pre></td></tr></tbody></table></figure>
        </div>
      </div>
    </div></li>
</ol>
<hr>
<ol start="14">
<li>找路<br>分别按照两个点进行bfs即可,最终的答案就是两个人都可以到的餐厅的到达之间之和。
    <div class="fold">
      <div class="fold-title fold-default collapsed" data-toggle="collapse" href="#collapse-c9b90bf4" role="button" aria-expanded="false" aria-controls="collapse-c9b90bf4">
        <div class="fold-arrow">▶</div>代码
      </div>
      <div class="fold-collapse collapse" id="collapse-c9b90bf4">
        <div class="fold-content">
          <figure class="highlight c++"><table><tbody><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;deque&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _fio                      \</span><br><span class="hljs-meta">    ios_base::sync_with_stdio(0); \</span><br><span class="hljs-meta">    cin.tie(0);                   \</span><br><span class="hljs-meta">    cout.tie(0);</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> all(x) (x).begin(), (x).end()</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> allr(x) (x).rbegin(), (x).rend()</span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; PII;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span> nl = <span class="hljs-string">'\n'</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">222</span>;<br><span class="hljs-type">int</span> d1[N][N],d2[N][N];<br><span class="hljs-type">char</span> g[N][N];<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    Y : 小Y位置</span><br><span class="hljs-comment">    M : 小M位置</span><br><span class="hljs-comment">    # : 障碍</span><br><span class="hljs-comment">    . : 空地</span><br><span class="hljs-comment">    @ ：餐厅</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">int</span> n, m;<br>PII a, b;<br><span class="hljs-type">int</span> dx[] = {<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>};<br><span class="hljs-type">int</span> dy[] = {<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>};<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs1</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>    queue&lt;PII&gt; q;<br>    q.<span class="hljs-built_in">push</span>(a);<br>    d1[a.first][a.second] = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">size</span>())<br>    {<br>        <span class="hljs-keyword">auto</span> t = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; ++i)<br>        {<br>            <span class="hljs-type">int</span> tx = dx[i] + t.first;<br>            <span class="hljs-type">int</span> ty = dy[i] + t.second;<br>            <span class="hljs-keyword">if</span> (tx &lt; <span class="hljs-number">0</span> || ty &lt; <span class="hljs-number">0</span> || tx &gt;= n || ty &gt;= m)<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span>(g[tx][ty] == <span class="hljs-string">'#'</span>) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span>(d1[tx][ty] != <span class="hljs-number">-1</span>) <span class="hljs-keyword">continue</span>;<br>            d1[tx][ty] = d1[t.first][t.second] + <span class="hljs-number">1</span>;<br>            q.<span class="hljs-built_in">push</span>({tx,ty});<br>        }<br>    }<br>}<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs2</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>    queue&lt;PII&gt; q;<br>    q.<span class="hljs-built_in">push</span>(b);<br>    d2[b.first][b.second] = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">size</span>())<br>    {<br>        <span class="hljs-keyword">auto</span> t = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; ++i)<br>        {<br>            <span class="hljs-type">int</span> tx = dx[i] + t.first;<br>            <span class="hljs-type">int</span> ty = dy[i] + t.second;<br>            <span class="hljs-keyword">if</span> (tx &lt; <span class="hljs-number">0</span> || ty &lt; <span class="hljs-number">0</span> || tx &gt;= n || ty &gt;= m)<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span>(g[tx][ty] == <span class="hljs-string">'#'</span>) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span>(d2[tx][ty] != <span class="hljs-number">-1</span>) <span class="hljs-keyword">continue</span>;<br>            d2[tx][ty] = d2[t.first][t.second] + <span class="hljs-number">1</span>;<br>            q.<span class="hljs-built_in">push</span>({tx,ty});<br>        }<br>    }<br>}<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-keyword">while</span> (~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d %d"</span>,&amp;n,&amp;m))<br>    {<br>        vector&lt;PII&gt; v;<br>        <span class="hljs-built_in">memset</span>(d1, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> d1);<br>        <span class="hljs-built_in">memset</span>(d2, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> d2);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>        {<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; ++j)<br>            {<br>                cin &gt;&gt; g[i][j];<br>                <span class="hljs-keyword">if</span> (g[i][j] == <span class="hljs-string">'Y'</span>)<br>                    a = {i, j};<br>                <span class="hljs-keyword">if</span> (g[i][j] == <span class="hljs-string">'M'</span>)<br>                    b = {i, j};<br>                <span class="hljs-keyword">if</span> (g[i][j] == <span class="hljs-string">'@'</span>)<br>                    v.<span class="hljs-built_in">push_back</span>({i, j});<br>            }<br>        }<br>        <span class="hljs-built_in">bfs1</span>();<br>        <span class="hljs-built_in">bfs2</span>();<br>        <span class="hljs-type">int</span> ans = INF;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> el : v)<br>        {<br>            <span class="hljs-type">int</span> x1 = d1[el.first][el.second];<br>            <span class="hljs-type">int</span> x2 = d2[el.first][el.second];<br>            <span class="hljs-keyword">if</span>(x1 != <span class="hljs-number">-1</span> &amp;&amp; x2 != <span class="hljs-number">-1</span>)<br>            ans = <span class="hljs-built_in">min</span>(ans, x1 + x2);<br>        }<br>        cout &lt;&lt; ans * <span class="hljs-number">11</span> &lt;&lt; nl;<br>    }<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br><br></code></pre></td></tr></tbody></table></figure>
        </div>
      </div>
    </div></li>
</ol>
<hr>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>kuangbin</tag>
      </tags>
  </entry>
  <entry>
    <title>区间DP</title>
    <url>/posts/628fb573/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>区间类动态规划是线性动态规划的扩展，它在分阶段地划分问题时，与阶段中元素出现的顺序和由前一阶段的哪些元素合并而来有很大的关系。</p>
<p>令状态$f(l,r)$表示$l到r$ 的区间的元素合并能获得到的价值最大（最小），为此$f(l,r) = max{f(l,k)+f(k+1,r) + W}$,$W$为这两个区间合并起来的价值。</p>
<p>该问题的求解主要是通过合并小区间的最优解进而得出整个大区间的最优解。</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>区间 DP 有以下特点：</p>
<p><strong>合并</strong>：即将两个或多个部分进行整合，当然也可以反过来；</p>
<p><strong>特征</strong>：能将问题分解为能两两合并的形式；</p>
<p><strong>求解</strong>：对整个问题设最优值，枚举合并点，将问题分解为左右两个部分，最后合并两个部分的最优值得到原问题的最优值。</p>
<h3 id="一般解法"><a href="#一般解法" class="headerlink" title="一般解法"></a>一般解法</h3><ul>
<li>一般第一层是枚举 $len$ 长度</li>
<li>第二层是枚举 $l$ 也就是左端点，然后 $r$ 可以通过 $l + len - 1$ 计算出来</li>
<li>第三层是枚举断点 $k$ 从 $l$ 到 $r$</li>
</ul>
<h2 id="经典题目"><a href="#经典题目" class="headerlink" title="经典题目"></a>经典题目</h2><h3 id="石子合并"><a href="#石子合并" class="headerlink" title="石子合并"></a>石子合并</h3><p>经典思想: 拆环成链,通过复制数组的手段达到将一个环拆成链式的结构，方便求解。</p>
<h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>对于每一个区间 $(l,r)$ 我们可以通过 $k$ 将整个区间分为两块 $f(l,k),f(k+1,r)$ ，如果要求$(l,r)$ 这个区间的最大/最小值，对于任意两堆，我们可以直接把这两堆的和加上，作为一部分贡献W，但是可以发现，如果某一堆里面有多个数，我们不仅仅只加当前的值，还需要加上整个区间的区间和C。</p>
<p>对于我们区间$(l,r)$来说，我们每次合并所产生的值就为 $W + C$ 因为 $(l,r)$ 区间是固定的，所以能够变换的只有 $W$ 所以我们怎样求 $W$ 的最大/最小 又成了一个子问题。我们对于每一个区间 $(l,r)$ 会有大量的这样的重叠子问题，所以我们才会按照 $k$ 来将我们的区间划分为两部分。<br>例如这个样例</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-number">4</span><br><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br><br><span class="hljs-number">19</span> <span class="hljs-number">26</span><br></code></pre></td></tr></tbody></table></figure>
<p><img src="https://pic.imgdb.cn/item/669ba841d9c307b7e980e185.png"></p>
<p>图中表示的是最小值的合并方式，对于区间$(1,3)$ 来说我们可能还会由 $f(1,1),f(2,3)$ 这里便出现了重叠子问题。</p>
<p>最后：<br>当$l == r$ 单个位置得分为0：$f_{len,l,r} = 0$<br>当 $l \neq r$</p>
<ul>
<li>计算最大值的转移：$f_{len,l,r}=max(f_{k−l+1,l,k}+f_{len−(k−l+1),k+1,r}+cost_{l,r})$ $(l \leq k \lt r)$ </li>
<li>计算最小值的转移：$f_{len,l,r}=min(f_{k−l+1,l,k}+f_{len−(k−l+1),k+1,r}+cost_{l,r})$ $(l \leq k \lt r)$</li>
</ul>
<p><a href="https://www.luogu.com.cn/problem/P1880">P1880 [NOI1995] 石子合并 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
<h2 id="平行四边形优化"><a href="#平行四边形优化" class="headerlink" title="平行四边形优化"></a>平行四边形优化</h2><p>因为我们普通的区间DP时间复杂度是 $O(n^3)$ 但是我们状态转移方程又设计好了，怎么去优化呢？</p>
<h3 id="动态规划优化与四边形不等式"><a href="#动态规划优化与四边形不等式" class="headerlink" title="动态规划优化与四边形不等式"></a>动态规划优化与四边形不等式</h3><p>有方程：$f(i,j) = \min(f(i,k) + f(k+1,j) + w(i,j)), s(i,j)$ 为最优点取到值。</p>
<h4 id="四边形不等式"><a href="#四边形不等式" class="headerlink" title="四边形不等式"></a>四边形不等式</h4><p>如果函数 $w$ 满足以下不等式：<br>$$<br>f(i, j) + f(i’, j’) \leq f(i’, j) + f(i, j’)<br>$$</p>
<p>那么我们称函数 $w$ 满足四边形不等式。这个性质对于优化动态规划算法非常重要。</p>
<h4 id="平行四边形优化-1"><a href="#平行四边形优化-1" class="headerlink" title="平行四边形优化"></a>平行四边形优化</h4><p>在满足四边形不等式的情况下，我们可以利用以下性质来加速计算：</p>
<p>$$<br>s(i, j-1) \leq s(i, j) \leq s(i + 1, j)<br>$$</p>
<p>其中，$s(i,j)$ 是计算过程中记录的最优分割点。这个优化思想利用了平行四边形不等式来减少不必要的计算，从而提高了算法的效率。</p>
<h3 id="算法改动"><a href="#算法改动" class="headerlink" title="算法改动"></a>算法改动</h3><ol>
<li><p><strong>添加 $s(i,j)$ 数组</strong>：记录在计算 $f(i,j)$ 时的最优分割点 $k$。对角线初始化为 $i$，以便跟踪最优分割点。</p>
</li>
<li><p><strong>更改 $k$ 的循环范围</strong>：更新循环范围为 $s(i,j-1)$ 到 $s(i+1,j)$，依据新加入的条件和 $s(i,j)$ 的值来选择分割点。</p>
</li>
<li><p><strong>条件判断</strong>：用 <code>if</code> 判断来选择分割点，而不是使用 <code>max/min</code>。在更新 $f(i,j)$ 时，也同时更新 $s(i,j)$ 为当前的最优分割点 $k$。</p>
</li>
<li><p>**更新 $f(i,j)$ 和 $s(i,j)$**：确保在每次更新 $f(i,j)$ 时，同时更新 $s(i,j)$。</p>
</li>
</ol>
<p>这种优化能够利用四边形不等式加速动态规划计算过程，提高算法效率。</p>
<p>具体看别的大佬描述<br><a href="https://blog.csdn.net/noiau/article/details/72514812">四边形不等式优化讲解（详解）-CSDN博客</a></p>
<p>注: 由于石子合并求最大值以及最小值，所以对于最小值我们并不能进行平行四边形优化。</p>
<blockquote>
<p>本文参考<a href="https://oi-wiki.org/dp/interval/">区间 DP - OI Wiki (oi-wiki.org)</a></p>
</blockquote>
]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>区间DP</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>记忆化搜索</title>
    <url>/posts/cb5e0eb8/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>记忆化搜索（Memoization）是一种优化技术，用于通过存储已经计算过的结果来避免重复计算。它是一种动态规划的实现方式，通常用于递归算法中。通过将中间结果存储在数据结构（如数组或字典）中，记忆化搜索可以显著提高算法的效率，特别是在解决具有重叠子问题的计算问题时。</p>
<p>简单来说就是当算法需要计算某个子问题的结果时，它首先检查是否已经计算过该问题。如果已经计算过，则直接返回已经存储的结果；否则，计算该问题，并将结果存储下来以备将来使用。</p>
<h2 id="记忆化搜索与递推区别"><a href="#记忆化搜索与递推区别" class="headerlink" title="记忆化搜索与递推区别"></a>记忆化搜索与递推区别</h2><h4 id="记忆化搜索："><a href="#记忆化搜索：" class="headerlink" title="记忆化搜索："></a>记忆化搜索：</h4><p>「自顶向下」的解决问题，采用自然的递归方式编写过程，在过程中会保存每个子问题的解（通常保存在一个数组或哈希表中）来避免重复计算。</p>
<p>优点：代码清晰易懂，可以有效的处理一些复杂的状态转移方程。有些状态转移方程是非常复杂的，使用记忆化搜索可以将复杂的状态转移方程拆分成多个子问题，通过递归调用来解决。</p>
<p>缺点：可能会因为递归深度过大而导致栈溢出问题。</p>
<h4 id="递推："><a href="#递推：" class="headerlink" title="递推："></a>递推：</h4><p>「自底向上」的解决问题，采用循环的方式编写过程，在过程中通过保存每个子问题的解（通常保存在一个数组或哈希表中）来避免重复计算。</p>
<p>优点：避免了深度过大问题，不存在栈溢出问题。计算顺序比较明确，易于实现。</p>
<p>缺点：无法处理一些复杂的状态转移方程。有些状态转移方程非常复杂，如果使用递推方法来计算，就会导致代码实现变得非常困难。</p>
<h2 id="如何写记忆化搜索"><a href="#如何写记忆化搜索" class="headerlink" title="如何写记忆化搜索"></a>如何写记忆化搜索</h2><h3 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h3><ol>
<li>把这道题的 dp 状态和方程写出来</li>
<li>根据它们写出 dfs 函数</li>
<li>添加记忆化数组</li>
</ol>
<h3 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h3><ol>
<li>写出这道题的暴搜程序（最好是dfs）</li>
<li>将这个 dfs 改成「无需外部变量」的 dfs</li>
<li>添加记忆化数组</li>
</ol>
<h2 id="简单题目"><a href="#简单题目" class="headerlink" title="简单题目"></a>简单题目</h2><p><a href="https://www.luogu.com.cn/problem/P1464">P1464 Function - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a>启蒙题</p>
]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>记忆化搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>二分法</title>
    <url>/posts/3510/</url>
    <content><![CDATA[<h2 id="二分法的概念"><a href="#二分法的概念" class="headerlink" title="二分法的概念"></a>二分法的概念</h2><p>二分法(Bisection method)，即一分为二的的方法。对于在区间$[a,b]$上连续不断且满足$f(a)*f(b)&lt;0$的函数$y=f(x)$,通过不断地把函数$f(x)$的零点所在区间二等分，使区间两个端点逐步逼近零点，进而得到零点的近似值的方法。<br>简单来说就是<br>一般用于求解一个具有单调性的函数的分界点。</p>
<p>二分实际上也是一种枚举，只不过是使用的数学方法大大减少了无意义的枚举次数,时间复杂度也优化成$O(logn)$。</p>
<p>我们一般所说的二分是二分查找法，本文就用二分简说。</p>
<p>简单来说二分搜索法可以用来查找满足某种条件的最大（最小）的值。</p>
<h3 id="单调性"><a href="#单调性" class="headerlink" title="单调性"></a>单调性</h3><p>在二分前，我们需要研究问题的单调性。<br>比如我们要求在正整数定义域内函数满足：<br>$$f(x) = x^2 ≥ k$$<br>的一个最小的x，其中k一般是一个定值。<br>我们很容易发现$x^2$的函数在正整数定义域内是单调递增的。</p>
<p>当然二分不止用在这么简单的场景，其他场景需要你自行分析。</p>
<h3 id="二段性"><a href="#二段性" class="headerlink" title="二段性"></a>二段性</h3><p>集合中的元素有存在分界线，给定条件可以将集合中元素分为两部分，一部分满足条件，一部分不满足条件。<br>例如当我们要查找一个数组中小于$14$的最大的一个数：</p>
<p>$$1 ,3 ,8 ,13 ,15 ,20 ,23$$</p>
<p>这时可以发现从13和15中间就有一条分界线，左边是满足我们的条件的，右边是不满足的。</p>
<p>于是就可以通过这个将整个区间分为两个区间。具体分为哪段到哪段就看你的写法。<br>所以我们就可以确定二分的方式，以及代码编写的选择，当然，如果是实数二分就不存在这样的区别。</p>
<h3 id="枚举区间"><a href="#枚举区间" class="headerlink" title="枚举区间"></a>枚举区间</h3><p>当我们使用二分的时候，还需要考虑的一点是，枚举的一个区间$[l,r]$。<br>这个区间一定是包含我们的最终答案的。</p>
<h3 id="判断函数"><a href="#判断函数" class="headerlink" title="判断函数"></a>判断函数</h3><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>{<span class="hljs-comment">/* ... */</span>} <span class="hljs-comment">// 检查x是否满足某种性质</span><br></code></pre></td></tr></tbody></table></figure>
<p>就刚刚的例子而言，我们的判断函数$check()$即为$mid^2 ≥ k$ (mid即为二分时的中间点)<br>判断函数的编写也是二分的重中之重，稍微一步写错就有可能造成找不到答案或者死循环的情况。</p>
<h3 id="确定答案"><a href="#确定答案" class="headerlink" title="确定答案"></a>确定答案</h3><p>和题意结合，输出对应的答案，这一步尤其要注意，要理解清楚题目的意思，比如第一个大于等于的，最后一个小于的，最后一个小于等于的等等等等。需要自己多加小心（通常这些字眼就暗示了这一道题需要用二分来优化）</p>
<h3 id="分区间"><a href="#分区间" class="headerlink" title="分区间"></a>分区间</h3><p>对应上文的分界线前后的元素，是属于整数二分的内容。</p>
<figure class="highlight excel"><table><tbody><tr><td class="code"><pre><code class="hljs excel">// 区间[l, r]被划分成[l, <span class="hljs-built_in">mid</span>]和[<span class="hljs-built_in">mid</span> + <span class="hljs-number">1</span>, r]时使用：<br><span class="hljs-built_in">int</span> binsearch(<span class="hljs-built_in">int</span> l, <span class="hljs-built_in">int</span> r)<br>{<br>    while (l &lt; r)<br>    {<br>        <span class="hljs-built_in">int</span> <span class="hljs-built_in">mid</span> = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">if</span> (check(<span class="hljs-built_in">mid</span>)) r = <span class="hljs-built_in">mid</span>;    // check()判断<span class="hljs-built_in">mid</span>是否满足性质<br>        else l = <span class="hljs-built_in">mid</span> + <span class="hljs-number">1</span>;<br>    }<br>    return l;<br>}<br></code></pre></td></tr></tbody></table></figure>

<figure class="highlight excel"><table><tbody><tr><td class="code"><pre><code class="hljs excel">// 区间[l, r]被划分成[l, <span class="hljs-built_in">mid</span> - <span class="hljs-number">1</span>]和[<span class="hljs-built_in">mid</span>, r]时使用：<br><span class="hljs-built_in">int</span> binsearch(<span class="hljs-built_in">int</span> l, <span class="hljs-built_in">int</span> r)<br>{<br>    while (l &lt; r)<br>    {<br>        <span class="hljs-built_in">int</span> <span class="hljs-built_in">mid</span> = l + r + <span class="hljs-number">1</span> &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">if</span> (check(<span class="hljs-built_in">mid</span>)) l = <span class="hljs-built_in">mid</span>;<br>        else r = <span class="hljs-built_in">mid</span> - <span class="hljs-number">1</span>;<br>    }<br>    return l;<br>}<br></code></pre></td></tr></tbody></table></figure>

<h3 id="实数二分"><a href="#实数二分" class="headerlink" title="实数二分"></a>实数二分</h3><p>实数二分就不用考虑整数二分的困扰，直接二分即可，要考虑精度，可以用浮点数比较法，还有一种方法是限制二分次数。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span> </span>{<span class="hljs-comment">/* ... */</span>} <span class="hljs-comment">// 检查x是否满足某种性质</span><br><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">binsearch</span><span class="hljs-params">(<span class="hljs-type">double</span> l, <span class="hljs-type">double</span> r)</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-type">const</span> <span class="hljs-type">double</span> eps = <span class="hljs-number">1e-6</span>;   <span class="hljs-comment">// eps 表示精度，取决于题目对精度的要求</span><br>    <span class="hljs-keyword">while</span> (r - l &gt; eps)<br>    {<br>        <span class="hljs-type">double</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid)) r = mid;<br>        <span class="hljs-keyword">else</span> l = mid;<br>    }<br>    <span class="hljs-keyword">return</span> l;<br>}<br></code></pre></td></tr></tbody></table></figure>
<h2 id="库函数"><a href="#库函数" class="headerlink" title="库函数"></a>库函数</h2><p>除了手写二分，还有一些库函数可以直接使用。</p>
<ul>
<li>lower_bound(x)：返回大于等于 x 的第一个迭代器；</li>
<li>upper_bound(x)：返回大于 x 的第一个迭代器；</li>
<li>binary_search(x)：在容器中二分查找 x 是否存在。</li>
</ul>
<p>lower_bound( begin,end,num)：从数组的begin位置到end-1位置二分查找第一个大于或等于num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。</p>
<p>upper_bound( begin,end,num)：从数组的begin位置到end-1位置二分查找第一个大于num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。</p>
<p>在从大到小的排序数组中，重载lower_bound()和upper_bound()</p>
<p>lower_bound( begin,end,num,greater<type>() ):从数组的begin位置到end-1位置二分查找第一个小于或等于num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。</type></p>
<p>upper_bound( begin,end,num,greater<type>() ):从数组的begin位置到end-1位置二分查找第一个小于num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。</type></p>
<p>binary_search (begin，end，num,sort_rule);<br>意思是，begin和end-1 的查找区间内，查找“等于”num的元素，返回值为1 (true 找到) 或0 (false 没找到)。</p>
<h2 id="三分法"><a href="#三分法" class="headerlink" title="三分法"></a>三分法</h2><p>三分的一大运用便是求解函数的极值点，虽然很高大上但是实际写起来并不复杂，基本与二分一致。</p>
<h3 id="整数凸函数"><a href="#整数凸函数" class="headerlink" title="整数凸函数"></a>整数凸函数</h3><figure class="highlight powershell"><table><tbody><tr><td class="code"><pre><code class="hljs powershell">ll l, <span class="hljs-built_in">r</span>;<br><span class="hljs-keyword">while</span>(l &lt; <span class="hljs-built_in">r</span>) {<br>    ll lmid = l + (<span class="hljs-built_in">r</span> - l) / <span class="hljs-number">3</span>;<br>    ll rmid = <span class="hljs-built_in">r</span> - (<span class="hljs-built_in">r</span> - l) / <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">if</span>(calc(lmid) &lt;= calc(rmid))	l = lmid + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">r</span> = rmid - <span class="hljs-number">1</span>;<br>}<br>printf(<span class="hljs-string">"%lld\n"</span>, max(calc(l), calc(<span class="hljs-built_in">r</span>)));<br></code></pre></td></tr></tbody></table></figure>

<h3 id="整数凹函数"><a href="#整数凹函数" class="headerlink" title="整数凹函数"></a>整数凹函数</h3><figure class="highlight powershell"><table><tbody><tr><td class="code"><pre><code class="hljs powershell">ll l, <span class="hljs-built_in">r</span>;<br><span class="hljs-keyword">while</span>(l &lt; <span class="hljs-built_in">r</span>) {<br>    ll lmid = l + (<span class="hljs-built_in">r</span> - l) / <span class="hljs-number">3</span>;<br>    ll rmid = <span class="hljs-built_in">r</span> - (<span class="hljs-built_in">r</span> - l) / <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">if</span>(calc(rmid) &gt;= calc(lmid))	<span class="hljs-built_in">r</span> = mid - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span> 	l = mid + <span class="hljs-number">1</span>;<br>}<br>printf(<span class="hljs-string">"%lld\n"</span>, min(calc(l), calc(<span class="hljs-built_in">r</span>)));<br></code></pre></td></tr></tbody></table></figure>

<h3 id="实数"><a href="#实数" class="headerlink" title="实数"></a>实数</h3><p>这里采用的是限制循环次数法。</p>
<h4 id="凸"><a href="#凸" class="headerlink" title="凸"></a>凸</h4><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">double</span> l, r;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">300</span>; i++) {<br>    <span class="hljs-type">double</span> lmid = l + (r - l) / <span class="hljs-number">3</span>;<br>    <span class="hljs-type">double</span> rmid = r - (r - l) / <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">calc</span>(lmid) &lt;= <span class="hljs-built_in">calc</span>(rmid))	l = lmid;<br>    <span class="hljs-keyword">else</span> 	r = rmid;<br>}<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"%.6f\n"</span>, <span class="hljs-built_in">calc</span>(l));<br></code></pre></td></tr></tbody></table></figure>

<h4 id="凹"><a href="#凹" class="headerlink" title="凹"></a>凹</h4><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">double</span> l, r;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">300</span>; i++) {<br>    <span class="hljs-type">double</span> lmid = l + (r - l) / <span class="hljs-number">3</span>;<br>    <span class="hljs-type">double</span> rmid = r - (r - l) / <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">calc</span>(rmid) &gt;= <span class="hljs-built_in">calc</span>(lmid))	r = rmid;<br>    <span class="hljs-keyword">else</span> 	l = lmid;<br>}<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"%.6f\n"</span>, <span class="hljs-built_in">calc</span>(l));<br></code></pre></td></tr></tbody></table></figure>



<h2 id="题目练习"><a href="#题目练习" class="headerlink" title="题目练习"></a>题目练习</h2><p><a href="https://www.luogu.com.cn/problem/P1873">P1873 [COCI 2011/2012 #5] EKO / 砍树 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
<p><a href="https://www.luogu.com.cn/problem/P2678">P2678 [NOIP2015 提高组] 跳石头 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
<p><a href="https://www.luogu.com.cn/problem/P3382">P3382 三分 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>树形DP</title>
    <url>/posts/9ba26914/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>树形DP，顾名思义是在树上的DP,应用于树形结构的动态规划。</p>
<p>其核心思想是在树的节点间传递和合并状态信息，逐步计算出所需的最优解。</p>
<p>因为树的递归性质，树形动态规划一般都是递归求解的。</p>
<h2 id="经典题目"><a href="#经典题目" class="headerlink" title="经典题目"></a>经典题目</h2><p><a href="https://www.luogu.com.cn/problem/P1352">P1352 没有上司的舞会 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
<p>以这个题目为例，我们定义 $f[i][0/1]$ 来表示以 $i$ 为根的子树的最优解，$f[i][0]$ 代表不选 $i$ 节点，$f[i][1]$ 代表选 $i$ 节点。<br>所以我们根据 $i$ 节点参不参加分为两种情况:</p>
<ul>
<li>$i$ 节点不参加，那么 $i$ 节点的子节点可以参加也可以不参加,所以有 $f[i][0] = \sum{}^{}max(f[j][1],f[j][0])$ </li>
<li>$i$ 节点参加，那么 $i$ 节点的子节点不能参加，所以有 $f[i][1] = \sum{}^{}f[j][0] + w_i$<br>所以我们可以通过$dfs$ 从最底层向上$dp$</li>
</ul>
<blockquote>
<p>本文参考<a href="https://oi-wiki.org/dp/tree/">树形 DP - OI Wiki (oi-wiki.org)</a></p>
</blockquote>
]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>DP</tag>
        <tag>树形DP</tag>
      </tags>
  </entry>
  <entry>
    <title>前缀和与差分</title>
    <url>/posts/37060/</url>
    <content><![CDATA[<h2 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h2><p>前缀和是指某序列的前n项和，可以把它理解为数学上的数列的前n项和。</p>
<p>假定$a_1,a_2,a_3,a_4…..a_n$为我们的原数组。给定m个$l,r$，要求求出$l$到$r$的区间和。</p>
<p>直接枚举一遍$l,r$进行求解的时间复杂度是$O(n*m)$，对于时间复杂度较严格的题，这样的做法是不可取的。</p>
<p>现在，假定有一个数组$p_1,p_2,p_3…p_n$，其中：</p>
<ul>
<li>$p_1 = a_1$</li>
<li>$p_2 = a_1 + a_2$</li>
<li>$p_3 = a_1 + a_2 + a_3$</li>
<li>$p_4 = a_1 + a_2 + a_3 + a_4$</li>
<li>…</li>
<li>$p_n = a_1 + a_2 + … + a_{n-1} + a_n$</li>
</ul>
<p>我们可以通过这个数组轻松得到$l$到$r$的区间和：<br>$$\text{sum}(l,r) = p[r] - p[l - 1]$$</p>
<p>通过这个公式，我们可以快速算出一段区间的和，时间复杂度是$O(1)$。</p>
<p>$p$数组的构建过程称之为<strong>预处理</strong>，需要的时间是$a$数组的长度$n$。因此，预处理的时间复杂度为$O(n)$。加上m次查询，总复杂度变为$O(n+m)$，大大提高了运行效率。</p>
<h2 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h2><p>差分是一种用于处理序列变化的技术，特别适用于需要频繁对区间进行修改的场景。</p>
<p>考虑一个序列 $a_1, a_2, a_3, \ldots, a_n$。我们引入差分数组 $d_1, d_2, d_3, \ldots, d_n$，其中 $d_i = a_i - a_{i-1}$。</p>
<ul>
<li>$d_1 = a_1$</li>
<li>$d_2 = a_2 - a_1$</li>
<li>$d_3 = a_3 - a_2$</li>
<li>…</li>
<li>$d_n = a_n - a_{n-1}$</li>
</ul>
<p>接下来，通过对差分数组进行前缀和操作，得到原始数组 $a$。差分数组的前缀和恰好是原始数组：</p>
<ul>
<li>$a_1 = d_1$ </li>
<li>$a_2 = d_1 + d_2$ </li>
<li>$a_3 = d_1 + d_2 + d_3$</li>
</ul>
<p>通过差分数组，可以快速进行区间修改和查询。对于区间 $[l, r]$ 的增量操作（假设增量值为 $c$），我们可以将差分数组进行如下修改：<br>$$<br>\begin{aligned}<br>d_l += c ,\<br>d_{r+1} -= c \<br>\end{aligned}<br>$$</p>
<p>因为差分做前缀和是原数组，所以我们对$d_i$进行操作的话，在原数组当中，其实就是对$a_i$到$a_n$进行了一次操作。</p>
<p>要想实现区间操作$[l,r] + c$就在$l$的位置加上$c$,之后在$r + 1$的位置减去c，这样差分数组在做前缀和操作之后，即把原数组的$[l,r]$进行了一个$+c$的操作。</p>
<p>通过差分数组 $d$，可以高效进行区间的增减操作。差分数组的构建和操作过程是一种预处理，其时间复杂度为 $O(n)$。随后对 $m$ 个查询操作的时间复杂度为 $O(m)$。总体而言，差分技巧能够在降低时间复杂度的同时，高效地处理区间操作。</p>
<p>值得注意的是，前缀和和差分这两种操作都是离线操作，也就是说不能边修改原数组的值，边进行前缀和和差分。</p>
<h2 id="二维前缀和"><a href="#二维前缀和" class="headerlink" title="二维前缀和"></a>二维前缀和</h2><h3 id="构建思路"><a href="#构建思路" class="headerlink" title="构建思路"></a>构建思路</h3><p>假设有一个二维数组 $a_{i,j}$，表示矩阵中的元素。我们想要在矩阵中快速计算某个子区域的和。为了实现这一目标，我们引入了二维前缀和数组 $p_{i,j}$。</p>
<h3 id="公式推导"><a href="#公式推导" class="headerlink" title="公式推导"></a>公式推导</h3><p>构建过程的关键在于理解 $p_{i,j}$ 如何由原始数组 $a_{i,j}$ 推导而来。我们使用以下公式：</p>
<p>$$<br>p_{i,j} = a_{i,j} + p_{i-1,j} + p_{i,j-1} - p_{i-1,j-1}<br>$$</p>
<p>这个公式直观地描述了 $p_{i,j}$ 是由当前元素 $a_{i,j}$ 加上其上方、左方的前缀和，再减去左上角的前缀和得到的。</p>
<h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><p>通过构建二维前缀和数组，我们可以在 $O(1)$ 的时间内计算任意矩阵子区域的和。这种预处理大大提高了区域和的计算效率。</p>
<h2 id="二维差分"><a href="#二维差分" class="headerlink" title="二维差分"></a>二维差分</h2><h3 id="构建思路-1"><a href="#构建思路-1" class="headerlink" title="构建思路"></a>构建思路</h3><p>二维差分用于处理对二维数组中区域进行频繁修改的情况。我们引入了二维差分数组 $d_{i,j}$。</p>
<h3 id="公式推导-1"><a href="#公式推导-1" class="headerlink" title="公式推导"></a>公式推导</h3><p>构建过程的关键在于理解 $d_{i,j}$ 如何由原始数组 $a_{i,j}$ 推导而来。我们使用以下公式：</p>
<p>$$<br>d_{i,j} = a_{i,j} - a_{i-1,j} - a_{i,j-1} + a_{i-1,j-1}<br>$$</p>
<p>这个公式描述了 $d_{i,j}$ 是当前元素 $a_{i,j}$ 与其上方、左方以及左上角元素之间的变化量。</p>
<h3 id="区域增减操作"><a href="#区域增减操作" class="headerlink" title="区域增减操作"></a>区域增减操作</h3><p>通过修改二维差分数组，我们可以在 $O(1)$ 的时间内进行矩阵子区域的增减操作。对于矩阵子区域 $[x_1, y_1, x_2, y_2]$ 的增量操作（假设增量值为 $c$），我们可以将二维差分数组进行如下修改：</p>
<p>$$<br>\begin{aligned}<br>d_{x_1, y_1} += c ,\<br>d_{x_2+1, y_1} -= c ,\<br>d_{x_1, y_2+1} -= c ,\<br>d_{x_2+1, y_2+1} += c ,\<br>\end{aligned}<br>$$</p>
<h3 id="差分数组的还原"><a href="#差分数组的还原" class="headerlink" title="差分数组的还原"></a>差分数组的还原</h3><p>通过对二维差分数组进行前缀和操作，得到原始数组 $a$。差分数组的前缀和即为原始数组：</p>
<p>$$<br>\begin{aligned}<br>a_{i,j} &amp;= d_{i,j} + a_{i-1,j} + a_{i,j-1} - a_{i-1,j-1}<br>\end{aligned}<br>$$</p>
<p>通过结合二维前缀和和二维差分，我们可以高效地处理二维矩阵区域的计算和修改。</p>
<h5 id="tips"><a href="#tips" class="headerlink" title="tips:"></a>tips:</h5><p>当然还有三维，不过一般一维就够了，二维的题也不多,除了上面这些方法，还可以使用树状数组和线段树来求前缀和和差分。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>前缀和</tag>
        <tag>差分</tag>
      </tags>
  </entry>
  <entry>
    <title>LCA最近公共祖先</title>
    <url>/posts/7cc481cf/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>LCA（Lowest Common Ancestor，最近公共祖先）是树结构中常用的一个问题，指的是树中两个节点的最低共同祖先节点。<strong>LCA树链抛分法</strong>和<strong>倍增法</strong>，我们这里讲述倍增法，倍增法是一种高效解决LCA问题的算法之一，通过预处理和动态规划的方式，可以在较快的时间内回答多次LCA查询。</p>
<h2 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h2><ol>
<li><p><strong>预处理：</strong> 算法首先对树进行预处理，计算每个节点的深度和其与2的幂次方祖先的关系。</p>
</li>
<li><p><strong>构建倍增表：</strong> 通过构建一个称为倍增表的数据结构，记录每个节点跳跃2^k步后的祖先节点。这样，我们就能够在O(log N)的时间内找到一个节点的第k个祖先。</p>
</li>
<li><p><strong>查询：</strong> 对于给定的两个节点u和v，首先确定它们的深度，然后将深度较大的节点跳跃到与深度较小的节点相同深度。接着，同时向上跳跃两个节点，直到找到它们的最近公共祖先。在跳跃的过程中，通过倍增表的信息加速查询。</p>
</li>
</ol>
<h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>LCA倍增法的时间复杂度是O(N log N)的预处理时间加上O(log N)的查询时间，其中N是树中节点的数量。这种方法在多次查询LCA的情况下非常高效，因为预处理的成本被分摊到了多个查询中。</p>
<p>这个算法在解决树上的LCA问题时，提供了一种有效的方法，尤其适用于需要频繁查询LCA的情况，例如在树上进行大量的图论算法或树算法时。</p>
<h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><h3 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h3><p>对于预处理，我们的递推公式为$$f[i][j] = f[f[i][j-1]][j-1]$$ $f[i][j]$代表从i开始，走$2^j$步到达的点。所以我们要想求出来，可以把$2^j$分为两个$2^{j-1}$的部分。</p>
<p>代入进树：<br>$$f[x][i] = f[f[x][i-1]][i-1]$$<br>从节点x往上跳$2^i$的点。</p>
<h3 id="查询结果"><a href="#查询结果" class="headerlink" title="查询结果"></a>查询结果</h3><p>对于lca,普遍情况我们查询到的结果并不是他们的最近公共祖先，而是最近公祖先的下一层，为什么不能直接查询到lca的公共祖先，因为在倍增当中，我们可能会出现查询到了公共祖先，但是不是最近的，所以我们转换思路，我们如果查询到同一个点，就代表不成立，缩短重新进行查询，这样就可以避免我们查询到非最近的公共祖先。</p>
<h2 id="封装模板"><a href="#封装模板" class="headerlink" title="封装模板"></a>封装模板</h2><p>基础封装，无权图,注意点只能是$1 - n$ ，如果不是则需要离散化。 </p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">LCA</span> {<br>&nbsp; &nbsp; <span class="hljs-type">int</span> n;<br>&nbsp; &nbsp; vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; h,f;<span class="hljs-comment">//存图，从i开始向上走2^j步到的点</span><br>&nbsp; &nbsp; vector&lt;<span class="hljs-type">int</span>&gt; dep,lg;<br>&nbsp; &nbsp; <span class="hljs-built_in">LCA</span>(<span class="hljs-type">int</span> n) {<br>&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">this</span>-&gt;n = n;<br>&nbsp; &nbsp; &nbsp; &nbsp; h.<span class="hljs-built_in">resize</span>(n + <span class="hljs-number">1</span>);<br>&nbsp; &nbsp; &nbsp; &nbsp; f.<span class="hljs-built_in">resize</span>(n + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">30</span>));<br>&nbsp; &nbsp; &nbsp; &nbsp; dep.<span class="hljs-built_in">resize</span>(n + <span class="hljs-number">1</span>);<br>&nbsp; &nbsp; &nbsp; &nbsp; lg.<span class="hljs-built_in">resize</span>(n + <span class="hljs-number">1</span>);<br>&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lg[i] = lg[i<span class="hljs-number">-1</span>] + (<span class="hljs-number">1</span> &lt;&lt; lg[i<span class="hljs-number">-1</span>] == i);<br>&nbsp; &nbsp; }<br>&nbsp; &nbsp; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>{ <span class="hljs-comment">// 建立双向边</span><br>&nbsp; &nbsp; &nbsp; &nbsp; h[x].<span class="hljs-built_in">push_back</span>(y);<br>&nbsp; &nbsp; &nbsp; &nbsp; h[y].<span class="hljs-built_in">push_back</span>(x);<br>&nbsp; &nbsp; }<br>&nbsp; &nbsp; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> fa)</span> </span>{<br>&nbsp; &nbsp; &nbsp; &nbsp; f[x][<span class="hljs-number">0</span>] = fa; <span class="hljs-comment">// 储存 x 的父节点</span><br>&nbsp; &nbsp; &nbsp; &nbsp; dep[x] = dep[fa] + <span class="hljs-number">1</span>;<br>&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= lg[dep[x]]; i++) {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; f[x][i] = f[f[x][i - <span class="hljs-number">1</span>]][i - <span class="hljs-number">1</span>];<br>&nbsp; &nbsp; &nbsp; &nbsp; }<br>&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : h[x]) {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">if</span> (y == fa) <span class="hljs-keyword">continue</span>;<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-built_in">dfs</span>(y, x);<br>&nbsp; &nbsp; &nbsp; &nbsp; }<br>&nbsp; &nbsp; }<br>&nbsp; &nbsp; <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lca</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>{<br>&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">if</span> (dep[x] &lt; dep[y]) <span class="hljs-built_in">swap</span>(x, y);<span class="hljs-comment">//保证x更深</span><br>&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">while</span> (dep[x] &gt; dep[y]) {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; x = f[x][lg[dep[x] - dep[y]] - <span class="hljs-number">1</span>];<br>&nbsp; &nbsp; &nbsp; &nbsp; }<br>&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">if</span> (x == y) <span class="hljs-keyword">return</span> x;<br>&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = lg[dep[x]] - <span class="hljs-number">1</span>; k &gt;= <span class="hljs-number">0</span>; k--) {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">if</span> (f[x][k] == f[y][k]) <span class="hljs-keyword">continue</span>;<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; x = f[x][k];<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; y = f[y][k];<br>&nbsp; &nbsp; &nbsp; &nbsp; }<br>&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">return</span> f[x][<span class="hljs-number">0</span>];<br>&nbsp; &nbsp; }<br>&nbsp; &nbsp; <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">clac</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>{ <span class="hljs-comment">// 倍增查询两点间距离</span><br>&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">return</span> dep[x] + dep[y] - <span class="hljs-number">2</span> * dep[<span class="hljs-built_in">lca</span>(x, y)];<br>&nbsp; &nbsp; }<br>&nbsp; &nbsp; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">(<span class="hljs-type">int</span> root = <span class="hljs-number">1</span>)</span> </span>{ <span class="hljs-comment">// 在此初始化</span><br>&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-built_in">dfs</span>(root, <span class="hljs-number">0</span>);<br>&nbsp; &nbsp; }<br>};<br></code></pre></td></tr></tbody></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>lca</tag>
        <tag>图论</tag>
        <tag>倍增</tag>
      </tags>
  </entry>
  <entry>
    <title>Dijkstra算法</title>
    <url>/posts/c4fedc02/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>Dijkstra算法是一种解决单源最短路径问题的贪心算法。</p>
<h2 id="朴素版Dijkstra算法"><a href="#朴素版Dijkstra算法" class="headerlink" title="朴素版Dijkstra算法"></a>朴素版Dijkstra算法</h2><p><strong>思想：</strong><br>朴素版Dijkstra算法是一种贪心算法，通过维护每个节点的当前最短距离来逐步确定从起始节点到其他节点的最短路径。在每一步中，选择当前未被标记的节点中距离最短的节点进行标记，并更新其邻居节点的距离值。</p>
<p><strong>概念：</strong></p>
<ol>
<li><em>距离值（distance）：</em> 表示从起始节点到某个节点的当前已知最短路径长度。</li>
<li><em>标记集合（visited）：</em> 用于标记已确定最短路径的节点。</li>
</ol>
<p><strong>过程：</strong></p>
<ol>
<li><em>初始化：</em> 将起始节点的距离值设为0，其他节点的距离值设为无穷大（表示尚未确定最短路径），标记集合为空。</li>
<li><em>选择最短路径节点：</em> 从未被标记的节点中选择距离值最小的节点，标记为已访问。</li>
<li><em>更新邻居节点：</em> 对于已访问节点的每个相邻节点，计算通过当前节点到达该相邻节点的路径长度，并更新相邻节点的距离值。</li>
<li><em>重复步骤2和3：</em> 重复选择最短路径节点和更新邻居节点的步骤，直到所有节点都被标记为已访问。</li>
<li><em>最终结果：</em> 每个节点的距离值即为从起始节点到达该节点的最短路径长度。</li>
</ol>
<p><strong>注意：</strong> 朴素版Dijkstra算法的时间复杂度相对较高，特别是在稠密图中，因为在每一步中都需要线性搜索未被标记的节点。为了提高效率，引入优先队列的版本能够更快地选择最短路径节点。</p>
<p><img src="https://pic.imgdb.cn/item/65aa70ec871b83018a209dca.png" alt="img"></p>
<h3 id="代码部分"><a href="#代码部分" class="headerlink" title="代码部分"></a>代码部分</h3><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">3010</span>;<br><span class="hljs-type">int</span> n,m,g[N][N];<span class="hljs-comment">//邻接矩阵</span><br><span class="hljs-type">int</span> d[N],st[N];<span class="hljs-comment">//距离数组，标记数组</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dji</span><span class="hljs-params">(<span class="hljs-type">int</span> s = <span class="hljs-number">1</span>)</span></span>{<br>	<span class="hljs-built_in">memset</span>(d,<span class="hljs-number">0x3f</span>,<span class="hljs-keyword">sizeof</span> d); d[s] = <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>	{<br>		<span class="hljs-type">int</span> x = <span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;++j)<br>		{<br>			<span class="hljs-keyword">if</span>(st[j]) <span class="hljs-keyword">continue</span>;<br>			<span class="hljs-keyword">if</span>(x == <span class="hljs-number">0</span>|| d[j] &lt; d[x]) x = j;<br>		}<br>		st[x] = <span class="hljs-number">1</span>;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;++j) d[j] = <span class="hljs-built_in">min</span>(d[j],d[x] + g[x][j]);<br>	}<br>}<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>	cin &gt;&gt; n &gt;&gt; m;<br>	<span class="hljs-built_in">memset</span>(g,<span class="hljs-number">0x3f</span>,<span class="hljs-keyword">sizeof</span> g);<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i)<br>	{<br>		<span class="hljs-type">int</span> x,y,w;cin &gt;&gt; x &gt;&gt; y &gt;&gt; w;<br>		g[x][y] = <span class="hljs-built_in">min</span>(g[x][y],w);<span class="hljs-comment">//考虑重边</span><br>		g[y][x] = <span class="hljs-built_in">min</span>(g[y][x],w);<span class="hljs-comment">//无向图</span><br>	}<br>	<span class="hljs-built_in">dji</span>();<br>	<span class="hljs-keyword">if</span>(d[n] == INF) cout &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; endl;<br>	<span class="hljs-keyword">else</span> cout &lt;&lt; d[n] &lt;&lt; endl;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>

<h2 id="Dijkstra算法堆优化"><a href="#Dijkstra算法堆优化" class="headerlink" title="Dijkstra算法堆优化"></a><strong>Dijkstra算法堆优化</strong></h2><p><strong>思想：</strong><br>Dijkstra算法的一种优化方式是引入堆（优先队列）数据结构，以提高在每一步中选择最短路径节点的效率。这种堆优化的Dijkstra算法能够更快地确定最短路径，特别在大规模图中表现更为出色。</p>
<p><strong>概念：</strong></p>
<ol>
<li><em>距离值（distance）：</em> 表示从起始节点到某个节点的当前已知最短路径长度。</li>
<li><em>标记集合（visited）：</em> 用于标记已确定最短路径的节点。</li>
<li><em>优先队列（priority queue）：</em> 存储待处理节点，并按距离值大小排序，以便每次选择最短路径节点。</li>
</ol>
<p><strong>过程：</strong></p>
<ol>
<li><em>初始化：</em> 将起始节点的距离值设为0，其他节点的距离值设为无穷大（表示尚未确定最短路径），将所有节点加入优先队列。</li>
<li><em>选择最短路径节点：</em> 从优先队列中选择距离值最小的节点，标记为已访问。</li>
<li><em>更新邻居节点：</em> 对于已访问节点的每个相邻节点，计算通过当前节点到达该相邻节点的路径长度，并更新相邻节点的距离值。</li>
<li><em>重复步骤2和3：</em> 重复选择最短路径节点和更新邻居节点的步骤，直到所有节点都被标记为已访问。</li>
<li><em>最终结果：</em> 每个节点的距离值即为从起始节点到达该节点的最短路径长度。</li>
</ol>
<p><strong>注意:</strong> Dijkstra算法在正权重图（权重不能为负）上表现良好，但不适用于存在负权重边的图。如果图中存在负权重边，可以考虑使用Bellman-Ford算法。</p>
<h3 id="代码部分-1"><a href="#代码部分-1" class="headerlink" title="代码部分"></a>代码部分</h3><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dis</span><span class="hljs-params">(n + <span class="hljs-number">1</span>,<span class="hljs-number">0x3f3f3f3f</span>)</span></span>;<br><span class="hljs-keyword">auto</span> dijkstra = [&amp;](<span class="hljs-type">int</span> s = <span class="hljs-number">1</span>) -&gt;<span class="hljs-type">void</span><br>{<br>	<span class="hljs-type">int</span> y,w;<br>	<span class="hljs-keyword">using</span> PII = pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;;<br>	priority_queue&lt;PII,vector&lt;PII&gt;,greater&lt;PII&gt; &gt; q;<br>	q.<span class="hljs-built_in">emplace</span>(<span class="hljs-number">0</span>,s);<br>	dis[s] = <span class="hljs-number">0</span>;<br>	<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">st</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>	<span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>())<br>	{<br>		<span class="hljs-type">int</span> x = q.<span class="hljs-built_in">top</span>().second;<br>		q.<span class="hljs-built_in">pop</span>();<br>		<span class="hljs-keyword">if</span>(st[x]) <span class="hljs-keyword">continue</span>;<br>		st[x] = <span class="hljs-number">1</span>;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> el : h[x])<br>		{<br>			<span class="hljs-built_in">tie</span>(y,w) = el;<br>			<span class="hljs-keyword">if</span>(dis[y] &gt; dis[x] + w)<br>			{<br>				dis[y] = dis[x] + w;<br>				q.<span class="hljs-built_in">emplace</span>(dis[y],y);<br>			}<br>		}<br>	}<br>};<br></code></pre></td></tr></tbody></table></figure>

<h2 id="正确性证明"><a href="#正确性证明" class="headerlink" title="正确性证明"></a>正确性证明</h2><p>为什么dijkstra算法这样的贪心策略是正确的？<a href="https://www.zhihu.com/question/57206374/answer/151995167">转载自</a></p>
<p>首先，Dijkstra算法成立的前提条件是不存在负权的边。这意味着任何一条路径，从起点开始到路径中每个点的距离都是依次递增的。</p>
<p>所以，按照递增的顺序来依次计算出最短路径，也就是Dijkstra算法了。</p>
<p>为了简单起见，我们可以认为所有的边权都是正值。如果有边的权值为0，则这个边的两个顶点到源点的最短距离一定相等，可以把它们看成是同一个顶点，这样只要证明了边权值为正值的情况，也就能进一步推广到有边权值为0的情况。</p>
<p>当我们计算最短路径的时候，源点到任意一个点的最短距离，要么是源点到它的某条边的长度，要么是源点到另一个点的最短距离距离，再加上另一个点到这个点的边的长度，写成公式就是：</p>
<p>$$<br>d(i) = \min{D(s, i), \min_{j \ne i} d(j) + D(j, i)}<br>$$</p>
<p>注意到我们有 $(D(j, i) &gt; 0)$，假如我们已经提前知道了各个 $d(i)$ 的大小顺序，那么比该顶点的最短路径距离更长的点就不用考虑了，改写成：</p>
<p>$$<br>d(i) = \min{D(s, i), \min_{d(j) &lt; d(i)} d(j) + D(j, i)}<br>$$</p>
<p>假想我们已经提前将 $d(i)$ 排好了序，除了源点以外，最近的是 $n_0$，然后是 $n_1$，然后是 $n_2$，也就是:</p>
<p>$$<br>d(n_0) \leq d(n_1) \leq d(n_2) \leq … \leq d(n_m)<br>$$</p>
<p>那么我们的公式即可变成:</p>
<p>$$<br>d(n_k) = \min{D(s, n_k), \min_{j &lt; k} d(n_j) + D(n_j, n_k)}<br>$$</p>
<p>假如说我们现在已经知道了最短距离最小的前 $k$ 个节点 ${n_0, n_1, …, n_{k−1}}$——特别的，$k = 0$ 的时候，这些节点的集合是个空集。当然它们的最短距离也根据上面的式子算了出来。我们希望接下来，通过这些信息找到 $n_k$，并且计算出 $d(n_k)$。</p>
<p>我们回到最早的式子中：</p>
<p>$$<br>d(i) = \min{D(s, i), \min_{j \ne i} d(j) + D(j,i)}<br>$$</p>
<p>如果在求最小值的第二项中，去掉一些项，那么得到的结果有可能会比原表达式大，但不可能比原表达式小（因为是求最小值的运算）。也就是对于 $i \notin {n_0, n_1, …, n_{k-1}}$，有：</p>
<p>$$<br>d(i) \le \min{D(s, i), \min_{j \in {n_0, n_1, …, n_{k-1}}} d(j) + D(j,i)}<br>$$</p>
<p>同时有：</p>
<p>$$<br>d(n_k) = \min{D(s, n_k), \min_{j \in {n_0, n_1, …, n_{k-1}}} d(j) + D(j,n_k)}<br>$$</p>
<p>也就是说，对于最后的 $n_k$ 来说，前面的式子会取等号。我们又知道 $n_k$ 是剩下节点中最短距离最小的。</p>
<p>也就是 :</p>
<p>$$<br>n_k = \arg \min_i d(i) = \arg \min_i \min{D(s, i), \min_{j \in {n_0, n_1, …, n_{k-1}}} d(j) + D(j,i)}<br>$$</p>
<p>第二个等号是因为我们将求最值表达式中不是最小的项替换成了比较大的项，而最小的项保持不变，因此最小值不变。这个最后的表达式就是Dijkstra算法。</p>
<p>在实际使用的时候，注意到这个式子可以改写成：</p>
<p>$$<br>\min{D(s,i), \min_{j \in {n_0, n_1, …, n_{k-1}}} d(j) + D(j,i)}<br>= \min{d(n_{k-1}) + D(n_{k-1},i), \min{D(s,i), \min_{j \in {n_0, n_1, …, n_{k-2}}} d(j) + D(j,i)}}<br>$$</p>
<p>第二项在上一轮就已经算出来了，所以每一轮只需要用最新加入的节点放缩一次就可以了。</p>
<p>直观来说，如果我们已经求出了k个离源点距离最近的点，以及它们各自的距离，那么到源点距离第k+1近的点，它到源点的最短路径只能经过这前k个点——如果经过了其他点，那么这个其他点显然离源点更近，那这个点一定不是第k+1近了。既然只经过这前k个点，那么只用这前k个点放缩就可以找到那个最短路径了。再加上前k-1个点上一轮已经放缩过，所以每一轮只需要用新加入的节点进行放缩就行了。</p>
]]></content>
      <categories>
        <category>算法</category>
        <category>图论</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>图论基础</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title>Kruskal算法</title>
    <url>/posts/8708cb74/</url>
    <content><![CDATA[<h2 id="Kruskal-算法"><a href="#Kruskal-算法" class="headerlink" title="Kruskal 算法"></a>Kruskal 算法</h2><p>Kruskal 算法是一种用于求解最小生成树的贪心算法。它的基本思想是通过选择边来逐步构建最小生成树，确保每一步都选择权值最小的边，同时避免形成环。</p>
<h2 id="算法引入"><a href="#算法引入" class="headerlink" title="算法引入"></a>算法引入</h2><p>假设你是一位城市道路规划者，下面是你的城市以及蓝图。<br><img src="https://pic.imgdb.cn/item/65aa70bd871b83018a1fb9c4.png" alt="img"><br>现在要求你建设其中的一些道路（每一条道路的建设需要金币），使每个城市之间都能互相到达，并且所花费的金币最少。<br>而你是算法高手，一下就想到了树这个数据结构，树是特殊的图，有向无环图，只要生成一颗树，就能满足其中任意两个城市可以互相到达的条件，现在要处理的就是划分金币最少。于是便有了最小生成树。</p>
<h2 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h2><ol>
<li><strong>初始化</strong>：将图中的所有边按照权值从小到大进行排序。<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>     <span class="hljs-comment">// 存储边</span><br>{<br>    <span class="hljs-type">int</span> a, b, w;<br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt; (<span class="hljs-type">const</span> Edge &amp;W)<span class="hljs-type">const</span><br>    {<br>        <span class="hljs-keyword">return</span> w &lt; W.w;<br>    }<br>}edges[M];<br><br><span class="hljs-built_in">sort</span>(edges, edges + m);<br></code></pre></td></tr></tbody></table></figure></li>
<li><strong>创建并查集</strong>：为每个顶点创建一个单元素集合，用于判断是否形成环。<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) p[i] = i;    <span class="hljs-comment">// 初始化并查集</span><br></code></pre></td></tr></tbody></table></figure></li>
<li><strong>遍历边集合</strong>：按照排好序的边的顺序，依次检查每条边。<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i ++ )<br>{<br>    <span class="hljs-type">int</span> a = edges[i].a, b = edges[i].b, w = edges[i].w;<span class="hljs-comment">//取出边的数据</span><br><br>    <span class="hljs-comment">//合并操作</span><br>}<br></code></pre></td></tr></tbody></table></figure></li>
<li><strong>判断边的两个顶点是否在同一集合</strong>：如果不在同一集合，说明加入这条边不会形成环，则选择加入，并合并这两个顶点的集合。<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><code class="hljs c++">a = <span class="hljs-built_in">find</span>(a), b = <span class="hljs-built_in">find</span>(b);<br><span class="hljs-keyword">if</span> (a != b)     <span class="hljs-comment">// 如果两个连通块不连通，则将这两个连通块合并</span><br>{<br>    p[a] = b;<br>    res += w;<br>    cnt ++ ;<br>}<br></code></pre></td></tr></tbody></table></figure></li>
<li><strong>重复步骤 4</strong> 直到最小生成树的边数达到 <code>n-1</code>（其中 <code>n</code> 为图中顶点的个数）。<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> n, m;       <span class="hljs-comment">// n是点数，m是边数</span><br><span class="hljs-type">int</span> p[N];       <span class="hljs-comment">// 并查集的父节点数组</span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>     <span class="hljs-comment">// 存储边</span><br>{<br>    <span class="hljs-type">int</span> a, b, w;<br><br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt; (<span class="hljs-type">const</span> Edge &amp;W)<span class="hljs-type">const</span><br>    {<br>        <span class="hljs-keyword">return</span> w &lt; W.w;<br>    }<br>}edges[M];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span>     <span class="hljs-comment">// 并查集核心操作</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-keyword">if</span> (p[x] != x) p[x] = <span class="hljs-built_in">find</span>(p[x]);<br>    <span class="hljs-keyword">return</span> p[x];<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">kruskal</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-built_in">sort</span>(edges, edges + m);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) p[i] = i;    <span class="hljs-comment">// 初始化并查集</span><br><br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>, cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i ++ )<br>    {<br>        <span class="hljs-type">int</span> a = edges[i].a, b = edges[i].b, w = edges[i].w;<br><br>        a = <span class="hljs-built_in">find</span>(a), b = <span class="hljs-built_in">find</span>(b);<br>        <span class="hljs-keyword">if</span> (a != b)     <span class="hljs-comment">// 如果两个连通块不连通，则将这两个连通块合并</span><br>        {<br>            p[a] = b;<br>            res += w;<br>            cnt ++ ;<br>        }<br>    }<br><br>    <span class="hljs-keyword">if</span> (cnt &lt; n - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> INF;<br>    <span class="hljs-keyword">return</span> res;<br>}<br></code></pre></td></tr></tbody></table></figure>
根据步骤得出，我们可以把上图的最小生成树的过程画出来。</li>
</ol>
<p><img src="https://pic.imgdb.cn/item/65aa70d2871b83018a202027.png" alt="img"></p>
<h2 id="封装模板"><a href="#封装模板" class="headerlink" title="封装模板"></a>封装模板</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">DSU</span><br>{<br>	std::vector&lt;<span class="hljs-type">int</span>&gt; p, siz;<br>	<span class="hljs-built_in">DSU</span>() {}<br>	<span class="hljs-built_in">DSU</span>(<span class="hljs-type">int</span> n) { <span class="hljs-built_in">init</span>(n); }<br>	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function">	</span>{<br>		p.<span class="hljs-built_in">resize</span>(n);<br>		std::<span class="hljs-built_in">iota</span>(p.<span class="hljs-built_in">begin</span>(), p.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>);<br>		siz.<span class="hljs-built_in">assign</span>(n, <span class="hljs-number">1</span>);<br>	}<br>	<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function">	</span>{<br>		<span class="hljs-keyword">while</span> (x != p[x])<br>		{<br>			x = p[x] = p[p[x]];<br>		}<br>		<span class="hljs-keyword">return</span> x;<br>	}<br>	<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">same</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>{ <span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(x) == <span class="hljs-built_in">find</span>(y); }<br>	<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function">	</span>{<br>		<span class="hljs-type">int</span> px = <span class="hljs-built_in">find</span>(x);<br>		<span class="hljs-type">int</span> py = <span class="hljs-built_in">find</span>(y);<br>		<span class="hljs-keyword">if</span> (px == py)<br>		{<br>			<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>		}<br>		siz[px] += siz[py];<br>		p[py] = px;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>	}<br>	<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">size</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>{ <span class="hljs-keyword">return</span> siz[<span class="hljs-built_in">find</span>(x)]; }<br>};<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MST</span><br>{<br>	<span class="hljs-keyword">using</span> TII = tuple&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;;<br>	<span class="hljs-type">int</span> n;<br>	priority_queue&lt;TII,vector&lt;TII&gt;,greater&lt;TII&gt;&gt; eg;<br>	<span class="hljs-built_in">MST</span>(<span class="hljs-type">int</span> n) : <span class="hljs-built_in">n</span>(n){}<br>	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> w)</span></span><br><span class="hljs-function">	</span>{<br>		eg.<span class="hljs-built_in">emplace</span>(w,x,y);<br>	}<br>	<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">kruskal</span><span class="hljs-params">()</span></span><br><span class="hljs-function">	</span>{<br>		<span class="hljs-function">DSU <span class="hljs-title">dsu</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>		<span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>,cnt = <span class="hljs-number">0</span>,w,x,y;<br>		<span class="hljs-keyword">while</span>(eg.<span class="hljs-built_in">size</span>())<br>		{<br>			<span class="hljs-built_in">tie</span>(w,x,y) = eg.<span class="hljs-built_in">top</span>();<br>			eg.<span class="hljs-built_in">pop</span>();<br>			<span class="hljs-keyword">if</span>(dsu.<span class="hljs-built_in">same</span>(x,y)) <span class="hljs-keyword">continue</span>;<br>			dsu.<span class="hljs-built_in">merge</span>(x,y);<br>			ans += w;<br>			cnt ++ ;<br>		}<br>		<span class="hljs-keyword">if</span>(cnt &lt; n - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> INF;<br>		<span class="hljs-keyword">return</span> ans;<br>	}<br>};<br></code></pre></td></tr></tbody></table></figure>




<h2 id="题目练习"><a href="#题目练习" class="headerlink" title="题目练习"></a>题目练习</h2><p><a href="https://www.luogu.com.cn/problem/P3366">P3366 【模板】最小生成树 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>图论</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>最小生成树</tag>
        <tag>kruskal</tag>
      </tags>
  </entry>
  <entry>
    <title>图论基础</title>
    <url>/posts/eadfe50d/</url>
    <content><![CDATA[<h2 id="图的概念"><a href="#图的概念" class="headerlink" title="图的概念"></a>图的概念</h2><p>图论是离散数学的一个分支，致力于研究图（Graph）这一数学结构。图是用来模拟对象之间成对关系的工具，由节点或顶点（Vertex）以及连接这些顶点的边（Edge）组成。</p>
<p>下面这张图片就是一个图$G(V,E)$<br><img src="/img/%E5%9B%BE%E8%AE%BA%E5%9F%BA%E7%A1%80/2.png" alt="img"><br>图可以被表示为 $G=(V, E)，其中 V=(v_1, … , v_N)，E= (e_1, … , e_M)$。</p>
<p>其中$V$代表<strong>点集</strong>，$E$为<strong>边集</strong>。<br>需要注意的是，图的顶点集合不能为空，但边的集合可以为空。<br>我们常用$n$来代表顶点的数量,$m$代表边的数量。</p>
<h2 id="图的分类"><a href="#图的分类" class="headerlink" title="图的分类"></a>图的分类</h2><h3 id="按点边数量分"><a href="#按点边数量分" class="headerlink" title="按点边数量分"></a>按点边数量分</h3><p>根据点和边的数量来分可以分为:</p>
<ul>
<li>稀疏图</li>
<li>稠密图</li>
<li>零图<br>一般$m &lt; nlogn$我们就认为这个图是稀疏图，否则是稠密图。简单来说就是 边少点多 即为稀疏图，反之则为稠密图。零图就是这张图的边集为空，即只有顶点的图。</li>
</ul>
<h3 id="边的分类"><a href="#边的分类" class="headerlink" title="边的分类"></a>边的分类</h3><p>边分为:</p>
<ul>
<li>无向边</li>
<li>有向边<br>顾名思义，有向边就是带有方向的边，无向边就是不带有方向的边。</li>
</ul>
<p>无向边相当于两条在相同的两个节点之间，方向不同的边。也就是a -&gt; b &amp; b -&gt; a。</p>
<h3 id="按边有无向分"><a href="#按边有无向分" class="headerlink" title="按边有无向分"></a>按边有无向分</h3><p>首先边有向的就是 有向图，无向即为无向图。</p>
<ul>
<li>有向图</li>
<li>无向图<br><img src="https://pic.imgdb.cn/item/65aa6f45871b83018a18cca2.png" alt="img"><br><img src="https://pic.imgdb.cn/item/65aa6f71871b83018a199c49.png" alt="img"></li>
</ul>
<p>其中如果无向图任意一对顶点之间都有边连接，也就是有$<br>\frac{n \cdot (n - 1)}{2}<br>$<br>条不重复的边,称为<strong>完全图</strong>,类似的，有向图任意一对顶点$[u,v]$之间都有两条有向边$(u,v),(v,u)$连接,称为<strong>有向完全图</strong>。</p>
<h2 id="度"><a href="#度" class="headerlink" title="度"></a>度</h2><h3 id="无向图的度"><a href="#无向图的度" class="headerlink" title="无向图的度"></a>无向图的度</h3><p>在无向图中,顶点的度是指某个顶点连出的边数。<br>例如下图，顶点4的度数为3,顶点1的度数为2。<br>在代码中度数一般用数组$d[i]$表示，表示顶点$i$的度数。<br><img src="https://pic.imgdb.cn/item/65aa6f71871b83018a199c49.png" alt="img"></p>
<h3 id="有向图的度"><a href="#有向图的度" class="headerlink" title="有向图的度"></a>有向图的度</h3><p>在有向图中，度分为两种:</p>
<ul>
<li>入度</li>
<li>出度<br>入度是指以该顶点为终点的有向边的数量,<br>出度是指以该顶点为起点的有向边的数量。<br>例如下图,顶点$4$的出度数量为$1$,入度为$2$。<br><img src="https://pic.imgdb.cn/item/65aa6f45871b83018a18cca2.png" alt="img"></li>
</ul>
<h3 id="度的性质"><a href="#度的性质" class="headerlink" title="度的性质"></a>度的性质</h3><p>在有向图和无向图中，顶点的度数为边数的两倍。<br>在有向图中，入度数=出度数</p>
<h2 id="图的存储"><a href="#图的存储" class="headerlink" title="图的存储"></a>图的存储</h2><h3 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h3><p>邻接矩阵是一种图的存储结构，它通过使用一维数组来表示每个顶点，并将边的信息存储在二维数组中，以矩阵的形式展现图中各顶点之间的邻接关系。简而言之，邻接矩阵以一种紧凑而清晰的方式描述了图的结构，其中每个顶点通过矩阵中的行和列相互关联。<br>对于有$n$个顶点的图 $G=(V,E)$ 来说，我们可以用一个 $n×n$ 的$01$矩阵 $g$ 来表示 $G$ 中各顶点的相邻关系。而$g_{ij} = 1$的时候代表$v_i$有一条连向$v_j$的边,0则没有。</p>
<p><img src="https://pic.imgdb.cn/item/65aa6f87871b83018a1a051c.png" alt="img"><br>这张无向图对应的01矩阵为:</p>
<figure class="highlight yaml"><table><tbody><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-number">0101</span><br><span class="hljs-number">1011</span><br><span class="hljs-number">0101</span><br><span class="hljs-number">1110</span><br></code></pre></td></tr></tbody></table></figure>
<p><img src="https://pic.imgdb.cn/item/65aa6fb0871b83018a1ac811.png" alt="img"></p>
<p>这张有向图对应的01矩阵为:</p>
<figure class="highlight yaml"><table><tbody><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-number">0101</span><br><span class="hljs-number">0001</span><br><span class="hljs-number">0100</span><br><span class="hljs-number">0010</span><br></code></pre></td></tr></tbody></table></figure>

<p>仔细对比下即可领略。邻接矩阵在代码的体现就是一个二维数组$g[i][j]$。</p>
<h3 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h3><p>邻接表的思想是，对于图中的每一个顶点，用一个数组来记录这个点和哪些点相连。由于相邻的点会动态的添加，所以对于每个点，我们需要用vector(或者其他方式，例如前向星等)来记录，本文采用vector方式。<br>对于上面那张有向图，书写成邻接表的形式即为：</p>
<ul>
<li>h </li>
<li>1 2 4   </li>
<li>2 4</li>
<li>3 2</li>
<li>4 3<br>$h$即为顶点，后面跟着的是对应顶点通过有向边能到达的点。这个结构也是二维的，不过没有记录过多的信息，所以我们可以用变长数组vector来实现,<code>vector&lt;T&gt; h[N];</code>要想让1到2有一条边，直接<code>h[1].push_back(2)</code>即可。</li>
</ul>
<h3 id="使用技巧"><a href="#使用技巧" class="headerlink" title="使用技巧"></a>使用技巧</h3><p>一般在点数在5000以内，我们选择使用邻接矩阵，否则使用邻接表。</p>
]]></content>
      <categories>
        <category>算法</category>
        <category>图论</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>图论基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Floyd算法</title>
    <url>/posts/d7becff4/</url>
    <content><![CDATA[<h2 id="Floyd-Warshall概念"><a href="#Floyd-Warshall概念" class="headerlink" title="Floyd-Warshall概念"></a>Floyd-Warshall概念</h2><p>Floyd-Warshall算法是一种经典的图算法，用于求解图中所有顶点对之间的最短路径（多源最短路）。该算法适用于有向图或无向图，可以处理带有负权边（但不能存在负权回路）的图。Floyd-Warshall算法的主要思想是动态规划，通过逐步更新所有顶点对之间的最短路径信息来求解问题。</p>
<h2 id="算法步骤："><a href="#算法步骤：" class="headerlink" title="算法步骤："></a>算法步骤：</h2><p>初始化：将图的邻接矩阵表示的路径权值矩阵初始化为图中的边权值。如果不存在边，则权值设为无穷大（表示不可达），对角线元素初始化为0。</p>
<p>动态规划：对于每一对顶点（i，j），以每个顶点k为中间节点，尝试更新从i到j的最短路径。如果通过中间节点k的路径比直接路径更短，则更新路径。</p>
<p>迭代更新：重复上述动态规划步骤，对每一对顶点都进行动态规划，直到所有顶点对之间的最短路径都得到了更新。</p>
<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>Floyd算法是一个暴力并且美丽的算法，算法一共三重循环，分别枚举三个点。</p>
<ul>
<li>断点</li>
<li>出发点</li>
<li>终点</li>
</ul>
<p>状态表示 <code>d[k,i,j]</code> 所有从i出发，最终走到j，且中间只经过节点编号不超过k的所有路径<br>分成两部分:</p>
<ul>
<li>d[k-1][i][j] 所有不含k的路径</li>
<li>d[k-1][i][k] + d[k-1][k][j] 所有包含k的路径<br>观察发现，我们可以优化掉第一维</li>
</ul>
<p>状态转移方程也非常好记:<br>$$<br>    d[i][j] = min(d[i][j],d[i][k] + d[k][j])<br>$$</p>
<h2 id="正确性证明"><a href="#正确性证明" class="headerlink" title="正确性证明"></a>正确性证明</h2><p><a href="https://zhuanlan.zhihu.com/p/613716744">来自大佬的证明</a></p>
<h2 id="算法模板"><a href="#算法模板" class="headerlink" title="算法模板"></a>算法模板</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//初始化：</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++ )<br>            <span class="hljs-keyword">if</span> (i == j) d[i][j] = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">else</span> d[i][j] = INF;<br><br><span class="hljs-comment">// 算法结束后，d[a][b]表示a到b的最短距离</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">floyd</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= n; k ++ )<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++ )<br>                d[i][j] = <span class="hljs-built_in">min</span>(d[i][j], d[i][k] + d[k][j]);<br>}<br></code></pre></td></tr></tbody></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>图论</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>图论基础</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title>拓扑排序</title>
    <url>/posts/fb40efc5/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>拓扑排序是图论中的一种重要算法，用于对有向无环图（DAG）进行排序。在拓扑排序中，图中的节点被排序，使得如果图中存在一条从节点 A 到节点 B 的有向路径，那么在排序结果中，节点 A 出现在节点 B 之前。</p>
<p>拓扑排序常用于解决一些实际问题，例如任务调度、依赖关系分析等。在项目管理中，如果任务之间存在先后顺序的依赖关系，那么可以利用拓扑排序确定任务的执行顺序，以保证任务能够按照依赖关系的要求顺利完成。</p>
<h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>拓扑排序算法的基本思想是通过不断移除入度为零的节点，并更新相应节点的入度信息，直至所有节点都被排序完成。</p>
<ol>
<li>初始化：首先，对图中的每个节点计算其入度（即指向该节点的边的数量），并将入度为零的节点加入一个待处理队列中。</li>
<li>迭代处理：从待处理队列中选择一个入度为零的节点，将其加入排序结果中，并将该节点从图中移除（即删除与其相连的所有边）。同时，更新与被移除节点相连的节点的入度信息。</li>
<li>重复步骤 2，直至待处理队列为空。</li>
</ol>
<p>如果最终排序结果中包含了图中的所有节点，则拓扑排序成功；否则，说明图中存在环路，无法进行拓扑排序。</p>
<p>拓扑排序算法的时间复杂度取决于图的大小和边的数量，通常为 $O(V+E)$，其中 V 是节点的数量，E 是边的数量。</p>
<h2 id="算法模板"><a href="#算法模板" class="headerlink" title="算法模板"></a>算法模板</h2><p>纯净版</p>

    <div class="fold">
      <div class="fold-title fold-default collapsed" data-toggle="collapse" href="#collapse-8f7bdefe" role="button" aria-expanded="false" aria-controls="collapse-8f7bdefe">
        <div class="fold-arrow">▶</div>代码
      </div>
      <div class="fold-collapse collapse" id="collapse-8f7bdefe">
        <div class="fold-content">
          <figure class="highlight c++"><table><tbody><tr><td class="code"><pre><code class="hljs c++">vector&lt;<span class="hljs-type">int</span>&gt; h[N];<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">d</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>vector&lt;<span class="hljs-type">int</span>&gt; ans;<br><span class="hljs-keyword">auto</span> topsort = [&amp;]() -&gt; <span class="hljs-type">void</span><br>{<br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>&nbsp; &nbsp; <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)<br>&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">if</span> (!d[i])<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; q.<span class="hljs-built_in">push</span>(i);<br>&nbsp; &nbsp; <span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">size</span>())<br>&nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">auto</span> t = q.<span class="hljs-built_in">front</span>();<br>&nbsp; &nbsp; &nbsp; &nbsp; q.<span class="hljs-built_in">pop</span>();<br>&nbsp; &nbsp; &nbsp; &nbsp; ans.<span class="hljs-built_in">push_back</span>(t);<br>&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> el : h[t])<br>&nbsp; &nbsp; &nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">if</span>( -- d[el] == <span class="hljs-number">0</span>)<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; q.<span class="hljs-built_in">push</span>(el);<br>&nbsp; &nbsp; &nbsp; &nbsp; }<br>&nbsp; &nbsp; }<br>};<br></code></pre></td></tr></tbody></table></figure>
        </div>
      </div>
    </div>

<p>带注释版</p>

    <div class="fold">
      <div class="fold-title fold-default collapsed" data-toggle="collapse" href="#collapse-dcdac752" role="button" aria-expanded="false" aria-controls="collapse-dcdac752">
        <div class="fold-arrow">▶</div>代码
      </div>
      <div class="fold-collapse collapse" id="collapse-dcdac752">
        <div class="fold-content">
          <figure class="highlight c++"><table><tbody><tr><td class="code"><pre><code class="hljs c++">vector&lt;<span class="hljs-type">int</span>&gt; h[N];<span class="hljs-comment">//vector存图</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">d</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<span class="hljs-comment">//入度数量</span><br>vector&lt;<span class="hljs-type">int</span>&gt; ans;<span class="hljs-comment">//答案数组</span><br><span class="hljs-keyword">auto</span> topsort = [&amp;]() -&gt; <span class="hljs-type">void</span><br>{<br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<span class="hljs-comment">//队列</span><br>&nbsp; &nbsp; <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)<span class="hljs-comment">//把所有入度为0的点加进来</span><br>&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">if</span> (!d[i])<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; q.<span class="hljs-built_in">push</span>(i);<br>&nbsp; &nbsp; <span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">size</span>())<br>&nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">auto</span> t = q.<span class="hljs-built_in">front</span>();<br>&nbsp; &nbsp; &nbsp; &nbsp; q.<span class="hljs-built_in">pop</span>();<br>&nbsp; &nbsp; &nbsp; &nbsp; ans.<span class="hljs-built_in">push_back</span>(t);<br>&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> el : h[t])<br>&nbsp; &nbsp; &nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">if</span>( -- d[el] == <span class="hljs-number">0</span>)<span class="hljs-comment">//更新度数并且判断是否入度为0，为0即可push进队列</span><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; q.<span class="hljs-built_in">push</span>(el);<br>&nbsp; &nbsp; &nbsp; &nbsp; }<br>&nbsp; &nbsp; }<br>};<br></code></pre></td></tr></tbody></table></figure>
        </div>
      </div>
    </div>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>拓扑</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>GCD与LCM</title>
    <url>/posts/41f16002/</url>
    <content><![CDATA[<h2 id="最大公约数（GCD）"><a href="#最大公约数（GCD）" class="headerlink" title="最大公约数（GCD）"></a>最大公约数（GCD）</h2><p>最大公约数，也称为最大公因数或最大公因子，是两个或多个整数共有的最大正整数。通常用符号 $\text{gcd}(a, b)$ 表示，其中 $a$ 和 $b$ 是整数。最大公约数有广泛的应用，例如简化分数、判断两个数的互质性等。</p>
<h2 id="整除的定义："><a href="#整除的定义：" class="headerlink" title="整除的定义："></a>整除的定义：</h2><p>$a$ 能整除 $b$，记为 $a|b$。其中，$a$ 和 $b$ 为整数，且 $a \neq 0$，$b$ 是 $a$ 的倍数，$a$ 是 $b$ 的约数（因子）。</p>
<ol>
<li>若 $a, b, c$ 都是整数，且 $a|b, b|c$ 则 $a|c$。</li>
<li>若 $a, b, m, n$ 为整数，且 $c|a, c|b$，则 $c|(m \cdot a + n \cdot b)$。</li>
<li><strong>定理：带余除法。</strong> 若 $a$ 和 $b$ 都为整数且 $b &gt; 0$，且存在唯一的整数 $q, r$，使得 $a = b \cdot q + r$，其中 $0 \leq r &lt; b$。</li>
</ol>
<h2 id="GCD"><a href="#GCD" class="headerlink" title="GCD"></a>GCD</h2><h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h3><p>整数 $a$ 和 $b$ 的最大公约数是指能同时整除 $a$ 和 $b$ 的最大整数，记为 $\text{gcd}(a, b)$。<br>注意：由于 $-a$ 的因子和 $a$ 的因子相同，因此 $\text{gcd}(a, b) = \text{gcd}(|a|, |b|)$，代码中只关注正整数的情况。</p>
<h3 id="2-性质"><a href="#2-性质" class="headerlink" title="2. 性质"></a>2. 性质</h3><ul>
<li>$\text{gcd}(a, b) = \text{gcd}(a, a + b) = \text{gcd}(a, k \cdot a + b)$</li>
<li>$\text{gcd}(ka, kb) = k \cdot \text{gcd}(a, b)$</li>
<li>多个整数的最大公约数：$\text{gcd}(a, b, c) = \text{gcd}(\text{gcd}(a, b), c)$</li>
<li>若 $\text{gcd}(a, b) = d$ 则 $\text{gcd}\left(\frac{a}{d}, \frac{b}{d}\right) = 1$，即 $\frac{a}{d}$ 和 $\frac{b}{d}$ 互质</li>
<li>$\text{gcd}(a + cb, b) = \text{gcd}(a, b)$</li>
</ul>
<h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3. 代码"></a>3. 代码</h3><ul>
<li>可以使用 C++ 自带函数 <code>std::__gcd(a, b)</code>，注意参数必须为正整数，否则可能会返回负数。</li>
<li>可以使用欧几里得算法求解。</li>
<li>更相减损术。</li>
</ul>
<h3 id="欧几里得算法"><a href="#欧几里得算法" class="headerlink" title="欧几里得算法"></a>欧几里得算法</h3><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>{<br>	<span class="hljs-keyword">return</span> b ? <span class="hljs-built_in">gcd</span>(b,a % b) : a;<br>}<br></code></pre></td></tr></tbody></table></figure>
<p>比如要求$a = 7和b = 42$的最大公约数<br>计算 $a \div b$ 的商和余数，即 $q = \lfloor \frac{7}{42} \rfloor = 0$，$r = a \mod b = 7$。<br>由于余数 $r$ 不为零，将 $b$ 赋值给 $a$，将 $r$ 赋值给 $b$，即 $a = b$，$b = r$。<br>再次计算新的 $a \div b$ 的商和余数，即 $q = \lfloor \frac{42}{7} \rfloor = 6$，$r = a \mod b = 0$。<br>由于余数 $r$ 为零，辗转相除法结束。最终的最大公约数为当前的 $b$，即 $\text{gcd}(7, 42) = 7$。<br>通过辗转相除法，我们得到了数 7 和 42 的最大公约数为 7。<br>这个过程一直重复直到余数为零。每一步都将两个数的位置互换，然后进行除法运算，直到余数为零为止。</p>
<h2 id="LCM"><a href="#LCM" class="headerlink" title="LCM"></a>LCM</h2><p>$a和b的最小公倍数表示为lcm(a,b)$其中 $\text{lcm}(a, b) = \frac{a \cdot b}{\text{gcd}(a, b)}$。</p>
<h3 id="算术基本定理"><a href="#算术基本定理" class="headerlink" title="算术基本定理"></a><strong>算术基本定理</strong></h3><p>又称唯一分解定理。<br>任何大于 1 的正整数 $n$ 都可以唯一分解为有限个素数的乘积，即</p>
<p>$$n = p_1^{e_1} \cdot p_2^{e_2} \cdot \ldots \cdot p_k^{e_k}$$</p>
<p>其中 $p_1, p_2, \ldots, p_k$ 为素数，而 $e_1, e_2, \ldots, e_k$ 为对应素数的指数。这个分解是唯一的，即不存在其他方式将 $n$ 表示成素数的乘积。</p>
<h3 id="证明：-text-lcm-a-b-frac-a-cdot-b-text-gcd-a-b"><a href="#证明：-text-lcm-a-b-frac-a-cdot-b-text-gcd-a-b" class="headerlink" title="证明：$\text{lcm}(a, b) = \frac{a \cdot b}{\text{gcd}(a, b)}$"></a>证明：$\text{lcm}(a, b) = \frac{a \cdot b}{\text{gcd}(a, b)}$</h3><p>根据算术基本定理，我们可以将正整数 $a$ 和 $b$ 分别分解为其素因数的乘积：</p>
<p>$a = p_1^{e_1} \cdot p_2^{e_2} \cdot \ldots \cdot p_k^{e_k}$<br>$b = p_1^{f_1} \cdot p_2^{f_2} \cdot \ldots \cdot p_k^{f_k}$</p>
<p>其中 $p_1, p_2, \ldots, p_k$ 为素数，而 $e_1, e_2, \ldots, e_k$ 和 $f_1, f_2, \ldots, f_k$ 分别为 $a$ 和 $b$ 中对应素数的指数。</p>
<p>最小公倍数 $\text{lcm}(a, b)$ 是 $a$ 和 $b$ 的所有素因数的最大指数的乘积：</p>
<p>$$\text{lcm}(a, b) = p_1^{\max(e_1, f_1)} \cdot p_2^{\max(e_2, f_2)} \cdot \ldots \cdot p_k^{\max(e_k, f_k)}$$</p>
<p>最大公约数 $\text{gcd}(a, b)$ 是 $a$ 和 $b$ 的所有素因数的最小指数的乘积：</p>
<p>$$\text{gcd}(a, b) = p_1^{\min(e_1, f_1)} \cdot p_2^{\min(e_2, f_2)} \cdot \ldots \cdot p_k^{\min(e_k, f_k)}$$</p>
<p>现在，我们将 $\text{lcm}(a, b)$ 和 $\text{gcd}(a, b)$ 代入等式 $\text{lcm}(a, b) = \frac{a \cdot b}{\text{gcd}(a, b)}$ 进行验证：</p>
<p>$$\text{lcm}(a, b) = p_1^{\max(e_1, f_1)} \cdot p_2^{\max(e_2, f_2)} \cdot \ldots \cdot p_k^{\max(e_k, f_k)}$$</p>
<p>$$\frac{a \cdot b}{\text{gcd}(a, b)} = \frac{p_1^{e_1 + f_1} \cdot p_2^{e_2 + f_2} \cdot \ldots \cdot p_k^{e_k + f_k}}{p_1^{\min(e_1, f_1)} \cdot p_2^{\min(e_2, f_2)} \cdot \ldots \cdot p_k^{\min(e_k, f_k)}}$$</p>
<p>通过约简，我们可以看到它们是相等的。</p>
<p>这样，我们就证明了 $\text{lcm}(a, b) = \frac{a \cdot b}{\text{gcd}(a, b)}$。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>注意最好先除后乘，以防爆炸。</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lcm</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>{<br>	<span class="hljs-keyword">return</span> a / <span class="hljs-built_in">gcd</span>(a,b) *b;<br>}<br></code></pre></td></tr></tbody></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>数论</tag>
        <tag>gcd</tag>
        <tag>lcm</tag>
      </tags>
  </entry>
  <entry>
    <title>SPFA算法</title>
    <url>/posts/c856449e/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>SPFA算法是Bellman_ford算法的优化，所以我们先了解一下Bellman_ford算法。</p>
<h2 id="Bellman-ford算法"><a href="#Bellman-ford算法" class="headerlink" title="Bellman_ford算法"></a>Bellman_ford算法</h2><p>Bellman-Ford算法是一种用于求解单源最短路径问题的经典算法，其目标是找出从单个源点出发到图中所有其他顶点的最短路径。该算法适用于带有<strong>负权边</strong>的图。</p>
<h3 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h3><p>Bellman-Ford算法采用一种松弛（relaxation）的策略来逐步逼近最短路径。其基本思想可以概括为以下几个步骤：</p>
<p>初始化：将源点到所有其他顶点的距离设置为无穷大，源点自身的距离设置为0。</p>
<p>松弛操作：对图中的每一条边进行松弛操作，即尝试通过当前路径缩短已知的最短路径。如果通过该边可以获得更短的路径，则更新相应顶点的最短路径值。</p>
<p>迭代：重复进行松弛操作，一共进行V-1次（其中V为图中顶点的数量），以确保所有可能的最短路径都被考虑到。</p>
<p>检测负权回路：如果在V-1次迭代后还存在可以松弛的边，说明图中存在负权回路，因此无法得到准确的最短路径。算法将停止并报告负权回路的存在。不过我们一般不用bellman_ford算法求负环，而是用SPFA</p>
<blockquote>
<p>松弛操作: 用一条边尝试去更新最短路径就叫松弛操作</p>
</blockquote>
<p>注意:在每次迭代的时候，需要把当前dis数组备份一下，防止更新的时候出现串联。</p>

    <div class="fold">
      <div class="fold-title fold-default collapsed" data-toggle="collapse" href="#collapse-8f7bdefe" role="button" aria-expanded="false" aria-controls="collapse-8f7bdefe">
        <div class="fold-arrow">▶</div>代码
      </div>
      <div class="fold-collapse collapse" id="collapse-8f7bdefe">
        <div class="fold-content">
          <figure class="highlight c++"><table><tbody><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//求解从&nbsp;1 到&nbsp;n&nbsp;号节点的、最多经过&nbsp;k&nbsp;条边的最短距离。</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">510</span>,M = <span class="hljs-number">10010</span>;<br><span class="hljs-type">int</span> dis[N],backup[N];<br>vector&lt;tuple&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; &gt; eg;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bellman_ford</span><span class="hljs-params">(<span class="hljs-type">int</span> s = <span class="hljs-number">1</span>)</span></span><br><span class="hljs-function"></span>{<br>&nbsp; &nbsp; <span class="hljs-type">int</span> u,v,w;<br>&nbsp; &nbsp; <span class="hljs-built_in">memset</span>(dis,<span class="hljs-number">0x3f</span>,<span class="hljs-keyword">sizeof</span> dis);<br>&nbsp; &nbsp; dis[s] = <span class="hljs-number">0</span>;<br>&nbsp; &nbsp; <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;k;++i)<br>&nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-built_in">memcpy</span>(backup,dis,<span class="hljs-keyword">sizeof</span> dis);<br>&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;m; ++ j)<br>&nbsp; &nbsp; &nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-built_in">tie</span>(u,v,w) = eg[j];<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dis[v] = <span class="hljs-built_in">min</span>(dis[v],backup[u] + w);<br>&nbsp; &nbsp; &nbsp; &nbsp; }<br>&nbsp; &nbsp; }<br>}<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>&nbsp; &nbsp; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;<br>&nbsp; &nbsp; <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,a,b,w;i&lt;m;++i)<br>&nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; &nbsp; cin &gt;&gt; a &gt;&gt; b &gt;&gt; w;<br>&nbsp; &nbsp; &nbsp; &nbsp; eg.<span class="hljs-built_in">emplace_back</span>(a,b,w);<br>&nbsp; &nbsp; }<br>&nbsp; &nbsp; <span class="hljs-built_in">bellman_ford</span>();<br>&nbsp; &nbsp; <span class="hljs-keyword">if</span>(dis[n] &gt; INF / <span class="hljs-number">2</span>) <span class="hljs-built_in">puts</span>(<span class="hljs-string">"impossible"</span>);<span class="hljs-comment">//因为有边数的限制，所以没遍历到的情况大概率不是INF,而是小于INF</span><br>&nbsp; &nbsp; <span class="hljs-keyword">else</span> cout &lt;&lt; dis[n] &lt;&lt; endl;<br>&nbsp; &nbsp; <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>
        </div>
      </div>
    </div>

<h3 id="适用性"><a href="#适用性" class="headerlink" title="适用性"></a>适用性</h3><p>Bellman-Ford算法适用于一般的加权图，包括存在负权边的情况。但是，由于它的时间复杂度相对较高$O(nm)$，当处理没有负权边的图时，通常更倾向于使用Dijkstra算法。</p>
<h2 id="SPFA算法"><a href="#SPFA算法" class="headerlink" title="SPFA算法"></a>SPFA算法</h2><p>这个算法是一个很神奇的算法，时间复杂度是$O(km)$,k是一个常数，基本上是一个线性的算法，但是一些特殊的数据可以把SPFA算法的时间复杂度卡到$O(nm)$。尽管可以对SPFA再做一些优化，可惜这些优化也还是有对应的数据会给你卡掉。</p>
<p>SPFA（Shortest Path Faster Algorithm）算法是Bellman-Ford算法的一种优化版本，通过队列的方式避免了不必要的松弛操作，从而提高了算法的效率。SPFA算法在实际应用中相对于普通的Bellman-Ford算法具有更快的收敛速度。</p>
<p>每次松弛过程，我们保留那些dis值更新过的点，而在下一次松弛的时候，仅仅需要把这些点当起始节点进行松弛即可，所以剩下了很多不必要的松弛操作。</p>
<h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><p>初始化：将源点的最短路径估计值设置为0，其他顶点的最短路径估计值设置为无穷大。将源点入队。</p>
<p>队列操作：从队列中取出一个顶点，对该顶点的所有邻接边进行松弛操作。如果通过该边可以获得更短的路径，则更新相邻顶点的最短路径估计值。</p>
<p>入队条件：如果某个顶点的最短路径估计值发生改变，并且该顶点不在队列中，则将它入队。这是SPFA算法的关键之一，通过队列来避免不必要的重复松弛操作。</p>
<p>重复操作：重复进行队列操作，直到队列为空。</p>
<h3 id="判正负环"><a href="#判正负环" class="headerlink" title="判正负环"></a>判正负环</h3><p>SPFA判负环的思路是：当路径经过节点超过n(点数)时，图存在负环。</p>
<p>当我们一直绕着负环走时，由负环定义，该环边权和为负数，我们走的路径权值和是越来小的。所以当图存在负环时，最短路无解(-INF)。若一张图连通，那么它肯定是可以在经过&lt;=n个节点从一点到任意一点的。不存在负环时，一条路径最多经过n个节点，；存在负环时，spfa就会一直绕着负环走，经过的节点一定超过n，所以只用判断最短路经过节点点数即可。</p>
<p>所以拿一个cnt数组来维护即可。</p>
<h4 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h4><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dis</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">0x3f3f3f3f</span>)</span></span>;<br><span class="hljs-keyword">auto</span> spfa = [&amp;](<span class="hljs-type">int</span> s = <span class="hljs-number">1</span>) -&gt; <span class="hljs-type">bool</span> {<br>    <span class="hljs-type">int</span> y, w;<br>    <span class="hljs-keyword">using</span> PII = pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">st</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">cnt</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    q.<span class="hljs-built_in">emplace</span>(s);<span class="hljs-comment">//</span><br>    dis[s] = <span class="hljs-number">0</span>;<span class="hljs-comment">//</span><br>    st[s] = <span class="hljs-number">1</span>;<span class="hljs-comment">//</span><br>    <span class="hljs-comment">// for(int i=1;i&lt;=n;++i) q.emplace(i),st[i] = 1;//判断负环，一般要全部点加入</span><br>    <span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">size</span>()) {<br>        <span class="hljs-keyword">auto</span> x = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        st[x] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> el : h[x]) {<br>            <span class="hljs-comment">// tie(y,w) = el; // tie开销更大可能会超时</span><br>            y = el.first, w = el.second;<br>            <span class="hljs-keyword">if</span> (dis[y] &gt; dis[x] + w) {<br>                dis[y] = dis[x] + w;<br>                cnt[y] = cnt[x] + <span class="hljs-number">1</span>;<span class="hljs-comment">//判断负环</span><br>                <span class="hljs-keyword">if</span> (cnt[y] &gt;= n)<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">if</span> (!st[y])<br>                    q.<span class="hljs-built_in">emplace</span>(y), st[y] = <span class="hljs-number">1</span>;<br>            }<br>        }<br>    }<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>};<br><br></code></pre></td></tr></tbody></table></figure>

<p>那如何判正环呢，很简单，最短路换成最长路就行了。</p>
]]></content>
      <categories>
        <category>算法</category>
        <category>图论</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>图论基础</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title>拓展欧几里得</title>
    <url>/posts/68bc28a9/</url>
    <content><![CDATA[<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><h3 id="最大公约数"><a href="#最大公约数" class="headerlink" title="最大公约数"></a>最大公约数</h3><a href="/posts/41f16002/" title="GCD与LCM">GCD与LCM</a>
<h3 id="模运算"><a href="#模运算" class="headerlink" title="模运算"></a>模运算</h3><p>模运算的基本规则与四则运算基本一致：<br><img src="https://pic.imgdb.cn/item/664236120ea9cb1403670b1f.png" alt="img"><br>为什么没有除法，是因为除法在这里比较特别。</p>
<h3 id="同余"><a href="#同余" class="headerlink" title="同余"></a>同余</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>如果 $a$ 和 $b$ 除以 $c$ 的余数相同，就说 $a$ 和 $b$ 关于模 $c$ 同余，记作 $a \equiv b \pmod{c}$。 &gt; 如果 $a$ 和 $b$ 的差能够被 $m$ 整除，那么就说 $a$ 和 $b$ 关于 $m$ 同余。 </p>
<h4 id="同余关系是一种等价关系"><a href="#同余关系是一种等价关系" class="headerlink" title="同余关系是一种等价关系"></a>同余关系是一种等价关系</h4><ol>
<li>自反性：一个数永远和本身同余 </li>
<li>对称性：$a$ 和 $b$ 同余，$b$ 和 $a$ 也同余 </li>
<li>传递性：$a$ 和 $b$ 同余，$b$ 和 $c$ 也同余，即可推出 $a$ 和 $c$ 也同余</li>
</ol>
<h4 id="线性同余方程"><a href="#线性同余方程" class="headerlink" title="线性同余方程"></a>线性同余方程</h4><p>给定整数 $a$、$b$ 和 $m$，线性同余方程 $ax \equiv b \pmod{m}$ 的解是一个整数 $x$，使得 $ax$ 和 $b$ 对 $m$ 取模后的结果相同。 要解决线性同余方程，可以使用<strong>拓展欧几里得算法</strong>来找到解。如果 $\text{gcd}(a, m)$ 能够整除 $b$，那么方程 $ax \equiv b \pmod{m}$ 有解，否则无解。<br><strong>解法：</strong> </p>
<ol>
<li>使用拓展欧几里得算法找到整数 $x’$ 和 $y’$，使得 $ax’ + my’ = \text{gcd}(a, m)$。</li>
<li>如果 $\text{gcd}(a, m)$ 能够整除 $b$，那么方程 $ax \equiv b \pmod{m}$ 有解，且一组解为：$x = x’ \times \frac{b}{\text{gcd}(a, m)}$。</li>
</ol>
<h3 id="裴蜀定理"><a href="#裴蜀定理" class="headerlink" title="裴蜀定理"></a>裴蜀定理</h3><p>裴蜀定理（Bézout’s Lemma）是说，对于任意给定的两个整数 $a$ 和 $b$，存在整数 $x$ 和 $y$，使得它们满足以下等式： $$ ax + by = \text{gcd}(a, b) $$ 这个定理是拓展欧几里得算法的基础，通过这个定理，我们可以求解线性同余方程 $ax + by = c$ 的整数解。</p>
<p><strong>裴蜀定理证明：</strong></p>
<p><strong>基本情况：</strong> 当 $b=0$ 时，我们有 $\text{gcd}(a, 0) = a$。此时，等式 $ax + 0 = a$ 显然成立，其中 $x=1$。</p>
<p><strong>归纳假设：</strong> 假设对于某些整数 $k$，当 $b &lt; k$ 时，裴蜀定理成立，即存在整数 $x$ 和 $y$，使得 $ax + by = \text{gcd}(a, b)$。</p>
<p><strong>归纳步骤：</strong> 现在考虑 $b=k$ 的情况。我们使用带余除法，将 $a$ 除以 $k$ 得到余数 $r$。根据带余除法，我们有：</p>
<p>$$<br>a = qk + r<br>$$</p>
<p>其中，$q$ 是商，$r$ 是余数，$0 \leq r &lt; k$。</p>
<p>因为 $r = a - qk$，所以 $r$ 是 $a$ 和 $k$ 的线性组合。根据归纳假设，我们知道存在整数 $x’$ 和 $y’$，使得：</p>
<p>$$<br>kx’ + ry’ = \text{gcd}(k, r)<br>$$</p>
<p>将 $r$ 代入，我们有：</p>
<p>$$<br>kx’ + (a - qk)y’ = \text{gcd}(k, a)<br>$$</p>
<p>$$<br>ay’ + k(x’ - qy’) = \text{gcd}(k, a)<br>$$</p>
<p>这表明 $\text{gcd}(a, k) = \text{gcd}(k, r)$。</p>
<p>因此，通过归纳法，我们证明了对于任意的整数 $a$ 和 $b$，存在整数 $x$ 和 $y$，使得它们满足裴蜀定理。</p>
<p>这就完成了裴蜀定理的证明。</p>
<h3 id="费马小定理"><a href="#费马小定理" class="headerlink" title="费马小定理"></a>费马小定理</h3><p>费马小定理是数论中的一条重要定理，由法国数学家皮埃尔·德·费马在17世纪提出。它的表述如下：</p>
<p><strong>定理：</strong> 如果 $p$ 是一个素数，$a$ 是任意整数且不是 $p$ 的倍数，那么以下等式成立：</p>
<p>$$<br>a^{p-1} \equiv 1 \pmod{p}<br>$$</p>
<p>其中，$\equiv$ 表示模同余。</p>
<p>这个定理的一个直接推论是：如果 $p$ 是一个素数，$a$ 是任意整数，那么 $a^p \equiv a \pmod{p}$。</p>
<h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p>费马小定理在密码学、编程竞赛中的算法设计等领域有着重要应用。</p>
<ol>
<li><p><strong>模幂运算：</strong> 费马小定理提供了一种快速计算模幂的方法。在计算 $a^b \pmod{p}$ 时，可以先使用费马小定理将指数化简，然后再进行模幂运算，大大提高了计算效率。</p>
</li>
<li><p><strong>模反元素：</strong> 如果需要求解模方程 $ax \equiv 1 \pmod{p}$，即求解关于 $x$ 的同余方程的解，其中 $p$ 是素数，那么根据费马小定理，$x \equiv a^{p-2} \pmod{p}$ 就是方程的解。这提供了一种高效的方法来求解模反元素。</p>
</li>
<li><p><strong>素性检测：</strong> 费马小定理可以作为素性检测算法的一部分。在 Miller-Rabin 素性检测算法中，利用费马小定理判断一个数是否为素数。</p>
</li>
</ol>
<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>在应用费马小定理时，需要注意选择合适的素数 $p$，以及确保 $a$ 不是 $p$ 的倍数，否则定理可能不成立。</p>
<h3 id="推论"><a href="#推论" class="headerlink" title="推论"></a><strong>推论</strong></h3><p>费马小定理的一个重要推论是，对于任意整数 $a$、$b$ 和素数 $p$，如果 $\text{gcd}(a, p) = 1$，那么以下等式成立：</p>
<p>$$<br>a^{p-1} \equiv 1 \pmod{p}<br>$$</p>
<p>将 $a^{p-1}$ 写成 $a \times a^{p-2}$，并将等式两边同时乘以 $b^{p-2}$，得到：</p>
<p>$$<br>a^{p-1} \times b^{p-2} \equiv b^{p-2} \pmod{p}<br>$$</p>
<p>再将 $a^{p-1}$ 和 $b^{p-2}$ 替换成它们的原式，得到：</p>
<p>$$<br>ab^{p-1} \equiv b^{p-1} \pmod{p}<br>$$</p>
<p>由于 $b^{p-1} \equiv 1 \pmod{p}$（根据费马小定理），所以：</p>
<p>$$<br>ab^{p-1} \equiv b^{p-1} \equiv 1 \pmod{p}<br>$$</p>
<p>即，</p>
<p>$$<br>ab^{p-1} - 1 \equiv 0 \pmod{p}<br>$$</p>
<p>现在我们有一个形式为 $ax - 1 \equiv 0 \pmod{p}$ 的方程，其中 $x = b^{p-1}$。如果我们令 $y = p-1$，那么我们得到的方程就是 $ax - py = 1$，这与裴蜀定理的形式完全相同。因此，我们可以利用费马小定理来求解形如 $ax + by = \text{gcd}(a, b)$ 的线性同余方程。</p>
<h3 id="逆元"><a href="#逆元" class="headerlink" title="逆元"></a>逆元</h3><h4 id="什么是逆元"><a href="#什么是逆元" class="headerlink" title="什么是逆元"></a>什么是逆元</h4><p>在模运算中，对于整数 $a$ 和模数 $m$，如果存在整数 $a^{-1}$，使得 $a \times x \equiv 1 \pmod{m}$，那么 $x$ 就是 $a$ 在模 $m$ 意义下的逆元。逆元通常用符号 $a^{-1}$ 表示。</p>
<h4 id="快速幂算法"><a href="#快速幂算法" class="headerlink" title="快速幂算法"></a>快速幂算法</h4><a href="/posts/20c47d09/" title="快速幂">快速幂</a>

<p>快速幂算法是一种高效计算幂的方法，它可以在对数时间复杂度内计算出 $a^b \mod m$ 的值。在计算逆元时，我们可以利用费马小定理：</p>
<p>如果 $p$ 是一个素数，$a$ 是一个整数，且 $a$ 不是 $p$ 的倍数，那么<br>$a^{p-1} \equiv 1 \pmod{p}$<br>$a^{p-2} \equiv a^{-1} \pmod{p}$</p>
<p>所以，$a$ 的逆元 $a^{-1}$ 就是 $a^{p-2} \mod p$。</p>
<h4 id="拓展欧几里得算法"><a href="#拓展欧几里得算法" class="headerlink" title="拓展欧几里得算法"></a>拓展欧几里得算法</h4><p>拓展欧几里得算法用于解决形如 $ax + by = \text{gcd}(a, b)$ 的等式。当 $a$ 和 $b$ 互质时，这个算法可以用来计算 $a$ 的模 $b$ 的逆元。</p>
<p>假设我们要计算 $a^{-1} \pmod{m}$，其中 $\text{gcd}(a, m) = 1$，则可以通过拓展欧几里得算法找到一对整数 $x$ 和 $y$，使得：<br>$ax + my = 1$<br>对两边同时取模 $m$，我们得到：<br>$ax \equiv 1 \pmod{m}$</p>
<h2 id="拓展欧几里得算法-1"><a href="#拓展欧几里得算法-1" class="headerlink" title="拓展欧几里得算法"></a>拓展欧几里得算法</h2><p>拓展欧几里得算法是用于求解一元线性同余方程 <code>ax ≡ b (mod m)</code> 的一种有效方法。与普通的欧几里得算法相比，拓展欧几里得算法不仅可以找到方程 <code>ax + my = gcd(a,m)</code> 的整数解 <code>x</code> 和 <code>y</code>，还可以根据这个解得到同余方程 <code>ax ≡ b (mod m)</code> 的解。</p>
<p>拓展欧几里得算法的步骤如下：</p>
<ol>
<li>使用普通的欧几里得算法计算 <code>gcd(a, m)</code>。</li>
<li>在递归求解过程中，维护两个额外的变量 <code>x1</code> 和 <code>y1</code>，它们满足 <code>ax1 + my1 = gcd(a, m)</code>。</li>
<li>根据递归的基本情况 <code>ax1 + my1 = gcd(a, m)</code> 和 <code>mx2 + ny2 = gcd(m, n)</code>，使用迭代的方式计算 <code>x</code> 和 <code>y</code>，使得 <code>ax + my = gcd(a, m)</code>。</li>
<li>根据 <code>x1</code> 和 <code>y1</code> 计算出 <code>x</code> 的值，进而求解同余方程 <code>ax ≡ b (mod m)</code> 的解。</li>
</ol>
<p>拓展欧几里得算法的关键在于利用递归和迭代的方法，通过倒推的方式求解方程 <code>ax + my = gcd(a, m)</code>，并利用这个解求解同余方程 <code>ax ≡ b (mod m)</code>。这个算法在密码学和编程竞赛中经常被使用，特别是在求解模逆元和解决一些与模运算相关的问题时。</p>
<h3 id="人话版"><a href="#人话版" class="headerlink" title="人话版"></a>人话版</h3><p>拓展欧几里得算法就是可以在求解最大公约数的同时，求解出<code>ax + by = gcd(a,b)</code>的$(x,y)$。</p>
<blockquote>
<p>注意变量名的变化，可能看着有点乱。</p>
</blockquote>
<p>例如 $gcd(6,14) = 2$ 而 $2 = (-2)<em>6 + 1</em>14$</p>
<p>有两个基本的应用</p>
<ol>
<li>解不定方程$[ax + by = gcd(a,b)]$</li>
<li>求乘法逆元$[ ax \equiv 1 \pmod{b} ]$<br>并且在求解同余方程的时候<br>如果 $\text{gcd}(a, m)$ 能够整除 $b$，那么方程 $ax \equiv b \pmod{m}$ 有解，且一组解为：$x = x’ \times \frac{b}{\text{gcd}(a, m)}$</li>
</ol>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">exgcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span> &amp;x,<span class="hljs-type">int</span> &amp;y)</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-keyword">if</span>(!b)<br>    {<br>        x = <span class="hljs-number">1</span>,y = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> a;<br>    }<br>    <span class="hljs-type">int</span> d = <span class="hljs-built_in">exgcd</span>(b,a%b,y,x);<br>    y -= a / b * x;<span class="hljs-comment">//公式</span><br>    <span class="hljs-keyword">return</span> d;<br>}<br></code></pre></td></tr></tbody></table></figure>
<h4 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a>代码解释</h4><p><img src="https://pic.imgdb.cn/item/664236320ea9cb14036731d9.png" alt="img"></p>
<p>因此可以采取递归算法 先求出下一层的 ( x’ ) 和 ( y’ ) 再利用上述公式回代即可</p>
<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p><a href="https://www.acwing.com/problem/content/879/">扩展欧几里得算法</a><br><a href="https://www.luogu.com.cn/problem/P1082">P1082 [NOIP2012 提高组] 同余方程</a><br><a href="https://www.acwing.com/problem/content/880/">线性同余方程</a><br><a href="https://www.luogu.com.cn/problem/P2613">P2613 【模板】有理数取余</a><br><a href="https://www.luogu.com.cn/problem/P3811">P3811 【模板】模意义下的乘法逆元</a></p>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>cpp</tag>
        <tag>数论</tag>
        <tag>gcd</tag>
      </tags>
  </entry>
  <entry>
    <title>筛质数</title>
    <url>/posts/996e4f07/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>质数（素数）是指在大于1的自然数中，除了1和它本身之外没有其他正因数（除了1和本身以外没有其他能够整除它的正整数）。换句话说，一个质数只能被1和自身整除，不能被其他任何正整数整除。</p>
<h2 id="试除法求质数"><a href="#试除法求质数" class="headerlink" title="试除法求质数"></a>试除法求质数</h2><p>试除法是一种简单而直观的方法，用于确定一个数是否是质数。该方法的基本思想是通过逐一尝试除以小于该数平方根的所有可能因数，来检查是否存在除了1和该数本身之外的其他因数。如果找到了一个能够整除的因数，那么这个数就不是质数；否则，它就是质数。</p>
<p>时间复杂度$O(\sqrt n)$ </p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Is_prime</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-keyword">if</span>(n&lt;<span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n/i;++i)<br>        <span class="hljs-keyword">if</span>(n%i==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>

<blockquote>
<p>但是有的时候，我们要想知道比如$1 ~ 100000$ 的所有质数，这样就需要循环很多次。所以出现了筛质数，把质数都筛选出来，存储起来。</p>
</blockquote>
<h2 id="线性筛法求质数"><a href="#线性筛法求质数" class="headerlink" title="线性筛法求质数"></a>线性筛法求质数</h2><p>线性筛法是一种高效的算法，用于筛选出小于等于某个给定数的所有质数。与传统的试除法相比，线性筛法的优势在于它只需遍历一次，而且每个合数只被标记一次。这使得它在处理大范围的质数筛选时效率更高。<br>时间复杂度$O(n)$</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ol>
<li><p><strong>标记法：</strong> 初始化一个布尔数组 <code>st</code>，数组长度为 n+1，初始所有元素都标记为合数（false）。</p>
</li>
<li><p><strong>遍历质数：</strong> 从2开始，逐一遍历到n。对于每个质数i，如果它还没有被标记为质数（即 <code>st[i]</code> 为 false），则将其加入质数列表，然后标记它的所有倍数为合数。</p>
</li>
<li><p><strong>避免重复标记：</strong> 在标记的过程中，每个合数都只会被标记一次。这是线性筛法的优势之一，因为它避免了试除法中的重复标记问题。</p>
</li>
<li><p><strong>筛选结果：</strong> 最终，筛选出的质数都存储在 <code>primes</code> 数组中。</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> primes[N],cnt;<span class="hljs-comment">//存所有质数</span><br><span class="hljs-type">bool</span> st[N];<span class="hljs-comment">//记录i有没有被筛过</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get_primes</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span><span class="hljs-comment">//筛选2~n的素数</span></span><br><span class="hljs-function"></span>{<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;++i)<br>	{<br>		<span class="hljs-keyword">if</span>(!st[i]) primes[cnt++] = i;<span class="hljs-comment">//如果没有被筛过,证明是素数</span><br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;primes[j] * i &lt;=n;j++)<br>		{<br>		<span class="hljs-comment">/*p[j]一定小于等于i的质因子*/</span><br>			st[primes[j] * i] = <span class="hljs-literal">true</span>;<span class="hljs-comment">//用最小质因子筛掉合数</span><br>			<span class="hljs-keyword">if</span>(i%primes[j] == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>		}<br>	}<br>}<br></code></pre></td></tr></tbody></table></figure></li>
</ol>
<h4 id="存最小质因子"><a href="#存最小质因子" class="headerlink" title="存最小质因子"></a>存最小质因子</h4><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> primes[N],cnt;<span class="hljs-comment">//存所有质数</span><br><span class="hljs-type">bool</span> st[N];<span class="hljs-comment">//记录i有没有被筛过</span><br><span class="hljs-comment">//****</span><br><span class="hljs-type">int</span> minp[N];<span class="hljs-comment">//每个数的最小质因子</span><br><span class="hljs-comment">//****</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get_primes</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span><span class="hljs-comment">//筛选2~n的素数</span></span><br><span class="hljs-function"></span>{<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;++i)<br>	{<br>		<span class="hljs-keyword">if</span>(!st[i]) minp[i]=i,primes[cnt++] = i;<span class="hljs-comment">//如果没有被筛过,证明是素数</span><br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;primes[j] * i &lt;=n;j++)<br>		{<br>		<span class="hljs-comment">/*p[j]一定小于等于i的质因子*/</span><br>			st[primes[j] * i] = <span class="hljs-literal">true</span>;<span class="hljs-comment">//用最小质因子筛掉合数</span><br>			minp[primes[j] * i] = primes[j];<br>			<span class="hljs-keyword">if</span>(i%primes[j] == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>		}<br>	}<br>}<br></code></pre></td></tr></tbody></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>数论</tag>
        <tag>primes</tag>
      </tags>
  </entry>
  <entry>
    <title>组合计数</title>
    <url>/posts/9aab0fcd/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>组合计数是指在一个集合中选择一定数量的元素，而不考虑元素的顺序。在C++中，可以使用组合计数来解决各种组合问题，例如从一组元素中选择固定数量的元素。组合计数通常涉及到计算二项式系数（n choose k），其中 n 表示总的元素数量，k 表示要选择的元素数量。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>组合计数公式的展开可以通过阶乘的定义来实现。组合数 $C(n,k)$ 可以用以下公式示:<br>组合计数公式的展开过程：</p>
<p>$C(n, k) = \frac{n!}{k!(n-k)!}$</p>
<p>$= \frac{n \times (n-1) \times \ldots \times (n-k+1) \times (n-k)!}{k! \times (n-k)!}$</p>
<p>$= \frac{n \times (n-1) \times \ldots \times (n-k+1)}{k \times (k-1) \times \ldots \times 2 \times 1}$</p>
<p>用代码表示也很简单:</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">C</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>{<br>&nbsp; &nbsp; LL res = <span class="hljs-number">1</span>;<br>&nbsp; &nbsp; <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=a,j=<span class="hljs-number">1</span>;j&lt;=b;i--,j++)<br>&nbsp; &nbsp; &nbsp; &nbsp; res = res * i/j;<br>&nbsp; &nbsp; <span class="hljs-keyword">return</span> res;<br>}<br></code></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>数论</tag>
        <tag>组合数</tag>
      </tags>
  </entry>
  <entry>
    <title>快速幂</title>
    <url>/posts/20c47d09/</url>
    <content><![CDATA[<h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><h3 id="如何求解"><a href="#如何求解" class="headerlink" title="如何求解"></a>如何求解</h3><p>$a^{13}$怎么算，这个问题可能看着很简单，直接$a<em>a</em>a*…*a$就能算出来，但是如果这个指数如果变得非常大，比如$a^{100000}$ 这样写出来的代码运行起来就很慢,我们需要考虑优化。</p>
<h4 id="先考虑-a-2的幂"><a href="#先考虑-a-2的幂" class="headerlink" title="先考虑$a^{2的幂}$"></a>先考虑$a^{2的幂}$</h4><p>如果要求解$a^{64}$，我们可以发现$a*a$得到$a^2$再使用$a^2 * a^2$得到$a^4$，以此类推，我们可以花费很少的次数得到$a^{64}$。</p>
<h4 id="推广"><a href="#推广" class="headerlink" title="推广"></a>推广</h4><p>推广到正常数字，例如105。$a^{105}$,我们怎么去计算，我们可以知道$105 = 64 + 32 + 8 + 1$<br>于是我们可以得出$a^{105} = a^{64} * a^{32} * a^{8} * a^1$ ,再观察一下，发现每一个拆分出来的指数都是2的幂次，并且我们可以联想到二进制，$b(105) = 0110 1001$可以发现是对应的，也就是说我们可以把次数进行优化，并且从最低位到最高位依次累乘。</p>
<p>这边是快速幂的思想。</p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>快速幂算法是一种用于高效计算幂运算的算法。它通过将指数进行二进制拆分，并利用幂运算的性质，以减少计算的次数，从而提高运算速度。</p>
<h2 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h2><p>给定底数 <code>a</code> 和指数 <code>n</code>，要计算 <code>a^n</code>，快速幂算法的基本思想是将指数 <code>n</code> 二进制表示，并通过不断平方的方式来减少乘法的次数。例如，若要计算 <code>a^13</code>，可以按照以下步骤进行：</p>
<ol>
<li>将指数 <code>13</code> 转化为二进制：<code>1101</code>。</li>
<li>根据二进制表示，计算 <code>a^1</code>，<code>a^2</code>，<code>a^4</code>，<code>a^8</code>。</li>
<li>通过组合上述结果，得到 <code>a^13 = a^8 * a^4 * a^1</code>。</li>
</ol>
<p>这样，只需进行四次乘法运算，而不是直接进行 <code>a^13</code> 次乘法运算，大大减少了计算的时间复杂度。</p>
<p>时间复杂度是$O(logn)$，也很好理解。</p>
<h2 id="应用方式"><a href="#应用方式" class="headerlink" title="应用方式"></a>应用方式</h2><h3 id="1-求幂运算"><a href="#1-求幂运算" class="headerlink" title="1. 求幂运算"></a>1. 求幂运算</h3><p>快速幂算法广泛应用于需要大量幂运算的场景，如密码学中的加密算法、图论中的邻接矩阵乘法等。</p>
<h3 id="2-模幂运算"><a href="#2-模幂运算" class="headerlink" title="2. 模幂运算"></a>2. 模幂运算</h3><p>在密码学领域，快速幂算法常被用于模幂运算，即 <code>(a^b) mod m</code> 的计算。这在很多加密算法中都是一个基本的步骤。</p>
<h2 id="算法过程"><a href="#算法过程" class="headerlink" title="算法过程"></a>算法过程</h2><ol>
<li>将指数 <code>k</code> 转化为二进制表示。</li>
<li>从二进制表示的最低位开始，逐位检查：<ul>
<li>如果当前位是 <code>1</code>，则乘以当前的底数 <code>base</code>。</li>
<li>无论当前位是否是 <code>1</code>，都将底数 <code>base</code> 进行平方操作。</li>
</ul>
</li>
<li>继续处理下一位，直到二进制表示的最高位。</li>
</ol>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//求 m^k mod p，时间复杂度 O(logk)</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">qmi</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> p)</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">1</span> % p, t = m;<br>    <span class="hljs-keyword">while</span> (k)<br>    {<br>        <span class="hljs-keyword">if</span> (k&amp;<span class="hljs-number">1</span>) res = res * t % p;<br>        t = t * t % p;<br>        k &gt;&gt;= <span class="hljs-number">1</span>;<br>    }<br>    <span class="hljs-keyword">return</span> res;<br>}<br></code></pre></td></tr></tbody></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>时间复杂度</title>
    <url>/posts/58601/</url>
    <content><![CDATA[<h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>一般ACM或者笔试题的时间限制是1秒或2秒。<br>在这种情况下，C++代码中的操作次数控制在 $10^7$~$10^8$为最佳。</p>
<p>下面给出在不同数据范围下，代码的时间复杂度和算法该如何选择：</p>
<ol>
<li>n$&lt;=$ 30,指数级别,dfs+剪枝,状态压缩dp</li>
<li>n$&lt;=$ 100 =&gt; O($n^3$),floyd,dp,高斯消元</li>
<li>n$&lt;=$ 1000 =&gt; O($n^2$),O($n^2logn$),dp,二分,朴素版dijkstra,朴素版Prim,Bellman-Ford</li>
<li>n$&lt;=$ 10000 =&gt;O($n*\sqrt{n}$),块状链表，分块，莫队</li>
<li>n$&lt;=$  100000 =&gt;O($nlogn$) =&gt;各种sort，线段树、树状数组、set/map、heap、拓扑排序、dijkstra+heap、prim+heap、Kruskal、spfa、求凸包、求半平面交、二分、CDQ分治、整体二分、后缀数组、树链剖分、动态树</li>
<li>n$&lt;=$ 1000000 =&gt; O(n),以及常数较小的O($nlogn$)算法 =&gt; 单调队列、 hash、双指针扫描、并查集，kmp、AC自动机，常数比较小的 O($nlogn$)的做法：sort、树状数组、heap、dijkstra、spfa</li>
<li>n$&lt;=$ 10000000 =&gt;O(n) , 双指针扫描,kmp,AC自动机，线性筛素数</li>
<li>n$&lt;=$ $10^9$ =&gt;O($\sqrt n$) ,判断质数</li>
<li>n$&lt;=$ $10^{18}$ =&gt;O($logn$) ,最大公约数,快速幂,数位DP</li>
<li>n$&lt;= 10^{1000}$ =&gt; O($(logn)^2$),高精度加减乘除</li>
<li>n$&lt;= 10^{100000}$ =&gt;O($logk$ x $loglogk$),k表示数位,高精度加减,FFT/NTT</li>
</ol>
<hr>
<p>摘自<a href="https://www.acwing.com/blog/content/32/">acwing</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>元组tuple</title>
    <url>/posts/bc85eea7/</url>
    <content><![CDATA[<h2 id="C-Tuple-元组详解"><a href="#C-Tuple-元组详解" class="headerlink" title="C++ Tuple 元组详解"></a>C++ Tuple 元组详解</h2><p>C++ 标准库中的元组（Tuple）是一种特殊的数据结构，可以容纳多个不同类型的元素。它提供了一种方便的方式来组织和处理多个值，类似于结构体，但更加灵活。</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="创建元组"><a href="#创建元组" class="headerlink" title="创建元组"></a>创建元组</h3><p>在 C++ 中，你可以使用 <code>std::tuple</code> 来创建元组。以下是一个简单的例子：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;tuple&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-comment">// 创建一个包含整数、浮点数和字符串的元组</span><br>    <span class="hljs-function">std::tuple&lt;<span class="hljs-type">int</span>, <span class="hljs-type">float</span>, std::string&gt; <span class="hljs-title">myTuple</span><span class="hljs-params">(<span class="hljs-number">42</span>, <span class="hljs-number">3.14</span>, <span class="hljs-string">"Hello"</span>)</span></span>;<br><br>    <span class="hljs-comment">// 访问元组中的元素</span><br>    std::cout &lt;&lt; <span class="hljs-string">"First element: "</span> &lt;&lt; std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">0</span>&gt;(myTuple) &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">"Second element: "</span> &lt;&lt; std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">1</span>&gt;(myTuple) &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">"Third element: "</span> &lt;&lt; std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">2</span>&gt;(myTuple) &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>
<h2 id="自动类型推导"><a href="#自动类型推导" class="headerlink" title="自动类型推导"></a>自动类型推导</h2><p>C++11 引入了自动类型推导，使得创建元组更为方便：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;tuple&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-comment">// 使用自动类型推导创建元组</span><br>    <span class="hljs-keyword">auto</span> myTuple = std::<span class="hljs-built_in">make_tuple</span>(<span class="hljs-number">42</span>, <span class="hljs-number">3.14</span>, <span class="hljs-string">"Hello"</span>);<br><br>    <span class="hljs-comment">// 访问元组中的元素</span><br>    std::cout &lt;&lt; <span class="hljs-string">"First element: "</span> &lt;&lt; std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">0</span>&gt;(myTuple) &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">"Second element: "</span> &lt;&lt; std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">1</span>&gt;(myTuple) &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">"Third element: "</span> &lt;&lt; std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">2</span>&gt;(myTuple) &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br><br></code></pre></td></tr></tbody></table></figure>

<h2 id="使用元组"><a href="#使用元组" class="headerlink" title="使用元组"></a>使用元组</h2><h3 id="解构元组"><a href="#解构元组" class="headerlink" title="解构元组"></a>解构元组</h3><p>通过结构化绑定（Structured Binding），你可以更方便地解构元组：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;tuple&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-comment">// 创建元组</span><br>    <span class="hljs-keyword">auto</span> myTuple = std::<span class="hljs-built_in">make_tuple</span>(<span class="hljs-number">42</span>, <span class="hljs-number">3.14</span>, <span class="hljs-string">"Hello"</span>);<br><br>    <span class="hljs-comment">// 使用结构化绑定解构元组</span><br>    <span class="hljs-keyword">auto</span> [first, second, third] = myTuple;<br><br>    <span class="hljs-comment">// 访问解构后的变量</span><br>    std::cout &lt;&lt; <span class="hljs-string">"First element: "</span> &lt;&lt; first &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">"Second element: "</span> &lt;&lt; second &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">"Third element: "</span> &lt;&lt; third &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br><br></code></pre></td></tr></tbody></table></figure>
<p>使用<code>std::tie</code>解构元组</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;tuple&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-comment">// 创建一个包含整数、浮点数和字符串的元组</span><br>    <span class="hljs-function">std::tuple&lt;<span class="hljs-type">int</span>, <span class="hljs-type">float</span>, std::string&gt; <span class="hljs-title">myTuple</span><span class="hljs-params">(<span class="hljs-number">42</span>, <span class="hljs-number">3.14</span>, <span class="hljs-string">"Hello"</span>)</span></span>;<br><br>    <span class="hljs-comment">// 使用 std::tie 解构元组</span><br>    <span class="hljs-type">int</span> intValue;<br>    <span class="hljs-type">float</span> floatValue;<br>    std::string stringValue;<br><br>    std::<span class="hljs-built_in">tie</span>(intValue, floatValue, stringValue) = myTuple;<br><br>    <span class="hljs-comment">// 访问解构后的变量</span><br>    std::cout &lt;&lt; <span class="hljs-string">"Int value: "</span> &lt;&lt; intValue &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">"Float value: "</span> &lt;&lt; floatValue &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">"String value: "</span> &lt;&lt; stringValue &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br><br></code></pre></td></tr></tbody></table></figure>

<h3 id="元组的比较"><a href="#元组的比较" class="headerlink" title="元组的比较"></a>元组的比较</h3><p>元组之间的比较可以通过 std::tie 实现：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;tuple&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-comment">// 创建两个元组</span><br>    <span class="hljs-keyword">auto</span> tuple1 = std::<span class="hljs-built_in">make_tuple</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br>    <span class="hljs-keyword">auto</span> tuple2 = std::<span class="hljs-built_in">make_tuple</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br><br>    <span class="hljs-comment">// 使用 std::tie 进行比较</span><br>    <span class="hljs-keyword">if</span> (std::<span class="hljs-built_in">tie</span>(tuple1) == std::<span class="hljs-built_in">tie</span>(tuple2)) {<br>        std::cout &lt;&lt; <span class="hljs-string">"Tuples are equal."</span> &lt;&lt; std::endl;<br>    } <span class="hljs-keyword">else</span> {<br>        std::cout &lt;&lt; <span class="hljs-string">"Tuples are not equal."</span> &lt;&lt; std::endl;<br>    }<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br><br></code></pre></td></tr></tbody></table></figure>

<h2 id="高级特性"><a href="#高级特性" class="headerlink" title="高级特性"></a>高级特性</h2><h3 id="元组的递归"><a href="#元组的递归" class="headerlink" title="元组的递归"></a>元组的递归</h3><p>元组可以嵌套，实现递归结构：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;tuple&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-comment">// 递归函数处理元组</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>... Types&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printTuple</span><span class="hljs-params">(<span class="hljs-type">const</span> std::tuple&lt;Types...&gt;&amp; myTuple)</span> </span>{<br>    std::cout &lt;&lt; std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">0</span>&gt;(myTuple) &lt;&lt; <span class="hljs-string">" "</span>;<br><br>    <span class="hljs-comment">// 递归调用</span><br>    <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(<span class="hljs-keyword">sizeof</span>...(Types) &gt; <span class="hljs-number">1</span>)</span> </span>{<br>        <span class="hljs-built_in">printTuple</span>(std::<span class="hljs-built_in">tuple_tail</span>(myTuple));<br>    } <span class="hljs-keyword">else</span> {<br>        std::cout &lt;&lt; std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">1</span>&gt;(myTuple) &lt;&lt; std::endl;<br>    }<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-comment">// 创建嵌套元组</span><br>    <span class="hljs-keyword">auto</span> nestedTuple = std::<span class="hljs-built_in">make_tuple</span>(<span class="hljs-number">1</span>, std::<span class="hljs-built_in">make_tuple</span>(<span class="hljs-number">2</span>, std::<span class="hljs-built_in">make_tuple</span>(<span class="hljs-number">3</span>, <span class="hljs-string">"Hello"</span>)));<br><br>    <span class="hljs-comment">// 递归打印元组</span><br>    <span class="hljs-built_in">printTuple</span>(nestedTuple);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br><br></code></pre></td></tr></tbody></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>C++ 中的元组是一种强大的数据结构，提供了灵活的方式来处理多个不同类型的值。通过结构化绑定等特性，元组的使用变得更加方便。了解并熟练使用元组，将会使得代码更具表现力和可读性。</p>
<p>以上仅是元组的一些基础用法和高级特性，C++ 的元组还有许多其他功能和用法，具体可参考 <a href="https://en.cppreference.com/w/cpp/utility/tuple">C++ 标准库的相关文档</a>。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>tuple</tag>
      </tags>
  </entry>
  <entry>
    <title>日期处理</title>
    <url>/posts/3381e20e/</url>
    <content><![CDATA[<h3 id="日期数组"><a href="#日期数组" class="headerlink" title="日期数组"></a>日期数组</h3><p>方便查询每个月的天数</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> days[<span class="hljs-number">13</span>] = {<span class="hljs-number">0</span>, <span class="hljs-number">31</span>, <span class="hljs-number">28</span>, <span class="hljs-number">31</span>, <span class="hljs-number">30</span>, <span class="hljs-number">31</span>, <span class="hljs-number">30</span>, <span class="hljs-number">31</span>, <span class="hljs-number">31</span>, <span class="hljs-number">30</span>, <span class="hljs-number">31</span>, <span class="hljs-number">30</span>, <span class="hljs-number">31</span>};<br></code></pre></td></tr></tbody></table></figure>

<h3 id="判断闰年"><a href="#判断闰年" class="headerlink" title="判断闰年"></a>判断闰年</h3><p>被400整除 或者 被4整除的同时不被100整除</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">is_leap</span><span class="hljs-params">(<span class="hljs-type">int</span> year)</span></span><br><span class="hljs-function"></span>{<br>&nbsp; &nbsp; <span class="hljs-keyword">if</span> (year % <span class="hljs-number">4</span> == <span class="hljs-number">0</span> &amp;&amp; year % <span class="hljs-number">100</span> || year % <span class="hljs-number">400</span> == <span class="hljs-number">0</span>)<br>&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&nbsp; &nbsp; <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>

<h3 id="每个月的天数"><a href="#每个月的天数" class="headerlink" title="每个月的天数"></a>每个月的天数</h3><p>主要是需要判断闰年和月份的情况</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_month_day</span><span class="hljs-params">(<span class="hljs-type">int</span> year, <span class="hljs-type">int</span> month)</span></span><br><span class="hljs-function"></span>{<br>&nbsp; &nbsp; <span class="hljs-type">int</span> res = days[month];<br>&nbsp; &nbsp; <span class="hljs-keyword">if</span> (month == <span class="hljs-number">2</span> &amp;&amp; <span class="hljs-built_in">is_leap</span>(year)) res += <span class="hljs-number">1</span>;<br>&nbsp; &nbsp; <span class="hljs-keyword">return</span> res;<br>}<br></code></pre></td></tr></tbody></table></figure>

<h3 id="每年的天数"><a href="#每年的天数" class="headerlink" title="每年的天数"></a>每年的天数</h3><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_year_day</span><span class="hljs-params">(<span class="hljs-type">int</span> year)</span></span><br><span class="hljs-function"></span>{<br>&nbsp; &nbsp; <span class="hljs-type">int</span> res = <span class="hljs-number">365</span>;<br>&nbsp; &nbsp; <span class="hljs-keyword">if</span> (<span class="hljs-built_in">is_leap</span>(year)) res += <span class="hljs-number">1</span>;<br>&nbsp; &nbsp; <span class="hljs-keyword">return</span> res;<br>}<br></code></pre></td></tr></tbody></table></figure>]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>日期</tag>
      </tags>
  </entry>
  <entry>
    <title>求逆序对的数量</title>
    <url>/posts/41139/</url>
    <content><![CDATA[<h2 id="求逆序对的数量"><a href="#求逆序对的数量" class="headerlink" title="求逆序对的数量"></a>求逆序对的数量</h2><h2 id="什么是逆序对"><a href="#什么是逆序对" class="headerlink" title="什么是逆序对"></a>什么是逆序对</h2><p>设 A 为一个有 n 个数字的有序集 (n&gt;1)，其中所有数字各不相同。<br>如果存在正整数 i, j 使得 1 ≤ i &lt; j ≤ n 而且 A[i] &gt; A[j]，则 &lt;A[i], A[j]&gt; 这个有序对称为 A 的一个逆序对，也称作逆序数。</p>
<h2 id="使用树状数组求逆序对"><a href="#使用树状数组求逆序对" class="headerlink" title="使用树状数组求逆序对"></a>使用树状数组求逆序对</h2><p>在树状数组中，我们维护一个tr数组，这个数组的含义是目前A中的数字出现的次数</p>
<p>我们便可以通过逆序对的<code>query</code>操作和<code>add</code>操作进行动态求解。</p>
<blockquote>
<p>因为A的数据可能不是一个标准的排列，所以我们需要离散化一下数据，防止数据过大，</p>
</blockquote>
<br>

<p>下面使用<code>unordered_map&lt;int,int&gt; S;</code>进行离散化，进行一个值的映射，获取映射值的函数为</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">auto</span> x)</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-keyword">if</span>(S.<span class="hljs-built_in">count</span>(x) == <span class="hljs-number">0</span>) S[x] = ++ idx;<br>    <span class="hljs-keyword">return</span> S[x];<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>我们首先要吧映射值给求一遍，这要求我们的数据是有序的，所以我们需要先进行一次<strong>排序</strong>获取映射值。</p>
<br>

<p>之后动态对tr数组进行<code>add</code>和<code>query</code>,从最后一个往前推，每次答案加上<code>query(y-1)</code>,是求在当前已经有的数字，有多少个小于当前数字（正确顺序是大于）。</p>
<blockquote>
<p>如果正推，则为<code>query(n) - query(y)</code>。</p>
</blockquote>
<p>每次查询完，将当前数字插入tr数组</p>
<h3 id="代码片段"><a href="#代码片段" class="headerlink" title="代码片段"></a>代码片段</h3><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;deque&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _fio ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> all(x) (x).begin(), (x).end()</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> allr(x) (x).rbegin(), (x).rend()</span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL ;<br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; PII;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span> nl = <span class="hljs-string">'\n'</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100005</span>;<br>LL tr[N];<br>LL a[N],c[N],n,ans,idx;<br>unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; S;<br><span class="hljs-function">LL <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-keyword">return</span> x &amp; -x;<br>}<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> v)</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=x;i&lt;=n;i+=<span class="hljs-built_in">lowbit</span>(i)) tr[i] += v;<br>}<br><span class="hljs-function">LL <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>{<br>    LL res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=x;i;i-=<span class="hljs-built_in">lowbit</span>(i)) res += tr[i];<br>    <span class="hljs-keyword">return</span> res;<br>}<br><span class="hljs-function">LL <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-keyword">if</span>(S.<span class="hljs-built_in">count</span>(x) == <span class="hljs-number">0</span>) S[x] = ++ idx;<br>    <span class="hljs-keyword">return</span> S[x];<br>}<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i) cin &gt;&gt; a[i];<br>    <span class="hljs-built_in">memcpy</span>(c,a,<span class="hljs-keyword">sizeof</span> a);<br>    <span class="hljs-built_in">sort</span>(a,a+n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i) <span class="hljs-built_in">get</span>(a[i]);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;--i)<br>    {<br>        <span class="hljs-type">int</span> y = <span class="hljs-built_in">get</span>(c[i]);<br>        ans += <span class="hljs-built_in">query</span>(y<span class="hljs-number">-1</span>);<br>        <span class="hljs-built_in">add</span>(y,<span class="hljs-number">1</span>);<br>    }<br>    cout &lt;&lt; ans &lt;&lt; nl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br><br></code></pre></td></tr></tbody></table></figure>


<h2 id="使用归并排序求逆序对"><a href="#使用归并排序求逆序对" class="headerlink" title="使用归并排序求逆序对"></a>使用归并排序求逆序对</h2><p>实际上数字的交换次数即为A的逆序对数量<br>我们分区间来看<br>一个区间的逆序对数量=左边逆序对的数量+右边逆序对的数量+跨边界的逆序对数量。<br>和一般的归并排序不同的是<code>res+=mid-i+1</code>,<br>这里便是跨边界的逆序对的数量,其实就是在归并过程中，如果有的某一个数大于左边的一个数，就把左边遍历到的数字数量加上。因为左边是有序的，只要右边的数小于左边的一个数，就会小于左边那个数及前面所有的数。</p>
<figure class="highlight perl"><table><tbody><tr><td class="code"><pre><code class="hljs perl"><span class="hljs-comment">#include &lt;iostream&gt;</span><br><span class="hljs-comment">#include &lt;cstring&gt;</span><br><span class="hljs-comment">#include &lt;cstdio&gt;</span><br><span class="hljs-comment">#include &lt;algorithm&gt;</span><br>using namespace std;<br>const <span class="hljs-keyword">int</span> N = <span class="hljs-number">1</span>e5+<span class="hljs-number">10</span>;<br>typedef long long ll;<br><span class="hljs-keyword">int</span> a[N];<br><span class="hljs-keyword">int</span> tmp[N];<br><span class="hljs-keyword">int</span> n;<br><br>ll merge_sort(<span class="hljs-keyword">int</span> *<span class="hljs-keyword">q</span>,<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r)<br>{<br>	<span class="hljs-keyword">if</span>(l&gt;=r) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">int</span> mid = l+r&gt;&gt;<span class="hljs-number">1</span>;<br>	ll res = merge_sort(<span class="hljs-keyword">q</span>,l,mid)+merge_sort(<span class="hljs-keyword">q</span>,mid+<span class="hljs-number">1</span>,r);<br>	<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>,i=l,j=mid+<span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">while</span>(i&lt;=mid &amp;&amp; j&lt;=r)<br>	{<br>		<span class="hljs-keyword">if</span>(<span class="hljs-string">q[i]</span>&lt;=<span class="hljs-string">q[j]</span>) tmp[k++] = <span class="hljs-string">q[i++]</span>;<br>		<span class="hljs-keyword">else</span> {tmp[k++] = <span class="hljs-string">q[j++]</span>;res+=mid-i+<span class="hljs-number">1</span>;}	<br>	}<br>	<span class="hljs-keyword">while</span>(i&lt;=mid) tmp[k++] = <span class="hljs-string">q[i++]</span>;<br>	<span class="hljs-keyword">while</span>(j&lt;=r) tmp[k++] = <span class="hljs-string">q[j++]</span>;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=l,j=<span class="hljs-number">0</span>;i&lt;=r;++i,++j) <span class="hljs-string">q[i]</span> = tmp[j];<br>	<span class="hljs-keyword">return</span> res;<br>}<br><br><span class="hljs-keyword">int</span> main()<br>{<br>	cin&gt;&gt;n;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;<br>	i&lt;n;++i) cin&gt;&gt;a[i];<br>	cout&lt;&lt;merge_sort(a,<span class="hljs-number">0</span>,n-<span class="hljs-number">1</span>);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>


<blockquote>
<p>这两种算法求逆序对的时间复杂度理论都为(nlogn),但从代码角度考虑，我更为推荐树状数组解法。</p>
</blockquote>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>STL</title>
    <url>/posts/3006dc10/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>C++ 标准模板库（Standard Template Library，STL）是一套功能强大的 C++ 模板类和函数的集合，它提供了一系列通用的、可复用的算法和数据结构。</p>
<p>STL 的设计基于泛型编程，这意味着使用模板可以编写出独立于任何特定数据类型的代码。</p>
<p>STL 分为多个组件，包括容器（Containers）、迭代器（Iterators）、算法（Algorithms）、函数对象（Function Objects）和适配器（Adapters）等。</p>
<p>使用 STL 的好处:</p>
<ul>
<li><strong>代码复用</strong>：STL 提供了大量的通用数据结构和算法，可以减少重复编写代码的工作。</li>
<li><strong>性能优化</strong>：STL 中的算法和数据结构都经过了优化，以提供最佳的性能。</li>
<li><strong>泛型编程</strong>：使用模板，STL 支持泛型编程，使得算法和数据结构可以适用于任何数据类型。</li>
<li><strong>易于维护</strong>：STL 的设计使得代码更加模块化，易于阅读和维护。</li>
</ul>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>因为 $C++ 11$ 有 <a href="https://en.cppreference.com/w/cpp/language/auto">auto</a> 这一关键字的存在，本文不再介绍使用迭代器迭代，而只介绍一些在算法竞赛当中常用的容器以及算法函数等。</p>
<p>本文代码默认自带了<code>using namespace std;</code> 以减少 <code>std::</code> 的出现。</p>
<p>并只介绍常用操作，更详细的操作请点进对应的文章。</p>
<h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h2><p>STL（标准模板库）中的 <code>vector</code> 是 C++ 中一个非常常用的容器类。它是一个动态数组，可以自动调整大小，并提供了类似于数组的随机访问功能。</p>
<p>详细操作:<a href="/posts/1b6e485b/" title="vector">vector</a></p>
<h3 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h3><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><code class="hljs c++">   .<span class="hljs-built_in">size</span>()  返回元素个数<br>   .<span class="hljs-built_in">empty</span>()  返回是否为空<br>   .<span class="hljs-built_in">clear</span>()  清空<br>   .<span class="hljs-built_in">front</span>()/<span class="hljs-built_in">back</span>()<br>   .<span class="hljs-built_in">push_back</span>()/<span class="hljs-built_in">pop_back</span>()<br>   .<span class="hljs-built_in">begin</span>()/<span class="hljs-built_in">end</span>()<br>   []<br>   支持比较运算，按字典序<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;el : v){} 迭代<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i){} 迭代<br></code></pre></td></tr></tbody></table></figure>


<h2 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h2><p>STL（标准模板库）中的 <code>queue</code> 是 C++ 中的队列容器。实现了队列的基本功能 $FIFO$。<br>详细操作:<a href="/posts/7ffd7f63/" title="queue">queue</a></p>
<h3 id="常用操作-1"><a href="#常用操作-1" class="headerlink" title="常用操作"></a>常用操作</h3><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><code class="hljs c++">   .<span class="hljs-built_in">size</span>()<br>   .<span class="hljs-built_in">empty</span>()<br>   .<span class="hljs-built_in">push</span>()  向队尾插入一个元素<br>   .<span class="hljs-built_in">front</span>()  返回队头元素<br>   .<span class="hljs-built_in">back</span>()  返回队尾元素<br>   .<span class="hljs-built_in">pop</span>()  弹出队头元素<br><br><span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>()) q.<span class="hljs-built_in">pop</span>(); 遍历<br></code></pre></td></tr></tbody></table></figure>

<h3 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h3><p>会自动将<strong>大/小</strong>的放在队首。</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><code class="hljs c++">priority_queue, 优先队列，默认是大根堆<br>    .<span class="hljs-built_in">size</span>()<br>    .<span class="hljs-built_in">empty</span>()<br>    .<span class="hljs-built_in">push</span>()  插入一个元素<br>    .<span class="hljs-built_in">top</span>()  返回堆顶元素<br>    .<span class="hljs-built_in">pop</span>()  弹出堆顶元素<br>    <span class="hljs-comment">/*优先队列*/</span><br>    定义成小根堆的方式：priority_queue&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, greater&lt;<span class="hljs-type">int</span>&gt;&gt; q;<br><br></code></pre></td></tr></tbody></table></figure>

<h3 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h3><p>有迭代器，可以迭代，操作空间比queue更加大。</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><code class="hljs c++">deque, 双端队列<br>    .<span class="hljs-built_in">size</span>()<br>    .<span class="hljs-built_in">empty</span>()<br>    .<span class="hljs-built_in">clear</span>()<br>    .<span class="hljs-built_in">front</span>()/<span class="hljs-built_in">back</span>()<br>    .<span class="hljs-built_in">push_back</span>()/<span class="hljs-built_in">pop_back</span>()<br>    .<span class="hljs-built_in">push_front</span>()/<span class="hljs-built_in">pop_front</span>()<br>    .<span class="hljs-built_in">begin</span>()/<span class="hljs-built_in">end</span>()<br>    []<br></code></pre></td></tr></tbody></table></figure>
<h2 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h2><p>STL（标准模板库）中的 <code>stack</code> 是 C++ 中的栈容器。实现了栈的基本功能。<br>详细操作:<a href="/posts/41a87b6a/" title="stack">stack</a></p>
<h3 id="常用操作-2"><a href="#常用操作-2" class="headerlink" title="常用操作"></a>常用操作</h3><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><code class="hljs c++">.<span class="hljs-built_in">size</span>()<br>.<span class="hljs-built_in">empty</span>()<br>.<span class="hljs-built_in">push</span>()  向栈顶插入一个元素<br>.<span class="hljs-built_in">top</span>()  返回栈顶元素<br>.<span class="hljs-built_in">pop</span>()  弹出栈顶元素<br></code></pre></td></tr></tbody></table></figure>


<h2 id="set-和-map"><a href="#set-和-map" class="headerlink" title="set 和 map"></a>set 和 map</h2><p>STL（标准模板库）中的 <code>set</code> 是 C++ 中的集合容器。实现了集合的基本功能。<br>而map则类似于py里面的字典<br>详细操作:<a href="/posts/e61425dc/" title="set">set</a></p>
<h3 id="常用操作-3"><a href="#常用操作-3" class="headerlink" title="常用操作"></a>常用操作</h3><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><code class="hljs c++">set, map, multiset, multimap, 基于平衡二叉树（红黑树），动态维护有序序列<br>    .<span class="hljs-built_in">size</span>()<br>    .<span class="hljs-built_in">empty</span>()<br>    .<span class="hljs-built_in">clear</span>()<br>    .<span class="hljs-built_in">begin</span>()/<span class="hljs-built_in">end</span>()<br>    ++, -- 返回前驱和后继，时间复杂度 <span class="hljs-built_in">O</span>(logn)<br><br>    set/<span class="hljs-function">multiset</span><br><span class="hljs-function">        <span class="hljs-title">insert</span><span class="hljs-params">()</span>  插入一个数</span><br><span class="hljs-function">        <span class="hljs-title">find</span><span class="hljs-params">()</span>  查找一个数</span><br><span class="hljs-function">        <span class="hljs-title">count</span><span class="hljs-params">()</span>  返回某一个数的个数</span><br><span class="hljs-function">        <span class="hljs-title">erase</span><span class="hljs-params">()</span></span><br><span class="hljs-function">            <span class="hljs-params">(<span class="hljs-number">1</span>)</span> 输入是一个数x，删除所有x   <span class="hljs-title">O</span><span class="hljs-params">(k + logn)</span></span><br><span class="hljs-function">            <span class="hljs-params">(<span class="hljs-number">2</span>)</span> 输入一个迭代器，删除这个迭代器</span><br><span class="hljs-function">        <span class="hljs-title">lower_bound</span><span class="hljs-params">()</span>/<span class="hljs-title">upper_bound</span><span class="hljs-params">()</span></span><br><span class="hljs-function">            <span class="hljs-title">lower_bound</span><span class="hljs-params">(x)</span>  返回大于等于x的最小的数的迭代器</span><br><span class="hljs-function">            <span class="hljs-title">upper_bound</span><span class="hljs-params">(x)</span>  返回大于x的最小的数的迭代器</span><br></code></pre></td></tr></tbody></table></figure>

<h2 id="string"><a href="#string" class="headerlink" title="string"></a>string</h2><p>STL（标准模板库）中的 <code>string</code> 是 C++ 中的字符串容器。</p>
<p>详细操作:<a href="/posts/9ebeb2a9/" title="string">string</a></p>
<h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><code class="hljs c++">.<span class="hljs-built_in">size</span>()/<span class="hljs-built_in">length</span>()  返回字符串长度<br>.<span class="hljs-built_in">empty</span>()<br>.<span class="hljs-built_in">clear</span>()<br>.<span class="hljs-built_in">substr</span>(起始下标，(子串长度))  返回子串<br>.<span class="hljs-built_in">c_str</span>()  返回字符串所在字符数组的起始地址<br></code></pre></td></tr></tbody></table></figure>

<h2 id="bitset"><a href="#bitset" class="headerlink" title="bitset"></a>bitset</h2><p>详细操作:<a href="/posts/9dd4d1cb/" title="bitset">% ### 基本操作 </a></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><code class="hljs c++">bitset&lt;10000&gt; s;<br>   ~, &amp;, |, ^<br>   &gt;&gt;, &lt;&lt;<br>   ==, !=<br>   []<br><br>   <span class="hljs-built_in">count</span>()  返回有多少个<span class="hljs-number">1</span><br><br>   <span class="hljs-built_in">any</span>()  判断是否至少有一个<span class="hljs-number">1</span><br>   <span class="hljs-built_in">none</span>()  判断是否全为<span class="hljs-number">0</span><br><br>   <span class="hljs-built_in">set</span>()  把所有位置成<span class="hljs-number">1</span><br>   <span class="hljs-built_in">set</span>(k, v)  将第k位变成v<br>   <span class="hljs-built_in">reset</span>()  把所有位变成<span class="hljs-number">0</span><br>   <span class="hljs-built_in">flip</span>()  等价于~<br>   <span class="hljs-built_in">flip</span>(k) 把第k位取反<br></code></pre></td></tr></tbody></table></figure><a href="/posts/9dd4d1cb/" title="bitset"> ## pair 一些情况下可以代替双关键字结构体。 <figure class="highlight c++"><table><tbody><tr><td class="code"><pre><code class="hljs c++">pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;<br>	first, 第一个元素<br>    second, 第二个元素<br>    支持比较运算，以first为第一关键字，以second为第二关键字（字典序）<br></code></pre></td></tr></tbody></table></figure> ## tuple 元组，在一些情况下可以替换结构体。 详细操作:{%post_link 算法竞赛/巧妙技巧/元组tuple</a><p></p>
]]></content>
      <categories>
        <category>STL</category>
      </categories>
      <tags>
        <tag>cpp</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>带修莫队</title>
    <url>/posts/84c587e8/</url>
    <content><![CDATA[<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>在学习带修莫队之前，请务必学会<a href="/posts/a072cd53/" title="普通莫队">普通莫队</a>。</p>
<p>带修莫队即为：</p>
<p>普通莫队是不能修改的，我们可以强行让它可以修改，加上一维<strong>时间维</strong>,表示这次操作的时间。</p>
<p>时间维表示经历的修改次数。</p>
<p>即把询问$[l,r]$变成$[l,r,time]$,那么因为多了一维，我们对应的操作也会增加</p>
<ul>
<li>$[l-1,r,time]$</li>
<li>$[l+1,r,time]$</li>
<li>$[l,r-1,time]$</li>
<li>$[l,r+1,time]$</li>
<li>$[l,r,time-1]$</li>
<li>$[l,r,time+1]$<br>这样的转移时间复杂度仍然是$O(1)$,对应的，我们的排序规则就需要进行变动。<br>这样总的时间复杂度是$O(n^{\frac{5}{3}})$ 。</li>
</ul>
<h2 id="排序规则"><a href="#排序规则" class="headerlink" title="排序规则"></a>排序规则</h2><p>这一次的排序方式是以$n^{\frac{2}{3}}$为一块，分成了$n^{\frac{1}{3}}$ 块：</p>
<ul>
<li>第一关键词是左端点所在块</li>
<li>第二关键词是右端点所在块</li>
<li>第三关键词是时间</li>
</ul>
<h2 id="时间维"><a href="#时间维" class="headerlink" title="时间维"></a>时间维</h2><p>就跟普通莫队差不多，差多少时间，就补多少时间，可以把$[l,r,time]$画成一个三维空间去理解。</p>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p><a href="https://www.luogu.com.cn/problem/P1903">P1903 数颜色 / 维护队列 </a><br>题目大意：给你一个序列，M 个操作，有两种操作：</p>
<ol>
<li>修改序列上某一位的数字</li>
<li>询问区间&nbsp;$[l,r]$&nbsp;中数字的种类数（多个相同的数字只算一个）<br>可以发现，如果没有操作1，我们可以用普通莫队直接秒了，但是现在增加了一个单点修改的操作，所以我们需要使用带修莫队。</li>
</ol>

    <div class="fold">
      <div class="fold-title fold-default collapsed" data-toggle="collapse" href="#collapse-8086d9f7" role="button" aria-expanded="false" aria-controls="collapse-8086d9f7">
        <div class="fold-arrow">▶</div>解法
      </div>
      <div class="fold-collapse collapse" id="collapse-8086d9f7">
        <div class="fold-content">
          <h4 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h4><p>对于查询，就是很简单的维护一个桶，不过多赘述。<br>接下来考虑修改，我们把一个点修改成另一个颜色，我们需要考虑这个点是否在我当前区间里面，如果不在就不需要修改。如果在的话，增加一下修改之后的点，删除掉修改前的点。</p><p>无论是否在当前区间，都需要swap，因为修改后的下一次操作一定相反。<br>即为 (修改该位置-&gt;还原该位置-&gt;修改该位置-&gt;….)</p><h4 id="警示"><a href="#警示" class="headerlink" title="警示"></a>警示</h4><p>这里swap的时候一定要用引用，拷贝的话是没用的,这个点卡了我一下午!!!!。<br>因为这里的意义是，交换过后，我之后可以<strong>再修改回来</strong>。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> time = [&amp;](<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r) -&gt; <span class="hljs-type">void</span> {<br>           <span class="hljs-type">int</span> &amp;w = modify[x][<span class="hljs-number">1</span>], id = modify[x][<span class="hljs-number">0</span>];<br>           <span class="hljs-keyword">if</span>(l &lt;= id &amp;&amp; id &lt;= r)<br>           {<br>               <span class="hljs-built_in">sub</span>(v[id]);<br>               <span class="hljs-built_in">add</span>(w);<br>           }<br>           <span class="hljs-built_in">swap</span>(v[id],w);<span class="hljs-comment">//注意这里是引用，而不是拷贝，拷贝的话swap没有意义，这个点卡了我一下午</span><br>       };<br></code></pre></td></tr></tbody></table></figure><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;deque&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;numeric&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iomanip&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _fio ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb(e) push_back(e)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> all(x) (x).begin(), (x).end()</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> allr(x) (x).rbegin(), (x).rend()</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">'\n'</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> i64 = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">using</span> PII = pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-type">int</span> n,m;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e6</span>+<span class="hljs-number">10</span>;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-type">int</span> kn = <span class="hljs-built_in">pow</span>(n,<span class="hljs-number">0.6666</span>);<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v</span><span class="hljs-params">(N)</span>,<span class="hljs-title">K</span><span class="hljs-params">(N)</span>,<span class="hljs-title">cnt</span><span class="hljs-params">(N)</span></span>;<br>    vector&lt;array&lt;<span class="hljs-type">int</span>,4&gt; &gt; query = {{}};<span class="hljs-comment">//l,r,time,id</span><br>    vector&lt;array&lt;<span class="hljs-type">int</span>,2&gt; &gt; modify = {{}};<span class="hljs-comment">//下标,值</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) cin &gt;&gt; v[i],K[i] = (i<span class="hljs-number">-1</span>)/kn + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i)<br>    {<br>        string s;<span class="hljs-type">int</span> x,y;cin &gt;&gt; s &gt;&gt; x &gt;&gt; y;<br>        <span class="hljs-keyword">if</span>(s == <span class="hljs-string">"Q"</span>) query.<span class="hljs-built_in">push_back</span>({x,y,(<span class="hljs-type">int</span>)modify.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>,(<span class="hljs-type">int</span>)query.<span class="hljs-built_in">size</span>()});<br>        <span class="hljs-keyword">else</span> modify.<span class="hljs-built_in">push_back</span>({x,y});<br>    }<br>    <span class="hljs-built_in">sort</span>(query.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">1</span>,query.<span class="hljs-built_in">end</span>(),[&amp;](<span class="hljs-keyword">auto</span> x,<span class="hljs-keyword">auto</span> y){<br>        <span class="hljs-keyword">if</span>(K[x[<span class="hljs-number">0</span>]] != K[y[<span class="hljs-number">0</span>]]) <span class="hljs-keyword">return</span> x[<span class="hljs-number">0</span>] &lt; y[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">if</span>(K[x[<span class="hljs-number">1</span>]] != K[y[<span class="hljs-number">1</span>]]) <span class="hljs-keyword">return</span> x[<span class="hljs-number">1</span>] &lt; y[<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">return</span> x[<span class="hljs-number">3</span>] &lt; y[<span class="hljs-number">3</span>];<br>    });<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(query.size())</span></span>;<br>    <span class="hljs-type">int</span> l = <span class="hljs-number">1</span>,r = <span class="hljs-number">0</span>,val = <span class="hljs-number">0</span>,t = <span class="hljs-number">0</span>;<span class="hljs-comment">//t为累计修改次数</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;query.<span class="hljs-built_in">size</span>(); ++ i)<br>    {<br>        <span class="hljs-keyword">auto</span> &amp;e = query[i];<br>        <span class="hljs-type">int</span> ql = e[<span class="hljs-number">0</span>],qr = e[<span class="hljs-number">1</span>],qt = e[<span class="hljs-number">2</span>],id = e[<span class="hljs-number">3</span>];<br>        <span class="hljs-keyword">auto</span> add = [&amp;](<span class="hljs-type">int</span> x) -&gt; <span class="hljs-type">void</span> {<br>            <span class="hljs-keyword">if</span>(!cnt[x]) val += <span class="hljs-number">1</span>;<br>            cnt[x] ++ ;<br>        };<br>        <span class="hljs-keyword">auto</span> sub = [&amp;](<span class="hljs-type">int</span> x) -&gt; <span class="hljs-type">void</span> {<br>            cnt[x] -- ;<br>            <span class="hljs-keyword">if</span>(!cnt[x]) val -=<span class="hljs-number">1</span>;<br>        };<br>        <span class="hljs-keyword">auto</span> time = [&amp;](<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r) -&gt; <span class="hljs-type">void</span> {<br>            <span class="hljs-type">int</span> &amp;w = modify[x][<span class="hljs-number">1</span>], id = modify[x][<span class="hljs-number">0</span>];<br>            <span class="hljs-keyword">if</span>(l &lt;= id &amp;&amp; id &lt;= r)<br>            {<br>                <span class="hljs-built_in">sub</span>(v[id]);<br>                <span class="hljs-built_in">add</span>(w);<br>            }<br>            <span class="hljs-built_in">swap</span>(v[id],w);<span class="hljs-comment">//注意这里是引用，而不是拷贝，拷贝的话swap没有意义，这个点卡了我一下午</span><br>        };<br>        <span class="hljs-keyword">while</span> (l &gt; ql) <span class="hljs-built_in">add</span>(v[--l]);<br>        <span class="hljs-keyword">while</span> (r &lt; qr) <span class="hljs-built_in">add</span>(v[++r]);<br>        <span class="hljs-keyword">while</span> (l &lt; ql) <span class="hljs-built_in">sub</span>(v[l++]);<br>        <span class="hljs-keyword">while</span> (r &gt; qr) <span class="hljs-built_in">sub</span>(v[r--]);<br>        <span class="hljs-keyword">while</span> (t &lt; qt) t+=<span class="hljs-number">1</span> ,<span class="hljs-built_in">time</span>(t, ql, qr);<br>        <span class="hljs-keyword">while</span> (t &gt; qt) <span class="hljs-built_in">time</span>(t, ql, qr),t-=<span class="hljs-number">1</span>;<br>        ans[id] = val;<br>    }<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;ans.<span class="hljs-built_in">size</span>();++i) cout &lt;&lt; ans[i] &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>
        </div>
      </div>
    </div>


<h2 id="算法模板"><a href="#算法模板" class="headerlink" title="算法模板"></a>算法模板</h2>
    <div class="fold">
      <div class="fold-title fold-default collapsed" data-toggle="collapse" href="#collapse-6ae3e036" role="button" aria-expanded="false" aria-controls="collapse-6ae3e036">
        <div class="fold-arrow">▶</div>代码部分
      </div>
      <div class="fold-collapse collapse" id="collapse-6ae3e036">
        <div class="fold-content">
          <figure class="highlight c++"><table><tbody><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-type">int</span> n,m;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-type">int</span> kn = <span class="hljs-built_in">pow</span>(n,<span class="hljs-number">0.6666</span>);<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>,<span class="hljs-title">K</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>    vector&lt;array&lt;<span class="hljs-type">int</span>,4&gt;&gt; query = {{}};<span class="hljs-comment">//l,r,time,id</span><br>    vector&lt;array&lt;<span class="hljs-type">int</span>,2&gt;&gt; modify = {{}};<span class="hljs-comment">//下标，值</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) cin &gt;&gt; v[i],K[i] = (i<span class="hljs-number">-1</span>)/kn + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i)<br>    {<br>        string s;<span class="hljs-type">int</span> x,y;cin &gt;&gt; s &gt;&gt; x &gt;&gt; y;<br>        <span class="hljs-keyword">if</span>(s == <span class="hljs-string">"Q"</span>) query.<span class="hljs-built_in">emplace_back</span>(x,y,(<span class="hljs-type">int</span>)modify.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>,(<span class="hljs-type">int</span>)query.<span class="hljs-built_in">size</span>());<br>        <span class="hljs-keyword">else</span> modify.<span class="hljs-built_in">emplace_back</span>(x,y);<br>    }<br>    <span class="hljs-built_in">sort</span>(query.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">1</span>,query.<span class="hljs-built_in">end</span>(),[&amp;](<span class="hljs-keyword">auto</span> x,<span class="hljs-keyword">auto</span> y){<br>        <span class="hljs-keyword">if</span>(K[x[<span class="hljs-number">0</span>]] != K[y[<span class="hljs-number">0</span>]]) <span class="hljs-keyword">return</span> x[<span class="hljs-number">0</span>] &lt; y[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">if</span>(K[x[<span class="hljs-number">1</span>]] != K[y[<span class="hljs-number">1</span>]]) <span class="hljs-keyword">return</span> x[<span class="hljs-number">1</span>] &lt; y[<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">return</span> x[<span class="hljs-number">3</span>] &lt; y[<span class="hljs-number">3</span>];<br>    });<br>    <span class="hljs-type">int</span> l = <span class="hljs-number">1</span>,r = <span class="hljs-number">0</span>,val = <span class="hljs-number">0</span>,t = <span class="hljs-number">0</span>;<span class="hljs-comment">//t为累计修改次数</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;query.<span class="hljs-built_in">size</span>(); ++ i)<br>    {<br>        <span class="hljs-keyword">auto</span> &amp;e = query[i];<br>        <span class="hljs-type">int</span> ql = e[<span class="hljs-number">0</span>],qr = e[<span class="hljs-number">1</span>],qt = e[<span class="hljs-number">2</span>],id = e[<span class="hljs-number">3</span>];<br>        <span class="hljs-keyword">auto</span> add = [&amp;](<span class="hljs-type">int</span> x) -&gt; <span class="hljs-type">void</span> {<br><br>        };<br>        <span class="hljs-keyword">auto</span> sub = [&amp;](<span class="hljs-type">int</span> x) -&gt; <span class="hljs-type">void</span> {<br><br>        };<br>        <span class="hljs-keyword">auto</span> time = [&amp;](<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r) -&gt; <span class="hljs-type">void</span> {<br>            <span class="hljs-type">int</span> &amp;w = modify[x][<span class="hljs-number">1</span>], id = modify[x][<span class="hljs-number">0</span>];<span class="hljs-comment">//记得引用</span><br>            <span class="hljs-keyword">if</span>(l &lt;= id &amp;&amp; id &lt;= r)<br>            {<br>                <span class="hljs-built_in">sub</span>(v[id]);<br>                <span class="hljs-built_in">add</span>(w);<br>            }<br>            <span class="hljs-built_in">swap</span>(v[id],w);<br>        };<br>        <span class="hljs-keyword">while</span> (l &gt; ql) <span class="hljs-built_in">add</span>(w[--l]);<br>        <span class="hljs-keyword">while</span> (r &lt; qr) <span class="hljs-built_in">add</span>(w[++r]);<br>        <span class="hljs-keyword">while</span> (l &lt; ql) <span class="hljs-built_in">sub</span>(w[l++]);<br>        <span class="hljs-keyword">while</span> (r &gt; qr) <span class="hljs-built_in">sub</span>(w[r--]);<br>        <span class="hljs-keyword">while</span> (t &lt; qt) <span class="hljs-built_in">time</span>(++t, ql, qr);<br>        <span class="hljs-keyword">while</span> (t &gt; qt) <span class="hljs-built_in">time</span>(t--, ql, qr);<br>        ans[id] = val;<br>    }<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=ans.<span class="hljs-built_in">size</span>();++i) cout &lt;&lt; ans[i] &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>
        </div>
      </div>
    </div>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>杂项</tag>
      </tags>
  </entry>
  <entry>
    <title>带权并查集</title>
    <url>/posts/dbe7e802/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>带权并查集（Weighted Union-Find）是并查集的一种扩展，它在标准的并查集操作基础上引入了一个权重或者秩的概念，使得每个节点不仅代表一个集合，还记录了该集合的一些额外信息。通常，这个额外信息是与集合中的元素相关联的权重或者秩。</p>
<h2 id="维护距离"><a href="#维护距离" class="headerlink" title="维护距离"></a>维护距离</h2><p>很多带权并查集的题目都是通过维护距离这个额外的元素来求解。<br>现在设 $d[i]$ 数组为第 $i$ 个点到他父节点的距离,一开始，每个点自己就是自己的父节点，所以初始化为0。<br><img src="https://pic.imgdb.cn/item/65aa6ff1871b83018a1c0283.png" alt="img"><br>从图中可以看到，边上面是带有值的，这也是为什么叫做带权并查集。<br>从这张图我们可以列出这4个点对应的 $d[i]$</p>
<ul>
<li>d[1] = 4</li>
<li>d[2] = 0</li>
<li>d[6] = 5</li>
<li>d[5] = 6<br>而往往我们需要的是到根节点的距离,所以我们通过路径压缩，让这个点直接指向根节点，在运行的同时，把新的 $d[i]$ 给算出来。经过路径压缩后，$d[5] = d[5] + d[6] = 11$ ，所以说带权并查集是需要用到路径压缩的。</li>
</ul>
<figure class="highlight gradle"><table><tbody><tr><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">int</span> p[N], d[N]; <span class="hljs-comment">//p[]存储每个点的祖宗节点, d[x]存储x到p[x]的距离</span><br><br>    <span class="hljs-comment">// 返回x的祖宗节点</span><br>    <span class="hljs-keyword">int</span> <span class="hljs-keyword">find</span>(<span class="hljs-keyword">int</span> x)<br>    {<br>        <span class="hljs-keyword">if</span> (p[x] != x)<br>        {<br>            <span class="hljs-keyword">int</span> u = <span class="hljs-keyword">find</span>(p[x]);<br>            d[x] += d[p[x]];<br>            p[x] = u;<br>        }<br>        <span class="hljs-keyword">return</span> p[x];<br>    }<br><br>    <span class="hljs-keyword">void</span> init(<span class="hljs-keyword">int</span> n){<br>    <span class="hljs-comment">// 初始化，假定节点编号是1~n</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>        {<br>            p[i] = i;<br>            d[i] = <span class="hljs-number">0</span>;<br>        }<br>    }<br><br><br>    <span class="hljs-keyword">int</span> px = <span class="hljs-keyword">find</span>(x);<br>    <span class="hljs-keyword">int</span> py = <span class="hljs-keyword">find</span>(y); <br>    <span class="hljs-comment">// 合并a和b所在的两个集合：</span><br>    p[py] = <span class="hljs-keyword">find</span>(y);<br>    d[py] = d[x] - d[y] + s;<br></code></pre></td></tr></tbody></table></figure>

<p>s即为一个偏移量，而偏移量如何去求出来，需要根据题意。</p>
<p>在合并方面，如果是普通的并查集，我们可以选择任意一点直接合并到另一点。但是在带权并查集，我们还需要维护一个额外的信息，这里就是距离。</p>
<p>普通并查集:<br><img src="https://pic.imgdb.cn/item/65aa7007871b83018a1c6935.png" alt="img"></p>
<p>带权并查集:<br><img src="https://pic.imgdb.cn/item/65aa7019871b83018a1cb7d1.png" alt="img"></p>
<p>要是想让$x,y$这两个集合连通我们需要处理好$d[py]$ 这是一个未知量，也是我们需要的。</p>
<p>重点就是如何去计算,这个时候偏移量的出现就为之重要了。 通过图可以发现 $y$到$px$的距离应该是恒定的,所以有: $$s + d[x] = d[y] + d[py]$$<br>所以要想计算$d[py]$就很简单了。<br>$$d[py] = d[x] - d[y] + s$$<br>但是我们只是算出并改变了 $d[py]$ 为什么这样就OK了呢？可以查看我们的$find()$ 函数，只要调用了$find(i)$，那么 $i$ 节点的$d[i]$ 就一定是正确的，并且$i$还会指向根节点,因为我们使用了路径压缩。</p>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题:"></a>例题:</h2><h3 id="食物链"><a href="#食物链" class="headerlink" title="食物链"></a>食物链</h3><p><a href="https://www.luogu.com.cn/problem/P2024">食物链</a> 这道题题目大概是给了三种关系，然后让你判断合法性，最后输出不合法的操作数量。<br><img src="https://pic.imgdb.cn/item/65aa7034871b83018a1d379e.png" alt="img"><br>箭头代表 x-&gt;y  = x会被y吃。</p>
<p>这题用带权并查集来做的时候，$d[i]$ 数组代表距离的同时，里面的值的不同也有特殊含义,所以我们通过$MOD3$来控制距离的大小。</p>
<ul>
<li>0代表，与根节点同一族</li>
<li>1代表，该节点可以吃掉根节点一族</li>
<li>2代表，该节点被根节点一族吃</li>
</ul>
<p>是同类的话，偏移量为0。是不同的话偏移量为1，正负取决于你的x和y谁合并到谁身上。</p>

    <div class="fold">
      <div class="fold-title fold-default collapsed" data-toggle="collapse" href="#collapse-dcdac752" role="button" aria-expanded="false" aria-controls="collapse-dcdac752">
        <div class="fold-arrow">▶</div>代码
      </div>
      <div class="fold-collapse collapse" id="collapse-dcdac752">
        <div class="fold-content">
          <figure class="highlight c++"><table><tbody><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;deque&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;numeric&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iomanip&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _fio \</span><br><span class="hljs-meta">    ios_base::sync_with_stdio(0); \</span><br><span class="hljs-meta">    cin.tie(0); \</span><br><span class="hljs-meta">    cout.tie(0);</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb(e) push_back(e)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> all(x) (x).begin(), (x).end()</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> allr(x) (x).rbegin(), (x).rend()</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">'\n'</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> i64 = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">using</span> PII = pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">DSU</span><br>{<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; p, siz, d;<br>    <span class="hljs-type">int</span> res;<br><br>    <span class="hljs-built_in">DSU</span>() {}<br>    <span class="hljs-built_in">DSU</span>(<span class="hljs-type">int</span> n) { <span class="hljs-built_in">init</span>(n); }<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function">    </span>{<br>        p.<span class="hljs-built_in">resize</span>(n);<br>        std::<span class="hljs-built_in">iota</span>(p.<span class="hljs-built_in">begin</span>(), p.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>);<br>        siz.<span class="hljs-built_in">assign</span>(n, <span class="hljs-number">1</span>);<br>        d.<span class="hljs-built_in">assign</span>(n, <span class="hljs-number">0</span>);<br>    }<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function">    </span>{<br>        <span class="hljs-keyword">if</span> (p[x] != x)<br>        {<br>            <span class="hljs-type">int</span> u = <span class="hljs-built_in">find</span>(p[x]);<br>            d[x] += d[p[x]]; <span class="hljs-comment">// 按情况修改</span><br>            d[x] %= <span class="hljs-number">3</span>;<br>            p[x] = u;<br>        }<br>        <span class="hljs-keyword">return</span> p[x];<br>    }<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">same</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>{ <span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(x) == <span class="hljs-built_in">find</span>(y); }<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> s)</span></span><br><span class="hljs-function">    </span>{<br>        <span class="hljs-type">int</span> px = <span class="hljs-built_in">find</span>(x);<br>        <span class="hljs-type">int</span> py = <span class="hljs-built_in">find</span>(y);<br>        <span class="hljs-keyword">if</span> (px == py) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        siz[px] += siz[py];<br>        p[py] = px;<br>        d[py] = (d[x] - d[y] + s) % <span class="hljs-number">3</span>; <span class="hljs-comment">// s为偏移量，按情况修改</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    }<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">size</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>{ <span class="hljs-keyword">return</span> siz[<span class="hljs-built_in">find</span>(x)]; }<br>};<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-type">int</span> n, m, d, x, y;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-function">DSU <span class="hljs-title">dsu</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br><br>    <span class="hljs-keyword">while</span> (m--)<br>    {<br>        cin &gt;&gt; d &gt;&gt; x &gt;&gt; y;<br><br>        <span class="hljs-keyword">if</span> (x &gt; n || y &gt; n)<br>        {<br>            dsu.res += <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">continue</span>;<br>        }<br><br>        <span class="hljs-type">int</span> px = dsu.<span class="hljs-built_in">find</span>(x);<br>        <span class="hljs-type">int</span> py = dsu.<span class="hljs-built_in">find</span>(y);<br><br>        <span class="hljs-keyword">if</span> (d == <span class="hljs-number">1</span>)<br>        {<br>            <span class="hljs-keyword">if</span> (dsu.<span class="hljs-built_in">same</span>(x, y) &amp;&amp; (dsu.d[x] % <span class="hljs-number">3</span> != dsu.d[y] % <span class="hljs-number">3</span>))<br>                dsu.res++;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!dsu.<span class="hljs-built_in">same</span>(x, y))<br>                dsu.<span class="hljs-built_in">merge</span>(x, y, <span class="hljs-number">3</span>);<br>        }<br>        <span class="hljs-keyword">else</span><br>        {<br>            <span class="hljs-keyword">if</span> (dsu.<span class="hljs-built_in">same</span>(x, y) &amp;&amp; (dsu.d[x] % <span class="hljs-number">3</span> != (dsu.d[y] + <span class="hljs-number">1</span>) % <span class="hljs-number">3</span>))<br>                dsu.res++;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!dsu.<span class="hljs-built_in">same</span>(x, y))<br>                dsu.<span class="hljs-built_in">merge</span>(x, y, <span class="hljs-number">-1</span> + <span class="hljs-number">3</span>);<br>        }<br>    }<br><br>    cout &lt;&lt; dsu.res &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br><br></code></pre></td></tr></tbody></table></figure>
        </div>
      </div>
    </div>

<p>注意关系的判断和偏移量的计算就行了。</p>
<h2 id="封装模板"><a href="#封装模板" class="headerlink" title="封装模板"></a>封装模板</h2><p>改自<a href="/posts/c517589e/" title="并查集">并查集</a></p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">DSUV</span><br>{<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; p, siz, d;<br>    <span class="hljs-built_in">DSUV</span>() {}<br>    <span class="hljs-built_in">DSUV</span>(<span class="hljs-type">int</span> n) { <span class="hljs-built_in">init</span>(n); }<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function">    </span>{<br>        p.<span class="hljs-built_in">resize</span>(n);<br>        std::<span class="hljs-built_in">iota</span>(p.<span class="hljs-built_in">begin</span>(), p.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>);<br>        siz.<span class="hljs-built_in">assign</span>(n, <span class="hljs-number">1</span>);<br>        d.<span class="hljs-built_in">assign</span>(n, <span class="hljs-number">0</span>);<br>    }<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function">    </span>{<br>        <span class="hljs-keyword">if</span> (p[x] != x)<br>        {<br>            <span class="hljs-type">int</span> u = <span class="hljs-built_in">find</span>(p[x]);<br>            d[x] += d[p[x]];<span class="hljs-comment">//情况而定</span><br>            p[x] = u;<br>        }<br>        <span class="hljs-keyword">return</span> p[x];<br>    }<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">same</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>{ <span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(x) == <span class="hljs-built_in">find</span>(y); }<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> s)</span></span><br><span class="hljs-function">    </span>{<br>        <span class="hljs-type">int</span> px = <span class="hljs-built_in">find</span>(x);<br>        <span class="hljs-type">int</span> py = <span class="hljs-built_in">find</span>(y);<br>        <span class="hljs-keyword">if</span> (px == py)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        siz[px] += siz[py];<br>        p[py] = px;<br>        d[py] = (d[x] - d[y] + s);<span class="hljs-comment">//情况而定</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    }<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">size</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>{ <span class="hljs-keyword">return</span> siz[<span class="hljs-built_in">find</span>(x)]; }<br>};<br><br></code></pre></td></tr></tbody></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>图论</tag>
        <tag>并查集</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>并查集</title>
    <url>/posts/c517589e/</url>
    <content><![CDATA[<h2 id="并查集的概念"><a href="#并查集的概念" class="headerlink" title="并查集的概念"></a>并查集的概念</h2><p>并查集是一种用于处理集合合并与查找问题的数据结构。它提供查找（Find）和合并（Merge）两个基本操作。通过维护树形结构，每个树代表一个集合，通过路径压缩和按秩合并等优化，提高查找和合并操作的效率。常用于解决图论、连通性和最小生成树等问题。</p>
<p>简单来说，并查集就是一种能够处理连通性问题的数据结构。</p>
<h2 id="并查集的引入"><a href="#并查集的引入" class="headerlink" title="并查集的引入"></a>并查集的引入</h2><p>假如现在世界上有很多个人，现在设定一个规矩，两个人可以通过比试的输赢来建立一个帮派，赢的就是帮主（如果一个人打败了一个帮派的帮主，那么他就是新帮主，如果只是打败小弟，则需要继续往上,打最早击败过小弟的人），长久如此，通过比试次数越多，帮派就会壮大起来。</p>
<p>现在有 $8$ 个人，他们每一个人都有一个帮派，所以他们现在属于自己的帮派，帮主也是自己。</p>
<p>然后我们假如一个数组 $p$ ,每一个 $p[i]$ 代表的就是打败第 $i$ 位的人，在树形结构里面就是第 $i$ 位人的父节点。</p>
<p>一开始，每个人的$p[i]$ 都是自己，所以图中的边也是指向自己的。<br><img src="https://pic.imgdb.cn/item/65aa7050871b83018a1db7bd.png" alt="img"><br>之后我们安排 $[1]$ 和 $[2]$ 比试， 然后 $[2]$ 获得胜利，所以这个时候 就变成了 $[1]$ 号的 $p[1] = 2$,关系图就变成 $[1]$ 的边会指向 $[2]$ :<br><img src="https://pic.imgdb.cn/item/65aa7063871b83018a1e1010.png" alt="img"><br>之后我们分别安排</p>
<ul>
<li>$[4]$ 和 $[8]$ 比试，$[4]$ 获胜</li>
<li>$[5]$ 和 $[6]$ 比试，$[5]$ 获胜</li>
<li>$[5]$ 和 $[7]$ 比试，$[5]$ 获胜</li>
<li>$[1]$ 和 $[3]$ 比试, $[3]$ 获胜,这个时候$[3]$还要和$[2]$比试，因为$[2]$是帮主,但是这个时候 $[3]$ 输给了 $[2]$<br><img src="https://pic.imgdb.cn/item/65aa7072871b83018a1e56cd.png" alt="img"></li>
</ul>
<p>可以看到现在世界上已经有三个帮派(帮主首位)了，分别是:</p>
<ul>
<li>$[2,1,3]$</li>
<li>$[4,8]$</li>
<li>$[5,6,7]$<br>这时 $p$ 数组的值是</li>
</ul>
<ul>
<li>$p[1] = 2$</li>
<li>$p[2] = 2$</li>
<li>$p[3] = 2$</li>
<li>$p[4] = 4$</li>
<li>$p[5] = 5$</li>
<li>$p[6] = 5$</li>
<li>$p[7] = 5$</li>
<li>$p[8] = 4$</li>
</ul>
<p>现在如果给 $[7]$ 和 $[3]$ 安排一场比试，$[3]$ 赢了，但是还没结束, $[3]$ 还要和最早打败了 $[7]$ 的人比试，即为 $[5]$,之后 $[3]$ 输了,$[5]$ 自然要和$[2]$ 比试一场，之后 $[2]$ 获胜，$[5]$ 带着他帮派的所有人加入 $[2]$ 的麾下。<br><img src="https://pic.imgdb.cn/item/65aa7080871b83018a1e932c.png" alt="img"></p>
<p>然后就此世界上就只剩下两个帮派了。</p>
<h2 id="并查集的两种操作"><a href="#并查集的两种操作" class="headerlink" title="并查集的两种操作"></a>并查集的两种操作</h2><p>首先我们把上面的故事抽象一下，可以发现有两步操作，分别是输了之后，找第一次打败自己的人来继续挑战，然后是比试。</p>
<p>第一种我们可以看做是查找,找帮主，每一个节点都有一个父节点，也正对应了$p[k]$数组。<br>第二种我们可以看做是合并，两个集合之间的合并。</p>
<h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>查找操作用于确定一个元素属于哪个集合，即找到该元素所在集合的代表元素（根节点）。<br>查找操作的目的是判断两个元素是否属于同一个集合，通过比较它们的根节点来实现。</p>
<h3 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h3><p>合并操作用于将两个不相交的集合合并成一个新的集合。<br>具体操作通常是将其中一个集合的根节点连接到另一个集合的根节点上，从而形成一个新的集合。</p>
<h2 id="朴素版"><a href="#朴素版" class="headerlink" title="朴素版"></a>朴素版</h2><p>对于代码的编写，有朴素版，不过我们一般不会采用这种方式，因为效率比较低 $O(n)$</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>初始化主要是初始化 $p[k]$ 数组，初始化就是让每个人的父节点都为自己。</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> p[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) p[i] = i;<br>}<br></code></pre></td></tr></tbody></table></figure>
<h3 id="查找-1"><a href="#查找-1" class="headerlink" title="查找"></a>查找</h3><p>通过递归来找根节点</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-keyword">return</span> p[x] == x ? x : <span class="hljs-built_in">find</span>(p[x]);<br>}<br><br></code></pre></td></tr></tbody></table></figure>
<h3 id="合并-1"><a href="#合并-1" class="headerlink" title="合并"></a>合并</h3><p>只要 $x$ 和 $y$ 不属于同一集合，就需要合并</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function"></span>{<br>    x = <span class="hljs-built_in">find</span>(x);<br>    y = <span class="hljs-built_in">find</span>(y);<br>    <span class="hljs-keyword">if</span>(x == y) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    p[y] = x;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>

<h2 id="路径压缩"><a href="#路径压缩" class="headerlink" title="路径压缩"></a>路径压缩</h2><p>路径压缩的思想是在查找操作中，将查找路径上的每个节点都直接连接到根节点。这样，即使树的高度很大，任何一次查找操作都会使路径上的每个节点都直接指向根节点。这种操作会在实际查找的同时，通过修改树的结构，使得未来的查找操作变得更加高效。</p>
<p>大概就是在$find$的过程中，改变这个节点否父节点，最终让所有节点直接指向根节点。<br>路径压缩前:<br><img src="https://pic.imgdb.cn/item/65aa7091871b83018a1edf66.png" alt="img"><br>经过路径压缩后:<br><img src="https://pic.imgdb.cn/item/65aa70a3871b83018a1f3ac2.png" alt="img"></p>
<p>其实就是改一下 $find$ 函数,写法不唯一。</p>
<p>查询的时间复杂度近乎为$O(1)$</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> p[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) p[i] = i;<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span><span class="hljs-comment">//递归1版</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-keyword">return</span> (p[x] != x) ? (p[x] = <span class="hljs-built_in">find</span>(p[x])) : p[x];<br>    <br>}<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span><span class="hljs-comment">//递归2版</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-keyword">return</span> p[x] = (p[x] == x ? x : <span class="hljs-built_in">find</span>(p[x]));<br>}<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span><span class="hljs-comment">//循环版</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-keyword">while</span>(p[x] != x) x = p[x] = p[p[x]];<br>    <span class="hljs-keyword">return</span> x;<br>}<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function"></span>{<br>    x = <span class="hljs-built_in">find</span>(x);<br>    y = <span class="hljs-built_in">find</span>(y);<br>    <span class="hljs-keyword">if</span>(x == y) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    p[y] = x;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>

<h2 id="按秩合并"><a href="#按秩合并" class="headerlink" title="按秩合并"></a>按秩合并</h2><p>在朴素版本的并查集中，合并操作简单地将一个集合的根节点连接到另一个集合的根节点上。然而，这样的操作可能会导致一些集合的树深度增加，形成不平衡的树。这种情况下，查找操作可能会变得较慢，因为树的高度会增加。</p>
<p>按秩合并的基本思想是在合并操作时，将深度（秩）较小的树合并到深度较大的树上。这样可以避免形成过深的树，保持树的平衡，进而提高查找和合并操作的效率。通常，每个节点都会维护一个秩的信息，表示以该节点为根的树的深度。</p>
<p>所以我们引入一个新的数组 $rnk[i]$ 代表第 $i$ 节点的高度。</p>
<p>这个优化只体现在merge操作上面</p>
<p>查询的时间复杂度为$O(logn)$</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> p[N],rnk[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) p[i] = i;<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-keyword">return</span> p[x] == x ? x : <span class="hljs-built_in">find</span>(p[x]);<br>}<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function"></span>{<br>    x = <span class="hljs-built_in">find</span>(x);<br>    y = <span class="hljs-built_in">find</span>(y);<br>    <span class="hljs-keyword">if</span> (x == y) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (rnk[y] &gt; rnk[x]) <span class="hljs-built_in">swap</span>(x, y);<span class="hljs-comment">//保证 x 的高度 &gt;= y</span><br>    <span class="hljs-keyword">if</span> (rnk[x] == rnk[y]) rnk[x]++;<br>    p[y] = x;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>

<h2 id="启发式合并-通过大小"><a href="#启发式合并-通过大小" class="headerlink" title="启发式合并(通过大小)"></a>启发式合并(通过大小)</h2><p>通过大小的启发式合并是一种并查集优化策略，它基于集合大小（元素个数）来决定两个集合的合并方式。该启发式合并方法的核心思想是将元素较少的集合合并到元素较多的集合中，以保持树的平衡。</p>
<p>通过这样的合并策略，较小的树被合并到较大的树中，从而避免了形成过深的树。这有助于降低查找操作的时间复杂度，使得树的高度保持在相对较小的范围内，提高了整个并查集的效率。</p>
<p>所以我们引入一个新的数组 $siz[i]$ 代表第 $i$ 个集合的大小,注意的一点是,$siz[i]$ 只在根节点是有效的。</p>
<p>这个优化只体现在merge操作上面</p>
<p>查询的时间复杂度为$O(logn)$</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> p[N],siz[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) p[i] = i,siz[i] = <span class="hljs-number">1</span>;<span class="hljs-comment">//注意这里siz数组要初始化为1</span><br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-keyword">return</span> p[x] == x ? x : <span class="hljs-built_in">find</span>(p[x]);<br>}<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function"></span>{<br>    x = <span class="hljs-built_in">find</span>(x);<br>    y = <span class="hljs-built_in">find</span>(y);<br>    <span class="hljs-keyword">if</span> (x == y) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (siz[y] &gt; siz[x]) <span class="hljs-built_in">swap</span>(x, y);<span class="hljs-comment">//保证 x 的集合数量大小 &gt;= y</span><br>    p[y] = x;<br>    siz[x] += siz[y];<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>这三种优化都是我们平常经常写的优化方式，不过最常用的应该是路径压缩，毕竟代码更加简洁。但是在$Tarjan$的论文中，证明了只使用路径压缩的最坏复杂度为$O(mlogn)$，不过这种数据我们一般不会遇到，除非出题人水平很高，然后专门出数据卡并查集。所以三种方式都需要掌握，三种优化方式是可以混用的。</p>
<h2 id="封装模板"><a href="#封装模板" class="headerlink" title="封装模板"></a>封装模板</h2><p>借鉴的是jls的板子，稍有改动。</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">DSU</span><br>{<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; p, siz;<br>    <span class="hljs-built_in">DSU</span>() {}<br>    <span class="hljs-built_in">DSU</span>(<span class="hljs-type">int</span> n) { <span class="hljs-built_in">init</span>(n); }<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function">    </span>{<br>        p.<span class="hljs-built_in">resize</span>(n);<br>        std::<span class="hljs-built_in">iota</span>(p.<span class="hljs-built_in">begin</span>(), p.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>);<br>        siz.<span class="hljs-built_in">assign</span>(n, <span class="hljs-number">1</span>);<br>    }<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function">    </span>{<br>        <span class="hljs-keyword">while</span> (x != p[x])<br>        {<br>            x = p[x] = p[p[x]];<br>        }<br>        <span class="hljs-keyword">return</span> x;<br>    }<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">same</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>{ <span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(x) == <span class="hljs-built_in">find</span>(y); }<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function">    </span>{<br>        <span class="hljs-type">int</span> px = <span class="hljs-built_in">find</span>(x);<br>        <span class="hljs-type">int</span> py = <span class="hljs-built_in">find</span>(y);<br>        <span class="hljs-keyword">if</span> (px == py)<br>        {<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        }<br>        siz[px] += siz[py];<br>        p[py] = px;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    }<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">size</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>{ <span class="hljs-keyword">return</span> siz[<span class="hljs-built_in">find</span>(x)]; }<br>};<br></code></pre></td></tr></tbody></table></figure>

<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://www.luogu.com.cn/problem/P3367">P3367 【模板】并查集 - 洛谷 </a></p>
<h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><a href="/posts/dbe7e802/" title="带权并查集">带权并查集</a>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>图论</tag>
        <tag>并查集</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>树状数组</title>
    <url>/posts/59a0de58/</url>
    <content><![CDATA[<h2 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h2><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>普通树状数组维护的信息及运算要满足&nbsp;<strong>结合律</strong>&nbsp;且&nbsp;<strong>可差分</strong>，如加法（和）、乘法（积）、异或等。<br>需要注意的是:</p>
<ul>
<li>模意义下的乘法若要可差分，需保证每个数都存在逆元（模数为质数时一定存在）；</li>
<li>例如$gcd,max$ 这些信息不可差分，所以不能用普通树状数组处理,但是<ul>
<li>使用两个树状数组可以用于处理区间最值,详情见<a href="https://ioi.te.lv/oi/files/volume9.pdf#page=41">volume9.pdf (te.lv)</a></li>
<li>对于不可差分的信息查询，有一种$Olog(^2n)$的拓展树状数组</li>
</ul>
</li>
</ul>
<p>事实上，树状数组能解决的问题是线段树能解决的问题的子集：树状数组能做的，线段树一定能做；线段树能做的，树状数组不一定可以。然而，树状数组的代码要远比线段树短，时间效率常数也更小，因此仍有学习价值。</p>
<h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><h4 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h4><a href="/posts/37060/" title="前缀和与差分">前缀和与差分</a>
<h4 id="lowbit"><a href="#lowbit" class="headerlink" title="lowbit"></a>lowbit</h4><p>lowbit函数会求出一个二进制数字的最低位代表的那个数字</p>
<p>这是20的二进制 :$0010100$<br>而要获取最低的 $0000100$ 可以取反再加一变成 $1101100$ 之后再 进行按位与操作即可得到0010100 &amp;  1101100 = 0000100<br>因为在计算机中有补码的存在所以取反加1其实就是对应的负数，所以lowbit函数的写法即为:</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>{<br>	<span class="hljs-keyword">return</span> x &amp; -x;<br>}<br></code></pre></td></tr></tbody></table></figure>

<h3 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h3><p>给出一个长度为n的数组，完成以下两种操作</p>
<ul>
<li>将第x个数加上k</li>
<li>输出区间<code>[l,r]</code>内每个数的和</li>
</ul>
<h4 id="朴素做法"><a href="#朴素做法" class="headerlink" title="朴素做法"></a>朴素做法</h4><p>朴素做法单点修改的时间复杂度是 $O(1)$ ,但是查询区间和的时间复杂度是 $O(n)$ 所以如果有 $n$ 次询问的话，时间复杂度为 $O(n^2)$ 。</p>
<h4 id="前缀和做法"><a href="#前缀和做法" class="headerlink" title="前缀和做法"></a>前缀和做法</h4><p>前缀和做法在查询区间和的时间复杂度是 $O(1)$ ,但是因为需要单点修改，导致修改一次就需要重新预处理一次，时间复杂度为 $O(n)$ 所以如果有n次修改，同样时间复杂度为 $O(n^2)$</p>
<h4 id="树状数组介绍"><a href="#树状数组介绍" class="headerlink" title="树状数组介绍"></a>树状数组介绍</h4><p>而树状数组这一数据结构，可以很好解决这个问题，它在修改和查询上时间复杂度都为 $O(logn)$ 所以n次询问也仅仅只有 $O(nlogn)$ 。一般在 $10^6$的数据规模下使用。</p>
<h3 id="推导过程"><a href="#推导过程" class="headerlink" title="推导过程"></a>推导过程</h3><p>假如数组目前是为当前这个状态:<br><img src="https://pic.imgdb.cn/item/65f304cc9f345e8d03ec5fb1.png" alt="img"><br>如果朴素做法是很慢的，我们可能会想到一个优化，即为让它们两两求和，保存起来，这样在求和的时候可以节约一半的时间，修改数据的时候也只是会多修改一个数字而已:<br><img src="https://pic.imgdb.cn/item/65f305a49f345e8d03f27999.png" alt="img"><br>以此类推，我们可以得到这样的一张图:<br><img src="https://pic.imgdb.cn/item/65f305d29f345e8d03f3ebf0.png" alt="img"><br>这样我们在求前缀和的时候可以很简单的利用这些额外的速度快速的求出来，也是所谓的空间换时间了，但是通过观察我们可以发现表当中有一些数据是没有用的，或者说不是必须的。比如第二行的第一个5，我们在计算 $[3,4]$的区间和的时候，可以用 $19 - 14$ 来计算。所有层的第偶数个数字都是没用的，即使去掉也不影响:<br><img src="https://pic.imgdb.cn/item/65f307c29f345e8d03008863.png" alt="img"><br>然后观察剩下的数，可以发现正好有 $n$ 个，所以我们可以把这些数按照最靠右的位置放进一个数组,称为b数组:</p>
<p><img src="https://pic.imgdb.cn/item/65f3084d9f345e8d03047aac.png" alt="img"><br>所以在求前缀和时，我们只需要找到对应的几个区间，把这些区间相加即可找到答案。<br>修改某个数据时，我们也只需要向上找到包含它的区间进行修改即可。</p>
<p>我们把每行的区间长度列出来，并观察其下标的$lowbit$ 可以发现是相同的:<br><img src="https://pic.imgdb.cn/item/65f309899f345e8d030c4103.png" alt="img"><br>例如 <code>b[12]</code>，长度正好为lowbit(12) -&gt; bin(1100)</p>
<p>如果我们要计算前14个元素的和，可以得到lowbit(14) = 12,所以就可以通过计算前12个的和，然后再加上<code>b[14]</code>就好了。</p>
<p>还有一个性质即为 序列<code>b[i]</code> 正上方的序列，正好就是 <code>b[i + lowbit(i) ]</code>,所以我们在修改某一个位置的时候，就可以通过这个性质找到上方的序列，并进行修改。</p>
<p>这样我们便能很简单的写出查询和修改的代码:</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ask</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span><span class="hljs-comment">//查询x的前缀和</span></span><br><span class="hljs-function">&nbsp; &nbsp; </span>{<br>&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">for</span> (; x; x -= <span class="hljs-built_in">lowbit</span>(x))<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ans += b[x];<br>&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">return</span> ans;<br>&nbsp; &nbsp; }<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ask</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function">&nbsp; &nbsp; </span>{ <span class="hljs-comment">// 区间查询</span><br>&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">return</span> <span class="hljs-built_in">ask</span>(y) - <span class="hljs-built_in">ask</span>(x - <span class="hljs-number">1</span>);<br>&nbsp; &nbsp; }<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> k)</span><span class="hljs-comment">//在x位置上加上k</span></span><br><span class="hljs-function">&nbsp; &nbsp; </span>{<br>&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">for</span> (; x &lt;= n; x += <span class="hljs-built_in">lowbit</span>(x))<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; b[x] += k;<br>&nbsp; &nbsp; }<br><br></code></pre></td></tr></tbody></table></figure>

<h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><h4 id="区间修改-单点查询"><a href="#区间修改-单点查询" class="headerlink" title="区间修改|单点查询"></a>区间修改|单点查询</h4><p>普通的树状数组可以实现</p>
<ul>
<li>区间查询</li>
<li>单点修改<br>但是想要可以区间修改和单点查询该怎么办，我们可以利用差分来做，因为差分是前缀和的逆运算。<br>所以我们要是维护的是一个差分数组，这样对单点修改就等同于对区间修改，同样的查询前缀和的时候也等同于查单点的原数据。</li>
</ul>
<h5 id="单点查询"><a href="#单点查询" class="headerlink" title="单点查询"></a>单点查询</h5><p>设原数组为<code>a[i]</code>,设的<code>d[i] = a[i] - a[i-1] (a[0] = 0)</code> ，则$a[i] = \sum_{j = 1}^{i}d[j]$ ,可以通过<code>d[i]</code>的前缀和查询。</p>
<h5 id="区间修改"><a href="#区间修改" class="headerlink" title="区间修改"></a>区间修改</h5><p>当给区间<code>[l,r]</code>加上<code>x</code>的时候，<code>a[l]</code>与前一个元素<code>a[l-1]</code>增加了 $x$ ,<code>a[r + 1]</code> 与 <code>a[r]</code>的差减少了$x$。根据<code>d[i]</code>数组的定义，只需要给<code>d[l]</code>加上$x$，给<code>d[r+1]</code>减去$x$,即可。</p>
<p>所以便有了单点查询和区间修改:</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> k)</span></span><br><span class="hljs-function">&nbsp; &nbsp; </span>{<br>&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">for</span> (; x &lt;= n; x += x &amp; -x)<br>&nbsp; &nbsp; &nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; w[x] += k;<br>&nbsp; &nbsp; &nbsp; &nbsp; }<br>&nbsp; &nbsp; }<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> k)</span></span><br><span class="hljs-function"></span>{ <span class="hljs-comment">// 区间修改</span><br>&nbsp; &nbsp; <span class="hljs-built_in">add</span>(x, k), <span class="hljs-built_in">add</span>(y, -k);<br>}<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ask</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>{<br>&nbsp; &nbsp; <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>&nbsp; &nbsp; <span class="hljs-keyword">for</span> (; x; x -= x &amp; -x)<br>&nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; &nbsp;ans += w[x];<br>&nbsp; &nbsp; }<br>&nbsp; &nbsp; <span class="hljs-keyword">return</span> ans;<br>}<br></code></pre></td></tr></tbody></table></figure>

<h4 id="区间修改-区间查询"><a href="#区间修改-区间查询" class="headerlink" title="区间修改|区间查询"></a>区间修改|区间查询</h4><p>这是最常见的部分，也是线段树写着最麻烦的部分，但是我们可以用树状数组实现。<br>我们基于上面差分的思路，考虑一下如何构建前缀和。</p>
<ul>
<li>$a_1 = d_1$</li>
<li>$a_2 = d_1 + d_2$</li>
<li>$a_3 = d_1 + d_2 + d_3$</li>
<li>$a_4 = d_1 + d_2 + d_3 + d_4$</li>
<li>$a_n = d_1 + d_2 + … + d_{n-1} +d_n$<br>观察原数组$a$而言，单点查询就是$d$数组的前缀和。<br>我们可以把这个表补全变成<br><img src="https://pic.imgdb.cn/item/65f7d7c99f345e8d038289bb.png" alt="img"><br>设$s_n$为$a_n$的前缀和:$$s_n = \sum_{i = 1}^{n}d_i * (n + 1) - \sum_{i=1}^{n}i*d_i$$<br>所以我们需要额外维护一个树状数组$i * d_i$ 这样使用两个树状数组就可以实现区间查询了，区间修改的话，就和使用差分的思路的时候是一样的。<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function">i64 <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>{<br>&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span>(tr1, x) * (x + <span class="hljs-number">1</span>) - <span class="hljs-built_in">sum</span>(tr2, x);<br>&nbsp; &nbsp; }<br></code></pre></td></tr></tbody></table></figure></li>
</ul>
<h3 id="二维树状数组"><a href="#二维树状数组" class="headerlink" title="二维树状数组"></a>二维树状数组</h3><p> 二维树状数组，也被称作树状数组套树状数组，用来维护二维数组上的单点修改和前缀信息问题。<br> 这里暂时只给出封装模板<br> 
    </p><div class="fold">
      <div class="fold-title fold-default collapsed" data-toggle="collapse" href="#collapse-05eef982" role="button" aria-expanded="false" aria-controls="collapse-05eef982">
        <div class="fold-arrow">▶</div>代码
      </div>
      <div class="fold-collapse collapse" id="collapse-05eef982">
        <div class="fold-content">
          <figure class="highlight c++"><table><tbody><tr><td class="code"><pre><code class="hljs c++"> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BIT_2D</span> {<br>    <span class="hljs-type">int</span> n, m;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; b1, b2, b3, b4;<br>    <br>    <span class="hljs-built_in">BIT_2D</span>(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> m) : <span class="hljs-built_in">n</span>(n), <span class="hljs-built_in">m</span>(m) {<br>        b1.<span class="hljs-built_in">resize</span>(n + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m + <span class="hljs-number">1</span>));<br>        b2.<span class="hljs-built_in">resize</span>(n + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m + <span class="hljs-number">1</span>));<br>        b3.<span class="hljs-built_in">resize</span>(n + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m + <span class="hljs-number">1</span>));<br>        b4.<span class="hljs-built_in">resize</span>(n + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m + <span class="hljs-number">1</span>));<br>    }<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">auto</span> &amp;w, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> k)</span> </span>{ <span class="hljs-comment">// 单点修改</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = x; i &lt;= n; i += i &amp; -i) {<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = y; j &lt;= m; j += j &amp; -j) {<br>                w[i][j] += k;<br>            }<br>        }<br>    }<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> k)</span> </span>{ <br>        <span class="hljs-built_in">add</span>(b1, x, y, k);<br>        <span class="hljs-built_in">add</span>(b2, x, y, k * (x - <span class="hljs-number">1</span>));<br>        <span class="hljs-built_in">add</span>(b3, x, y, k * (y - <span class="hljs-number">1</span>));<br>        <span class="hljs-built_in">add</span>(b4, x, y, k * (x - <span class="hljs-number">1</span>) * (y - <span class="hljs-number">1</span>));<br>    }<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> X, <span class="hljs-type">int</span> Y, <span class="hljs-type">int</span> k)</span> </span>{ <span class="hljs-comment">// 区块修改：二维差分</span><br>        X++, Y++;<br>        <span class="hljs-built_in">add</span>(x, y, k), <span class="hljs-built_in">add</span>(X, y, -k);<br>        <span class="hljs-built_in">add</span>(X, Y, k), <span class="hljs-built_in">add</span>(x, Y, -k);<br>    }<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ask</span><span class="hljs-params">(<span class="hljs-keyword">auto</span> &amp;w, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>{ <span class="hljs-comment">// 单点查询</span><br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = x; i; i -= i &amp; -i) {<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = y; j; j -= j &amp; -j) {<br>                ans += w[i][j];<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> ans;<br>    }<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ask</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>{ <br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        ans += x * y * <span class="hljs-built_in">ask</span>(b1, x, y);<br>        ans -= y * <span class="hljs-built_in">ask</span>(b2, x, y);<br>        ans -= x * <span class="hljs-built_in">ask</span>(b3, x, y);<br>        ans += <span class="hljs-built_in">ask</span>(b4, x, y);<br>        <span class="hljs-keyword">return</span> ans;<br>    }<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ask</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> X, <span class="hljs-type">int</span> Y)</span> </span>{ <span class="hljs-comment">// 区块查询：二维前缀和</span><br>        x--, y--;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">ask</span>(X, Y) - <span class="hljs-built_in">ask</span>(x, Y) - <span class="hljs-built_in">ask</span>(X, y) + <span class="hljs-built_in">ask</span>(x, y);<br>    }<br>};<br><br></code></pre></td></tr></tbody></table></figure>
        </div>
      </div>
    </div><p></p>
<h3 id="封装代码"><a href="#封装代码" class="headerlink" title="封装代码"></a>封装代码</h3><h4 id="基础封装"><a href="#基础封装" class="headerlink" title="基础封装"></a>基础封装</h4>
    <div class="fold">
      <div class="fold-title fold-default collapsed" data-toggle="collapse" href="#collapse-90469042" role="button" aria-expanded="false" aria-controls="collapse-90469042">
        <div class="fold-arrow">▶</div>代码
      </div>
      <div class="fold-collapse collapse" id="collapse-90469042">
        <div class="fold-content">
          <figure class="highlight c++"><table><tbody><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">BIT</span><br>{<br>&nbsp; &nbsp; <span class="hljs-type">int</span> n;<br>&nbsp; &nbsp; vector&lt;<span class="hljs-type">int</span>&gt; w;<br>&nbsp; &nbsp; <span class="hljs-built_in">BIT</span>(<span class="hljs-type">int</span> n)<br>&nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">this</span>-&gt;n = n; <span class="hljs-comment">// 这里必须写 n ，否则会RE</span><br>&nbsp; &nbsp; &nbsp; &nbsp; w.<span class="hljs-built_in">resize</span>(n + <span class="hljs-number">1</span>);<br>&nbsp; &nbsp; }<br>&nbsp; &nbsp; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> k)</span></span><br><span class="hljs-function">&nbsp; &nbsp; </span>{<br>&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">for</span> (; x &lt;= n; x += x &amp; -x)<br>&nbsp; &nbsp; &nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; w[x] += k;<br>&nbsp; &nbsp; &nbsp; &nbsp; }<br>&nbsp; &nbsp; }<br><br>&nbsp; &nbsp; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> k)</span></span><br><span class="hljs-function">&nbsp; &nbsp; </span>{ <span class="hljs-comment">// 区间修改</span><br>&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-built_in">add</span>(x, k), <span class="hljs-built_in">add</span>(y, -k);<br>&nbsp; &nbsp; }<br>&nbsp; &nbsp; <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ask</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function">&nbsp; &nbsp; </span>{<br>&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">for</span> (; x; x -= x &amp; -x)<br>&nbsp; &nbsp; &nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ans += w[x];<br>&nbsp; &nbsp; &nbsp; &nbsp; }<br>&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">return</span> ans;<br>&nbsp; &nbsp; }<br>&nbsp; &nbsp; <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ask</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function">&nbsp; &nbsp; </span>{ <span class="hljs-comment">// 区间查询</span><br>&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">return</span> <span class="hljs-built_in">ask</span>(y) - <span class="hljs-built_in">ask</span>(x - <span class="hljs-number">1</span>);<br>&nbsp; &nbsp; }<br>};<br></code></pre></td></tr></tbody></table></figure>
        </div>
      </div>
    </div>
<h4 id="升级封装"><a href="#升级封装" class="headerlink" title="升级封装"></a>升级封装</h4><p>支持区间修改，区间求和，单点修改，单点查询。</p>

    <div class="fold">
      <div class="fold-title fold-default collapsed" data-toggle="collapse" href="#collapse-ee3b64fe" role="button" aria-expanded="false" aria-controls="collapse-ee3b64fe">
        <div class="fold-arrow">▶</div>代码
      </div>
      <div class="fold-collapse collapse" id="collapse-ee3b64fe">
        <div class="fold-content">
          <figure class="highlight c++"><table><tbody><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">S_BIT</span><br>{<br><span class="hljs-keyword">private</span>:<br>&nbsp; &nbsp; <span class="hljs-type">int</span> n;<br>&nbsp; &nbsp; vector&lt;i64&gt; tr1, tr2;<br>&nbsp; &nbsp; <span class="hljs-function">i64 <span class="hljs-title">lowbit</span><span class="hljs-params">(i64 x)</span></span><br><span class="hljs-function">&nbsp; &nbsp; </span>{<br>&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">return</span> x &amp; -x;<br>&nbsp; &nbsp; }<br>&nbsp; &nbsp; <span class="hljs-type">void</span> __add(vector&lt;i64&gt; &amp;tr, <span class="hljs-type">int</span> x, i64 k)<br>&nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">for</span> (; x &lt;= n; x += <span class="hljs-built_in">lowbit</span>(x))<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tr[x] += k;<br>&nbsp; &nbsp; }<br>&nbsp; &nbsp; i64 __ask(<span class="hljs-type">const</span> vector&lt;i64&gt; &amp;tr, <span class="hljs-type">int</span> x)<br>&nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; &nbsp; i64 res = <span class="hljs-number">0</span>;<br>&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">for</span> (; x; x -= <span class="hljs-built_in">lowbit</span>(x))<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res += tr[x];<br>&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">return</span> res;<br>&nbsp; &nbsp; }<br>&nbsp; &nbsp; i64 __sum(<span class="hljs-type">int</span> x)<br>&nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">return</span> __ask(tr1, x) * (x + <span class="hljs-number">1</span>) - __ask(tr2, x);<br>&nbsp; &nbsp; }<br><span class="hljs-keyword">public</span>:<br>&nbsp; &nbsp; <span class="hljs-built_in">S_BIT</span>(<span class="hljs-type">int</span> size) : <span class="hljs-built_in">n</span>(size), <span class="hljs-built_in">tr1</span>(size + <span class="hljs-number">1</span>), <span class="hljs-built_in">tr2</span>(size + <span class="hljs-number">1</span>) {}<br>&nbsp; &nbsp; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span></span><br><span class="hljs-function">&nbsp; &nbsp; </span>{<br>&nbsp; &nbsp; &nbsp; &nbsp; tr1.<span class="hljs-built_in">clear</span>();<br>&nbsp; &nbsp; &nbsp; &nbsp; tr2.<span class="hljs-built_in">clear</span>();<br>&nbsp; &nbsp; }<br>&nbsp; &nbsp; <span class="hljs-function">i64 <span class="hljs-title">ask</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span><span class="hljs-comment">//区间查询</span></span><br><span class="hljs-function">&nbsp; &nbsp; </span>{<br>&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">return</span> __sum(r) - __sum(l - <span class="hljs-number">1</span>);<br>&nbsp; &nbsp; }<br>&nbsp; &nbsp; <span class="hljs-function">i64 <span class="hljs-title">ask</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span><span class="hljs-comment">//单点查询</span></span><br><span class="hljs-function">&nbsp; &nbsp; </span>{<br>&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">return</span> <span class="hljs-built_in">ask</span>(x, x);<br>&nbsp; &nbsp; }<br>&nbsp; &nbsp; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, i64 v)</span><span class="hljs-comment">//区间修改，注意差分</span></span><br><span class="hljs-function">&nbsp; &nbsp; </span>{<br>&nbsp; &nbsp; &nbsp; &nbsp; __add(tr1, x, v);<br>&nbsp; &nbsp; &nbsp; &nbsp; __add(tr1, y, -v);<br>&nbsp; &nbsp; &nbsp; &nbsp; __add(tr2, x, v * x);<br>&nbsp; &nbsp; &nbsp; &nbsp; __add(tr2, y, -v * y);<br>&nbsp; &nbsp; }<br>&nbsp; &nbsp; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x, i64 v)</span><span class="hljs-comment">//单点修改</span></span><br><span class="hljs-function">&nbsp; &nbsp; </span>{<br>&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-built_in">add</span>(x, x+<span class="hljs-number">1</span>, v);<br>&nbsp; &nbsp; }<br>};<br></code></pre></td></tr></tbody></table></figure>
        </div>
      </div>
    </div>

<h3 id="练习题目"><a href="#练习题目" class="headerlink" title="练习题目"></a>练习题目</h3><p><a href="https://www.luogu.com.cn/problem/P3374">P3374 【模板】树状数组 1 </a> 模板题<br><a href="https://www.luogu.com.cn/problem/P3368">P3368 【模板】树状数组 2 </a> 区间修改，单点查询，维护差分模板题<br><a href="https://www.luogu.com.cn/problem/P5057">P5057 [CQOI2006] 简单题</a>区间修改，单点查询，维护差分模板题<br><a href="https://www.luogu.com.cn/problem/P2068">P2068 统计和</a>模板题，记得long long<br><a href="https://www.luogu.com.cn/problem/P4939">P4939 Agent2</a>区间修改，单点查询，维护差分模板题<br><a href="https://www.luogu.com.cn/problem/P2357">P2357 守墓人</a> 全操作<br><a href="https://www.luogu.com.cn/problem/P1972">P1972 [SDOI2009] HH的项链</a>区间种类个数</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title>拓展域并查集</title>
    <url>/posts/b6627a60/</url>
    <content><![CDATA[<h2 id="拓展并查集的概念"><a href="#拓展并查集的概念" class="headerlink" title="拓展并查集的概念"></a>拓展并查集的概念</h2><p>拓展并查集（Union-Find with Extensions）是对标准并查集（Union-Find）的一种扩展，旨在解决更复杂的问题。</p>
<p>拓展域并查集解决了一种多个有相互关系的并查集，放在一起考虑的问题。一般的并查集应用一般就是判断在不在一个集合，拓展域并查集讲的是多个集合，之间有相互关系一般为相互排斥关系，判断是否在一个集合等。</p>
<h2 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h2><p>为了解决多种关系相互的问题，我们需要更多的空间来维护。</p>
<p>假如我现在有两种关系，友好和敌对，那么我就需要开两倍的空间$p[2 * n]$其中$p[i]$存储的与i是友好关系的,$p[i + n]$ 存储的是与i是敌对关系的。</p>
<p>以此类推:</p>
<ul>
<li>$p[a]$存储与a同类的</li>
<li>$p[a+1*n]$存储与a发生第一类关系的</li>
<li>$p[a+2*n]$存储与a发生第二类关系的</li>
<li>$p[a+3*n]$存储与a发生第三类关系的</li>
<li>….</li>
</ul>
<p>通过这些关系之间的联系，可以很方便的求解。</p>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="食物链"><a href="#食物链" class="headerlink" title="食物链"></a>食物链</h3><p>我们还是通过<a href="https://www.luogu.com.cn/problem/P2024">食物链</a>这题来看，这道题有三种关系,同类，食物，天敌。<br><img src="https://pic.imgdb.cn/item/65aa6fd1871b83018a1b6749.png" alt="img"><br>我們分別用$x$代表同类，$x + n$代表食物，$x + n + n $代表天敌。</p>
<p>当我们要判断$x,y$ 是同类这句话是否是假话时，我们要把如果是假话的情况列举出来：</p>
<ul>
<li>x的食物是y</li>
<li>x的天敌是y<br>这两种情况就是假话，对应代码即为$same(x + n,y) , same(x + n + n,y)$两种任意一种成立即为假话。<br>如果是真话的话，就把 这三类都要$merge$一下</li>
<li>merge(x,y),</li>
<li>merge(x + n,y + n),</li>
<li>merge(x + n + n,y + n + n)</li>
</ul>
<p>因为x和y是同类的话，他们的食物肯定是同类，他们的天敌肯定是同类。</p>
<p>当我们要判断 $x$ 吃 $y$ 也就是说$y$是$x$的食物,$x$是$y$的天敌。<br>这句话为假时，情况是:</p>
<ul>
<li>x 和 y 同类</li>
<li>y 是 x 的天敌</li>
</ul>
<p>如果这句话是真话，那么我们合并</p>
<ul>
<li>merge(x + n , y)</li>
<li>merge(x + n + n, y + n)</li>
<li>merge(x , y + n + n)</li>
</ul>
<p>可以和<a href="/posts/dbe7e802/" title="带权并查集">带权并查集</a>里面的比较一下。</p>

    <div class="fold">
      <div class="fold-title fold-default collapsed" data-toggle="collapse" href="#collapse-8f7bdefe" role="button" aria-expanded="false" aria-controls="collapse-8f7bdefe">
        <div class="fold-arrow">▶</div>代码
      </div>
      <div class="fold-collapse collapse" id="collapse-8f7bdefe">
        <div class="fold-content">
          <figure class="highlight c++"><table><tbody><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;deque&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;numeric&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iomanip&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _fio                      \</span><br><span class="hljs-meta">	ios_base::sync_with_stdio(0); \</span><br><span class="hljs-meta">	cin.tie(0);                   \</span><br><span class="hljs-meta">	cout.tie(0);</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb(e) push_back(e)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> all(x) (x).begin(), (x).end()</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> allr(x) (x).rbegin(), (x).rend()</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">'\n'</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> i64 = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">using</span> PII = pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">DSU</span><br>{<br>	std::vector&lt;<span class="hljs-type">int</span>&gt; p, siz;<br>	<span class="hljs-built_in">DSU</span>() {}<br>	<span class="hljs-built_in">DSU</span>(<span class="hljs-type">int</span> n) { <span class="hljs-built_in">init</span>(n); }<br>	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function">	</span>{<br>		p.<span class="hljs-built_in">resize</span>(n);<br>		std::<span class="hljs-built_in">iota</span>(p.<span class="hljs-built_in">begin</span>(), p.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>);<br>		siz.<span class="hljs-built_in">assign</span>(n, <span class="hljs-number">1</span>);<br>	}<br>	<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function">	</span>{<br>		<span class="hljs-keyword">while</span> (x != p[x])<br>		{<br>			x = p[x] = p[p[x]];<br>		}<br>		<span class="hljs-keyword">return</span> x;<br>	}<br>	<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">same</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>{ <span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(x) == <span class="hljs-built_in">find</span>(y); }<br>	<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function">	</span>{<br>		<span class="hljs-type">int</span> px = <span class="hljs-built_in">find</span>(x);<br>		<span class="hljs-type">int</span> py = <span class="hljs-built_in">find</span>(y);<br>		<span class="hljs-keyword">if</span> (px == py)<br>		{<br>			<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>		}<br>		siz[px] += siz[py];<br>		p[py] = px;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>	}<br>	<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">size</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>{ <span class="hljs-keyword">return</span> siz[<span class="hljs-built_in">find</span>(x)]; }<br>};<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>	<span class="hljs-type">int</span> n, k, res = <span class="hljs-number">0</span>;<br>	cin &gt;&gt; n &gt;&gt; k;<br>	<span class="hljs-function">DSU <span class="hljs-title">dsu</span><span class="hljs-params">(<span class="hljs-number">3</span> * (n + <span class="hljs-number">1</span>))</span></span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, d, x, y; i &lt; k; ++i)<br>	{<br>		cin &gt;&gt; d &gt;&gt; x &gt;&gt; y;<br>		<span class="hljs-keyword">if</span> (x &gt; n || y &gt; n)<br>		{<br>			res++;<br>			<span class="hljs-keyword">continue</span>;<br>		}<br>		<span class="hljs-keyword">if</span> (d &amp; <span class="hljs-number">1</span>)<br>		{<br>			<span class="hljs-keyword">if</span> (dsu.<span class="hljs-built_in">same</span>(x + n, y) || dsu.<span class="hljs-built_in">same</span>(x + n + n, y))<br>			{<br>				res++;<br>			}<br>			<span class="hljs-keyword">else</span><br>			{<br>				dsu.<span class="hljs-built_in">merge</span>(x, y);<br>				dsu.<span class="hljs-built_in">merge</span>(x + n, y + n);<br>				dsu.<span class="hljs-built_in">merge</span>(x + n + n, y + n + n);<br>			}<br>		}<br>		<span class="hljs-keyword">else</span><br>		{<br>			<span class="hljs-keyword">if</span> (dsu.<span class="hljs-built_in">same</span>(x + n + n, y) || dsu.<span class="hljs-built_in">same</span>(x, y))<br>			{<br>				res++;<br>			}<br>			<span class="hljs-keyword">else</span><br>			{<br>				dsu.<span class="hljs-built_in">merge</span>(x + n, y);<br>				dsu.<span class="hljs-built_in">merge</span>(x + n + n, y + n);<br>				dsu.<span class="hljs-built_in">merge</span>(x, y + n + n);<br>			}<br>		}<br>	}<br>	cout &lt;&lt; res &lt;&lt; endl;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br><br></code></pre></td></tr></tbody></table></figure>
        </div>
      </div>
    </div>
<h3 id="团伙"><a href="#团伙" class="headerlink" title="团伙"></a>团伙</h3><p><a href="https://www.luogu.com.cn/problem/P1892">团伙</a>，这个题只有两种关系，注意的就是，朋友的敌人和自己的敌人不一定是朋友。</p>

    <div class="fold">
      <div class="fold-title fold-default collapsed" data-toggle="collapse" href="#collapse-dcdac752" role="button" aria-expanded="false" aria-controls="collapse-dcdac752">
        <div class="fold-arrow">▶</div>代码
      </div>
      <div class="fold-collapse collapse" id="collapse-dcdac752">
        <div class="fold-content">
          <figure class="highlight c++"><table><tbody><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;deque&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;numeric&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iomanip&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _fio                      \</span><br><span class="hljs-meta">	ios_base::sync_with_stdio(0); \</span><br><span class="hljs-meta">	cin.tie(0);                   \</span><br><span class="hljs-meta">	cout.tie(0);</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb(e) push_back(e)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> all(x) (x).begin(), (x).end()</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> allr(x) (x).rbegin(), (x).rend()</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">'\n'</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> i64 = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">using</span> PII = pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">DSU</span><br>{<br>	std::vector&lt;<span class="hljs-type">int</span>&gt; p, siz;<br>	<span class="hljs-built_in">DSU</span>() {}<br>	<span class="hljs-built_in">DSU</span>(<span class="hljs-type">int</span> n) { <span class="hljs-built_in">init</span>(n); }<br>	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function">	</span>{<br>		p.<span class="hljs-built_in">resize</span>(n);<br>		std::<span class="hljs-built_in">iota</span>(p.<span class="hljs-built_in">begin</span>(), p.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>);<br>		siz.<span class="hljs-built_in">assign</span>(n, <span class="hljs-number">1</span>);<br>	}<br>	<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function">	</span>{<br>		<span class="hljs-keyword">while</span> (x != p[x])<br>		{<br>			x = p[x] = p[p[x]];<br>		}<br>		<span class="hljs-keyword">return</span> x;<br>	}<br>	<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">same</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>{ <span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(x) == <span class="hljs-built_in">find</span>(y); }<br>	<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function">	</span>{<br>		<span class="hljs-type">int</span> px = <span class="hljs-built_in">find</span>(x);<br>		<span class="hljs-type">int</span> py = <span class="hljs-built_in">find</span>(y);<br>		<span class="hljs-keyword">if</span> (px == py)<br>		{<br>			<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>		}<br>		siz[px] += siz[py];<br>		p[py] = px;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>	}<br>	<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">size</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>{ <span class="hljs-keyword">return</span> siz[<span class="hljs-built_in">find</span>(x)]; }<br>};<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>	<span class="hljs-type">int</span> n, m;<br>	cin &gt;&gt; n &gt;&gt; m;<br>	<span class="hljs-function">DSU <span class="hljs-title">dsu</span><span class="hljs-params">(<span class="hljs-number">2</span> * (n + <span class="hljs-number">1</span>))</span></span>;<br>	<span class="hljs-keyword">while</span> (m--)<br>	{<br>		string op;<br>		<span class="hljs-type">int</span> x, y;<br>		cin &gt;&gt; op &gt;&gt; x &gt;&gt; y;<br>		<span class="hljs-keyword">if</span> (op == <span class="hljs-string">"F"</span>)<br>		{<br>			dsu.<span class="hljs-built_in">merge</span>(x, y);<br>			<span class="hljs-comment">// dsu.merge(x + n, y + n);</span><br>		}<br>		<span class="hljs-keyword">else</span><br>		{<br>			dsu.<span class="hljs-built_in">merge</span>(x + n, y);<br>			dsu.<span class="hljs-built_in">merge</span>(x, y + n);<br>		}<br>	}<br>	unordered_set&lt;<span class="hljs-type">int</span>&gt; st;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>		st.<span class="hljs-built_in">insert</span>(dsu.<span class="hljs-built_in">find</span>(i));<br>	cout &lt;&lt; st.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>
        </div>
      </div>
    </div>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>图论</tag>
        <tag>并查集</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>普通莫队</title>
    <url>/posts/a072cd53/</url>
    <content><![CDATA[<h2 id="莫队算法简介"><a href="#莫队算法简介" class="headerlink" title="莫队算法简介"></a>莫队算法简介</h2><p>莫队算法是由莫涛提出的算法。在莫涛提出莫队算法之前，莫队算法已经在 Codeforces 的高手圈里小范围流传，但是莫涛是第一个对莫队算法进行详细归纳总结的人。莫涛提出莫队算法时，只分析了普通莫队算法，但是经过 OIer 和 ACMer 的集体智慧改造，莫队有了多种扩展版本。</p>
<p>莫队算法可以解决一类离线区间询问问题,基于双指针，分块，排序等思想，适用性极为广泛。同时将其加以扩展，便能轻松处理树上路径询问以及支持修改操作。</p>
<h2 id="普通莫队"><a href="#普通莫队" class="headerlink" title="普通莫队"></a>普通莫队</h2><p>莫队是处理离线区间询问的算法$O(n \sqrt n)$</p>
<p>假设$n = m$ ($m$为询问数，$n$为区间长度),对于任意一个区间$[l,r]$ 我们假设已经知道这个区间的$val$,我们可以通过拓展到$[l-1,r],[l+1,r],[l,r-1],[l,r+1]$这四个区间，并且算出对应的$val$,那么我们的效率将会变得很高。</p>
<p>为了让我们的拓展次数变少,我们可以对每个询问进行排序，尽可能的让相近的区间同时查询。这就是莫队的一个很神奇的地方，采用了分块的思想，把区间分成一块一块的，这样我们的排序规则就是，先按照所属块的先后排序，然后同一块的再按照右端点排序，这样就大大降低了我们的时间复杂度。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">move</span><span class="hljs-params">(<span class="hljs-type">int</span> pos, <span class="hljs-type">int</span> sign)</span> </span>{<br>  <span class="hljs-comment">// update nowAns</span><br>}<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>{<br>  BLOCK_SIZE = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">ceil</span>(<span class="hljs-built_in">pow</span>(n, <span class="hljs-number">0.5</span>)));<br>  <span class="hljs-built_in">sort</span>(querys, querys + m);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; ++i) {<br>    <span class="hljs-type">const</span> query &amp;q = querys[i];<br>    <span class="hljs-keyword">while</span> (l &gt; q.l) <span class="hljs-built_in">move</span>(--l, <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">while</span> (r &lt; q.r) <span class="hljs-built_in">move</span>(++r, <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">while</span> (l &lt; q.l) <span class="hljs-built_in">move</span>(l++, <span class="hljs-number">-1</span>);<br>    <span class="hljs-keyword">while</span> (r &gt; q.r) <span class="hljs-built_in">move</span>(r--, <span class="hljs-number">-1</span>);<br>    ans[q.id] = nowAns;<br>  }<br>}<br></code></pre></td></tr></tbody></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>莫队的复杂度证明比较复杂，这里贴上<a href="https://oi-wiki.org/misc/mo-algo/">OI Wiki</a><br>莫队算法还有一个特点：当&nbsp;n 不变时，m 越大，处理每次询问的平均转移代价就越小。一些其他的离线算法也具有同样的特点（如求 LCA 的 Tarjan 算法），但是莫队算法的平均转移代价随&nbsp;m&nbsp;的变化最明显。</p>
<h3 id="排序优化"><a href="#排序优化" class="headerlink" title="排序优化"></a>排序优化</h3><figure class="highlight awk"><table><tbody><tr><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>假设块的大小为<span class="hljs-number">2</span><br><span class="hljs-number">1</span> <span class="hljs-number">1</span><br><span class="hljs-number">2</span> <span class="hljs-number">100</span><br><span class="hljs-number">3</span> <span class="hljs-number">1</span><br><span class="hljs-number">4</span> <span class="hljs-number">100</span><br></code></pre></td></tr></tbody></table></figure>

<p>我们通过上面的数据可以发现，r指针的移动次数大概为300次，并且每一个区间的r，导致整体看起来像一个波浪，这里我们就要用到奇偶化排序。</p>
<p>什么是奇偶化排序？奇偶化排序即对于属于奇数块的询问，r 按从小到大排序，对于属于偶数块的排序，r 从大到小排序，这样我们的 r 指针在处理完这个奇数块的问题后，将在返回的途中处理偶数块的问题，再向 n 移动处理下一个奇数块的问题，优化了 r 指针的移动次数，一般情况下，这种优化能让程序快 30% 左右。</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">sort</span>(query.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">1</span>, query.<span class="hljs-built_in">end</span>(), [&amp;](<span class="hljs-keyword">auto</span> x, <span class="hljs-keyword">auto</span> y) {<br>	<span class="hljs-keyword">if</span> (K[x[<span class="hljs-number">0</span>]] != K[y[<span class="hljs-number">0</span>]]) <span class="hljs-keyword">return</span> x[<span class="hljs-number">0</span>] &lt; y[<span class="hljs-number">0</span>]; <br>	<span class="hljs-keyword">if</span> (K[x[<span class="hljs-number">0</span>]] &amp; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> x[<span class="hljs-number">1</span>] &lt; y[<span class="hljs-number">1</span>]; <br>	<span class="hljs-keyword">return</span> x[<span class="hljs-number">1</span>] &gt; y[<span class="hljs-number">1</span>]; <br>});<br></code></pre></td></tr></tbody></table></figure>

<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p>我们先拿最简单的应用，前缀和，众所周知，有很多方法都可以求前缀和，当然莫队也行。</p>

    <div class="fold">
      <div class="fold-title fold-default collapsed" data-toggle="collapse" href="#collapse-b2f6d8e1" role="button" aria-expanded="false" aria-controls="collapse-b2f6d8e1">
        <div class="fold-arrow">▶</div>前缀和
      </div>
      <div class="fold-collapse collapse" id="collapse-b2f6d8e1">
        <div class="fold-content">
          <h4 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h4><p>输入一个长度为 $n$ 的整数序列。</p><p>接下来再输入 $m$ 个询问，每个询问输入一对 $l, r$。</p><p>对于每个询问，输出原序列中从第 $l$ 个数到第 $r$ 个数的和。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含两个整数 $n$ 和 $m$。</p><p>第二行包含 $n$ 个整数，表示整数数列。</p><p>接下来 $m$ 行，每行包含两个整数 $l$ 和 $r$，表示一个询问的区间范围。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>共 $m$ 行，每行输出一个询问的结果。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>$1 \le l \le r \le n$,<br>$1 \le n,m \le 100000$,<br>$-1000 \le 数列中元素的值 \le 1000$</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><p>5 3<br>2 1 3 6 4<br>1 2<br>1 3<br>2 4</p><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><p>3<br>6<br>10<br>对于每一个区间，我们考虑那四种情况:</p><ul><li><p>当左边需要增加一个位置，我们直接加上那个位置的值</p></li><li><p>当左边需要减少一个位置，我们直接减少那个位置的值</p></li><li><p>当右边需要增加一个位置，我们直接加上那个位置的值</p></li><li><p>当右边需要减少一个位置，我们直接减少那个位置的值</p>  <div class="fold">    <div class="fold-title fold-default collapsed" data-toggle="collapse" href="#collapse-9c51fa20" role="button" aria-expanded="false" aria-controls="collapse-9c51fa20">      <div class="fold-arrow">▶</div>代码    </div>    <div class="fold-collapse collapse" id="collapse-9c51fa20">      <div class="fold-content">        <figure class="highlight c++"><table><tbody><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;deque&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;numeric&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iomanip&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _fio ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb(e) push_back(e)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> all(x) (x).begin(), (x).end()</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> allr(x) (x).rbegin(), (x).rend()</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">'\n'</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> i64 = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">using</span> PII = pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>	<span class="hljs-type">int</span> n,m;<br>	cin &gt;&gt; n &gt;&gt; m;<br>	<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>	vector&lt;array&lt;<span class="hljs-type">int</span>,3&gt; &gt; <span class="hljs-built_in">query</span>(m+<span class="hljs-number">1</span>);<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) cin &gt;&gt; v[i];<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i)<br>	{<br>		<span class="hljs-type">int</span> l,r;cin &gt;&gt; l &gt;&gt; r;<br>		query[i] = {l,r,i};<br>	}<br>	<span class="hljs-type">int</span> kn = n / <span class="hljs-built_in">min</span>&lt;<span class="hljs-type">int</span>&gt;(n,<span class="hljs-built_in">sqrt</span>(m));<br>	<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">K</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) K[i] = (i - <span class="hljs-number">1</span>) / kn + <span class="hljs-number">1</span>;<br>	<span class="hljs-built_in">sort</span>(query.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">1</span>,query.<span class="hljs-built_in">end</span>(),[&amp;](<span class="hljs-keyword">auto</span> x,<span class="hljs-keyword">auto</span> y){<br>		<span class="hljs-keyword">if</span>(K[x[<span class="hljs-number">0</span>]] != K[y[<span class="hljs-number">0</span>]]) <span class="hljs-keyword">return</span> x[<span class="hljs-number">0</span>] &lt; y[<span class="hljs-number">0</span>];<br>		<span class="hljs-keyword">if</span>(K[x[<span class="hljs-number">0</span>]] &amp; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> x[<span class="hljs-number">1</span>] &lt; y[<span class="hljs-number">1</span>];<br>		<span class="hljs-keyword">return</span> x[<span class="hljs-number">1</span>] &gt; y[<span class="hljs-number">1</span>];<br>	});<br><br>	<span class="hljs-type">int</span> l = <span class="hljs-number">1</span>,r = <span class="hljs-number">0</span>,val = <span class="hljs-number">0</span>;<br>	<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(m + <span class="hljs-number">1</span>)</span></span>;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i)<br>	{<br>		<span class="hljs-keyword">auto</span> &amp;e = query[i];<br>		<span class="hljs-type">int</span> ql = e[<span class="hljs-number">0</span>],qr = e[<span class="hljs-number">1</span>],id = e[<span class="hljs-number">2</span>];<br>		<span class="hljs-keyword">auto</span> add = [&amp;](<span class="hljs-type">int</span> x) -&gt; <span class="hljs-type">void</span> {<br>			val += x;<br>		};<br>		<span class="hljs-keyword">auto</span> sub = [&amp;](<span class="hljs-type">int</span> x) -&gt; <span class="hljs-type">void</span> {<br>			val -= x;<br>		};<br>		<span class="hljs-keyword">while</span>(l &gt; ql) <span class="hljs-built_in">add</span>(v[-- l]);<br>		<span class="hljs-keyword">while</span>(r &lt; qr) <span class="hljs-built_in">add</span>(v[++ r]);<br>		<span class="hljs-keyword">while</span>(l &lt; ql) <span class="hljs-built_in">sub</span>(v[l ++ ]);<br>		<span class="hljs-keyword">while</span>(r &gt; qr) <span class="hljs-built_in">sub</span>(v[r -- ]);<br>		ans[id] = val;<br>	}<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) cout &lt;&lt; ans[i] &lt;&lt; endl;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br><br></code></pre></td></tr></tbody></table></figure>      </div>    </div>  </div></li></ul>
        </div>
      </div>
    </div>
<h4 id="小-Z-的袜子"><a href="#小-Z-的袜子" class="headerlink" title="小 Z 的袜子"></a>小 Z 的袜子</h4><p>然后是<a href="https://www.luogu.com.cn/problem/P1494">P1494 [国家集训队] 小 Z 的袜子 - 洛谷</a></p>

    <div class="fold">
      <div class="fold-title fold-default collapsed" data-toggle="collapse" href="#collapse-378c5fbf" role="button" aria-expanded="false" aria-controls="collapse-378c5fbf">
        <div class="fold-arrow">▶</div>小 Z 的袜子
      </div>
      <div class="fold-collapse collapse" id="collapse-378c5fbf">
        <div class="fold-content">
          <p>其实莫队的写法基本上不同就只是在$add,sub$这两个函数之中。<br>这道题需要额外维护一个$cnt$数组，因为我们需要知道的是这个区间，相同颜色的袜子的数量，之后我们如何去算概率，首先我们考虑分母，一个完整的区间$[l,r]$,假如区间长度为$n$所有的组合次数为$C_n^2$,对应每一个分子，我们先考虑$add$加上颜色为$k$的袜子的情况，我们增加了一个$k$假如我们原来一共有$f$只，就是$C_f^2$现在我们需要更新了，因为多了一只，所以我的现在的情况即为$C_{f+1}^2$ ，然后我们再减去原来的。即为<br>$$<br>    C_{f+1}^2 - C_f^2 = (f+1)*f / 2 - f * (f - 1) / 2<br>$$<br>$sub$同理,其实这个公式还可以简化，简化为$f$，但是为了清晰，下方代码并没有简化。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;deque&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;numeric&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iomanip&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _fio ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb(e) push_back(e)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> all(x) (x).begin(), (x).end()</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> allr(x) (x).rbegin(), (x).rend()</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">'\n'</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> i64 = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">using</span> PII = pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><br><span class="hljs-function">i64 <span class="hljs-title">gcd</span><span class="hljs-params">(i64 a,i64 b)</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-keyword">return</span> b ? <span class="hljs-built_in">gcd</span>(b,a % b) : a;<br>}<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>    _fio<br>	<span class="hljs-type">int</span> n,m;<br>	cin &gt;&gt; n &gt;&gt; m;<br>	<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>,<span class="hljs-title">cnt</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>	vector&lt;array&lt;<span class="hljs-type">int</span>,3&gt; &gt; <span class="hljs-built_in">query</span>(m+<span class="hljs-number">1</span>);<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) cin &gt;&gt; v[i];<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i)<br>	{<br>		<span class="hljs-type">int</span> l,r;cin &gt;&gt; l &gt;&gt; r;<br>		query[i] = {l,r,i};<br>	}<br>	<span class="hljs-type">int</span> kn = n / <span class="hljs-built_in">min</span>&lt;<span class="hljs-type">int</span>&gt;(n,<span class="hljs-built_in">sqrt</span>(m));<br>	<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">K</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) K[i] = (i - <span class="hljs-number">1</span>) / kn + <span class="hljs-number">1</span>;<br>	<span class="hljs-built_in">sort</span>(query.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">1</span>,query.<span class="hljs-built_in">end</span>(),[&amp;](<span class="hljs-keyword">auto</span> x,<span class="hljs-keyword">auto</span> y){<br>		<span class="hljs-keyword">if</span>(K[x[<span class="hljs-number">0</span>]] != K[y[<span class="hljs-number">0</span>]]) <span class="hljs-keyword">return</span> x[<span class="hljs-number">0</span>] &lt; y[<span class="hljs-number">0</span>];<br>		<span class="hljs-keyword">if</span>(K[x[<span class="hljs-number">0</span>]] &amp; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> x[<span class="hljs-number">1</span>] &lt; y[<span class="hljs-number">1</span>];<br>		<span class="hljs-keyword">return</span> x[<span class="hljs-number">1</span>] &gt; y[<span class="hljs-number">1</span>];<br>	});<br><br>	<span class="hljs-type">int</span> l = <span class="hljs-number">1</span>,r = <span class="hljs-number">0</span>;<br>    i64 val = <span class="hljs-number">0</span>;<br>	<span class="hljs-function">vector&lt;i64&gt; <span class="hljs-title">ans1</span><span class="hljs-params">(m + <span class="hljs-number">1</span>)</span>,<span class="hljs-title">ans2</span><span class="hljs-params">(m + <span class="hljs-number">1</span>)</span></span>;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i)<br>	{<br>		<span class="hljs-keyword">auto</span> &amp;e = query[i];<br>		<span class="hljs-type">int</span> ql = e[<span class="hljs-number">0</span>],qr = e[<span class="hljs-number">1</span>],id = e[<span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">if</span>(ql == qr)<br>        {<br>            ans1[id] = <span class="hljs-number">0</span>,ans2[id] = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">continue</span>;<br>        }<br>		<span class="hljs-keyword">auto</span> add = [&amp;](<span class="hljs-type">int</span> x) -&gt; <span class="hljs-type">void</span> {<br>            val += (cnt[x] + <span class="hljs-number">1</span>)*cnt[x]/<span class="hljs-number">2</span> - cnt[x]*(cnt[x] - <span class="hljs-number">1</span>)/<span class="hljs-number">2</span>;<br>            cnt[x] ++ ; <br>		};<br>		<span class="hljs-keyword">auto</span> sub = [&amp;](<span class="hljs-type">int</span> x) -&gt; <span class="hljs-type">void</span> {<br>            cnt[x] -- ; <br>            val -= (cnt[x] + <span class="hljs-number">1</span>)*cnt[x]/<span class="hljs-number">2</span> - cnt[x]*(cnt[x] - <span class="hljs-number">1</span>)/<span class="hljs-number">2</span>;<br>		};<br>		<span class="hljs-keyword">while</span>(l &gt; ql) <span class="hljs-built_in">add</span>(v[-- l]);<br>		<span class="hljs-keyword">while</span>(r &lt; qr) <span class="hljs-built_in">add</span>(v[++ r]);<br>		<span class="hljs-keyword">while</span>(l &lt; ql) <span class="hljs-built_in">sub</span>(v[l ++ ]);<br>		<span class="hljs-keyword">while</span>(r &gt; qr) <span class="hljs-built_in">sub</span>(v[r -- ]);<br>		ans1[id] = val;<br>        ans2[id] = (i64)(r - l + <span class="hljs-number">1</span>) * (r - l) / <span class="hljs-number">2</span>;<br>	}<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i)<br>    {<br>        <span class="hljs-keyword">if</span>(ans1[i] != <span class="hljs-number">0</span>)<br>        {<br>            i64 g = <span class="hljs-built_in">gcd</span>(ans1[i],ans2[i]);<br>            ans1[i]/=g,ans2[i]/=g;<br>        }<br>        <span class="hljs-keyword">else</span><br>        {<br>            ans2[i] = <span class="hljs-number">1</span>;<br>        }<br>        cout &lt;&lt; ans1[i] &lt;&lt; <span class="hljs-string">"/"</span> &lt;&lt; ans2[i] &lt;&lt; endl;<br>    }<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>
        </div>
      </div>
    </div>

<h4 id="XOR-and-Favorite-Number"><a href="#XOR-and-Favorite-Number" class="headerlink" title="XOR and Favorite Number"></a>XOR and Favorite Number</h4><p><a href="https://codeforces.com/problemset/problem/617/E">Problem - 617E - Codeforces</a></p>

    <div class="fold">
      <div class="fold-title fold-default collapsed" data-toggle="collapse" href="#collapse-eab82611" role="button" aria-expanded="false" aria-controls="collapse-eab82611">
        <div class="fold-arrow">▶</div>XOR and Favorite Number
      </div>
      <div class="fold-collapse collapse" id="collapse-eab82611">
        <div class="fold-content">
          <p>题面翻译</p><ul><li>给定一个长度为 $n$ 的序列 $a$，然后再给一个数字 $k$，再给出 $m$ 组询问，每组询问给出一个区间，求这个区间里面有多少个子区间的异或值为 $k$。</li><li>$1 \le n,m \le 10 ^ 5$，$0 \le k,a_i \le 10^6$，$1 \le l_i \le r_i \le n$。</li></ul><p>我们要求$a_i \bigoplus a_{i+1} \bigoplus a_{i+2} \bigoplus … \bigoplus a_j$，可以通过前缀和，因为异或也满足类似前缀和的性质。<br>所以这个式子就变成了$(a_1 \bigoplus a_2 \bigoplus … \bigoplus a_{i-1}) \bigoplus (a_1 \bigoplus a_2 \bigoplus … \bigoplus a_j)$ ,如果用前缀和异或数组的话，这道题就变成了，有多少个数对$(i,j)$满足$a_i \bigoplus a_j = k$。之后直接莫队，因为$x \bigoplus y = z -&gt; x \bigoplus z = y$ 所以就有我们每加入一个$x$,每一个对应的y都满足，所以把y的数量给加上,用$cnt$数组当做桶就行。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;deque&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;numeric&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iomanip&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _fio                      \</span><br><span class="hljs-meta">	ios_base::sync_with_stdio(0); \</span><br><span class="hljs-meta">	cin.tie(0);                   \</span><br><span class="hljs-meta">	cout.tie(0);</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb(e) push_back(e)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> all(x) (x).begin(), (x).end()</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> allr(x) (x).rbegin(), (x).rend()</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">'\n'</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> i64 = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">using</span> PII = pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>	_fio<br>	<span class="hljs-type">int</span> n, k, m;<br>	cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;<br>	i64 kn = n / <span class="hljs-built_in">min</span>&lt;<span class="hljs-type">int</span>&gt;(n, <span class="hljs-built_in">sqrt</span>(m));<br>	<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">K</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>,<span class="hljs-title">cnt</span><span class="hljs-params">(<span class="hljs-number">2e6</span>+<span class="hljs-number">10</span>)</span></span>;<br>	<span class="hljs-function">vector&lt;i64&gt; <span class="hljs-title">ans</span><span class="hljs-params">(m + <span class="hljs-number">1</span>)</span> </span>;<br>	vector&lt;array&lt;<span class="hljs-type">int</span>, 3&gt;&gt; <span class="hljs-built_in">query</span>(m + <span class="hljs-number">1</span>);<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)<br>		cin &gt;&gt; v[i], v[i] ^= v[i - <span class="hljs-number">1</span>], K[i] = (i - <span class="hljs-number">1</span>) / kn + <span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++i)<br>	{<br>		i64 l, r;<br>		cin &gt;&gt; l &gt;&gt; r;<br>		query[i] = {l - <span class="hljs-number">1</span>, r, i};<span class="hljs-comment">//前缀和，直接l-1</span><br>	}<br>	<span class="hljs-built_in">sort</span>(query.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">1</span>, query.<span class="hljs-built_in">end</span>(), [&amp;](<span class="hljs-keyword">auto</span> x, <span class="hljs-keyword">auto</span> y)<br>		 {<br>		<span class="hljs-keyword">if</span>(K[x[<span class="hljs-number">0</span>]] != K[y[<span class="hljs-number">0</span>]]) <span class="hljs-keyword">return</span> x[<span class="hljs-number">0</span>] &lt; y[<span class="hljs-number">0</span>];<br>		<span class="hljs-keyword">if</span>(K[x[<span class="hljs-number">0</span>]] &amp; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> x[<span class="hljs-number">1</span>] &lt; y[<span class="hljs-number">1</span>];<br>		<span class="hljs-keyword">return</span> x[<span class="hljs-number">1</span>] &gt; y[<span class="hljs-number">1</span>]; <br>		});<br>	<span class="hljs-type">int</span> l = <span class="hljs-number">1</span>, r = <span class="hljs-number">0</span>;<br>	i64 val = <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++i)<br>	{<br>		<span class="hljs-keyword">auto</span> &amp;e = query[i];<br>		<span class="hljs-type">int</span> ql = e[<span class="hljs-number">0</span>], qr = e[<span class="hljs-number">1</span>], id = e[<span class="hljs-number">2</span>];<br>		<span class="hljs-keyword">auto</span> add = [&amp;](<span class="hljs-type">int</span> x) -&gt; <span class="hljs-type">void</span><br>		{<br>			val += (i64)cnt[x ^ k];<br>			cnt[x]++;<br>		};<br>		<span class="hljs-keyword">auto</span> sub = [&amp;](<span class="hljs-type">int</span> x) -&gt; <span class="hljs-type">void</span><br>		{<br>			cnt[x]--;<br>			val -= (i64)cnt[x ^ k];<br>		};<br>		<span class="hljs-keyword">while</span> (l &gt; ql) <span class="hljs-built_in">add</span>(v[--l]);<br>		<span class="hljs-keyword">while</span> (r &lt; qr) <span class="hljs-built_in">add</span>(v[++r]);<br>		<span class="hljs-keyword">while</span> (l &lt; ql) <span class="hljs-built_in">sub</span>(v[l++]);<br>		<span class="hljs-keyword">while</span> (r &gt; qr) <span class="hljs-built_in">sub</span>(v[r--]);<br>		ans[id] = val;<br>	}<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++i)<br>		cout &lt;&lt; ans[i] &lt;&lt; endl;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>
        </div>
      </div>
    </div>



<h2 id="算法模板"><a href="#算法模板" class="headerlink" title="算法模板"></a>算法模板</h2>
    <div class="fold">
      <div class="fold-title fold-default collapsed" data-toggle="collapse" href="#collapse-738764b7" role="button" aria-expanded="false" aria-controls="collapse-738764b7">
        <div class="fold-arrow">▶</div>代码
      </div>
      <div class="fold-collapse collapse" id="collapse-738764b7">
        <div class="fold-content">
          <figure class="highlight c++"><table><tbody><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>&nbsp; &nbsp; <span class="hljs-type">int</span> n, m;<br>&nbsp; &nbsp; cin &gt;&gt; n &gt;&gt; m;<br>&nbsp; &nbsp; i64 kn = n / <span class="hljs-built_in">min</span>&lt;<span class="hljs-type">int</span>&gt;(n, <span class="hljs-built_in">sqrt</span>(m));<br>&nbsp; &nbsp; <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">K</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>&nbsp; &nbsp; <span class="hljs-function">vector&lt;i64&gt; <span class="hljs-title">ans</span><span class="hljs-params">(m + <span class="hljs-number">1</span>)</span></span>;<br>&nbsp; &nbsp; vector&lt;array&lt;<span class="hljs-type">int</span>, 3&gt;&gt; <span class="hljs-built_in">query</span>(m + <span class="hljs-number">1</span>);<br>&nbsp; &nbsp; <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)<br>&nbsp; &nbsp; &nbsp; &nbsp; cin &gt;&gt; v[i], K[i] = (i - <span class="hljs-number">1</span>) / kn + <span class="hljs-number">1</span>;<br>&nbsp; &nbsp; <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++i)<br>&nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-type">int</span> l, r;<br>&nbsp; &nbsp; &nbsp; &nbsp; cin &gt;&gt; l &gt;&gt; r;<br>&nbsp; &nbsp; &nbsp; &nbsp; query[i] = {l, r, i};<br>&nbsp; &nbsp; }<br>&nbsp; &nbsp; <span class="hljs-built_in">sort</span>(query.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">1</span>, query.<span class="hljs-built_in">end</span>(), [&amp;](<span class="hljs-keyword">auto</span> x, <span class="hljs-keyword">auto</span> y)<br>&nbsp; &nbsp; &nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">if</span>(K[x[<span class="hljs-number">0</span>]] != K[y[<span class="hljs-number">0</span>]]) <span class="hljs-keyword">return</span> x[<span class="hljs-number">0</span>] &lt; y[<span class="hljs-number">0</span>];<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">if</span>(K[x[<span class="hljs-number">0</span>]] &amp; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> x[<span class="hljs-number">1</span>] &lt; y[<span class="hljs-number">1</span>];<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">return</span> x[<span class="hljs-number">1</span>] &gt; y[<span class="hljs-number">1</span>];<br>&nbsp; &nbsp; &nbsp; &nbsp; });<br>&nbsp; &nbsp; <span class="hljs-type">int</span> l = <span class="hljs-number">1</span>, r = <span class="hljs-number">0</span>, val = <span class="hljs-number">0</span>;<br>&nbsp; &nbsp; <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++i)<br>&nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">auto</span> &amp;e = query[i];<br>&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-type">int</span> ql = e[<span class="hljs-number">0</span>], qr = e[<span class="hljs-number">1</span>], id = e[<span class="hljs-number">2</span>];<br>&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">auto</span> add = [&amp;](<span class="hljs-type">int</span> x) -&gt; <span class="hljs-type">void</span> {<br>&nbsp; <br>		};<br>&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">auto</span> sub = [&amp;](<span class="hljs-type">int</span> x) -&gt; <span class="hljs-type">void</span> {<br>  <br>&nbsp; &nbsp; &nbsp; &nbsp; };<br>&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">while</span> (l &gt; ql) <span class="hljs-built_in">add</span>(v[--l]);<br>&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">while</span> (r &lt; qr) <span class="hljs-built_in">add</span>(v[++r]);<br>&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">while</span> (l &lt; ql) <span class="hljs-built_in">sub</span>(v[l++]);<br>&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">while</span> (r &gt; qr) <span class="hljs-built_in">sub</span>(v[r--]);<br>&nbsp; &nbsp; &nbsp; &nbsp; ans[id] = val;<br>&nbsp; &nbsp; }<br>&nbsp; &nbsp; <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++i) cout &lt;&lt; ans[i] &lt;&lt; endl;<br>&nbsp; &nbsp; <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>
        </div>
      </div>
    </div>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>杂项</tag>
      </tags>
  </entry>
  <entry>
    <title>线段树</title>
    <url>/posts/8893d943/</url>
    <content><![CDATA[<h2 id="封装模板"><a href="#封装模板" class="headerlink" title="封装模板"></a>封装模板</h2><p>$jls$的基础LSGT模板,区间为$[l,r)$，之后可能会更改。</p>

    <div class="fold">
      <div class="fold-title fold-default collapsed" data-toggle="collapse" href="#collapse-8f7bdefe" role="button" aria-expanded="false" aria-controls="collapse-8f7bdefe">
        <div class="fold-arrow">▶</div>代码
      </div>
      <div class="fold-collapse collapse" id="collapse-8f7bdefe">
        <div class="fold-content">
          <figure class="highlight c++"><table><tbody><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;deque&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;numeric&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iomanip&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _fio                      \</span><br><span class="hljs-meta">	ios_base::sync_with_stdio(0); \</span><br><span class="hljs-meta">	cin.tie(0);                   \</span><br><span class="hljs-meta">	cout.tie(0);</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb(e) push_back(e)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> all(x) (x).begin(), (x).end()</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> allr(x) (x).rbegin(), (x).rend()</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">'\n'</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> i64 = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">using</span> PII = pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Info</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">Tag</span>&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">LazySegmentTree</span><br>{<br>	<span class="hljs-type">const</span> <span class="hljs-type">int</span> n;<br>	std::vector&lt;Info&gt; info;<br>	std::vector&lt;Tag&gt; tag;<br>	<span class="hljs-built_in">LazySegmentTree</span>(<span class="hljs-type">int</span> n) : <span class="hljs-built_in">n</span>(n), <span class="hljs-built_in">info</span>(<span class="hljs-number">4</span> &lt;&lt; std::__lg(n)), <span class="hljs-built_in">tag</span>(<span class="hljs-number">4</span> &lt;&lt; std::__lg(n)) {}<br>	<span class="hljs-built_in">LazySegmentTree</span>(std::vector&lt;Info&gt; init) : <span class="hljs-built_in">LazySegmentTree</span>(init.<span class="hljs-built_in">size</span>())<br>	{<br>		std::function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt; build = [&amp;](<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)<br>		{<br>			<span class="hljs-keyword">if</span> (r - l == <span class="hljs-number">1</span>)<br>			{<br>				info[p] = init[l];<br>				<span class="hljs-keyword">return</span>;<br>			}<br>			<span class="hljs-type">int</span> m = (l + r) / <span class="hljs-number">2</span>;<br>			<span class="hljs-built_in">build</span>(<span class="hljs-number">2</span> * p, l, m);<br>			<span class="hljs-built_in">build</span>(<span class="hljs-number">2</span> * p + <span class="hljs-number">1</span>, m, r);<br>			<span class="hljs-built_in">pull</span>(p);<br>		};<br>		<span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, n);<br>	}<br>	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pull</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span></span><br><span class="hljs-function">	</span>{<br>		info[p] = info[<span class="hljs-number">2</span> * p] + info[<span class="hljs-number">2</span> * p + <span class="hljs-number">1</span>];<br>	}<br>	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">apply</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">const</span> Tag &amp;v)</span></span><br><span class="hljs-function">	</span>{<br>		info[p].<span class="hljs-built_in">apply</span>(v);<br>		tag[p].<span class="hljs-built_in">apply</span>(v);<br>	}<br>	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span></span><br><span class="hljs-function">	</span>{<br>		<span class="hljs-built_in">apply</span>(<span class="hljs-number">2</span> * p, tag[p]);<br>		<span class="hljs-built_in">apply</span>(<span class="hljs-number">2</span> * p + <span class="hljs-number">1</span>, tag[p]);<br>		tag[p] = <span class="hljs-built_in">Tag</span>();<br>	}<br>	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> x, <span class="hljs-type">const</span> Info &amp;v)</span></span><br><span class="hljs-function">	</span>{<br>		<span class="hljs-keyword">if</span> (r - l == <span class="hljs-number">1</span>)<br>		{<br>			info[p] = v;<br>			<span class="hljs-keyword">return</span>;<br>		}<br>		<span class="hljs-type">int</span> m = (l + r) / <span class="hljs-number">2</span>;<br>		<span class="hljs-built_in">push</span>(p);<br>		<span class="hljs-keyword">if</span> (x &lt; m)<br>		{<br>			<span class="hljs-built_in">modify</span>(<span class="hljs-number">2</span> * p, l, m, x, v);<br>		}<br>		<span class="hljs-keyword">else</span><br>		{<br>			<span class="hljs-built_in">modify</span>(<span class="hljs-number">2</span> * p + <span class="hljs-number">1</span>, m, r, x, v);<br>		}<br>		<span class="hljs-built_in">pull</span>(p);<br>	}<br>	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">const</span> Info &amp;v)</span></span><br><span class="hljs-function">	</span>{<br>		<span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, n, p, v);<br>	}<br>	<span class="hljs-function">Info <span class="hljs-title">rangeQuery</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function">	</span>{<br>		<span class="hljs-keyword">if</span> (l &gt;= y || r &lt;= x)<br>		{<br>			<span class="hljs-keyword">return</span> <span class="hljs-built_in">Info</span>();<br>		}<br>		<span class="hljs-keyword">if</span> (l &gt;= x &amp;&amp; r &lt;= y)<br>		{<br>			<span class="hljs-keyword">return</span> info[p];<br>		}<br>		<span class="hljs-type">int</span> m = (l + r) / <span class="hljs-number">2</span>;<br>		<span class="hljs-built_in">push</span>(p);<br>		<span class="hljs-keyword">return</span> <span class="hljs-built_in">rangeQuery</span>(<span class="hljs-number">2</span> * p, l, m, x, y) + <span class="hljs-built_in">rangeQuery</span>(<span class="hljs-number">2</span> * p + <span class="hljs-number">1</span>, m, r, x, y);<br>	}<br>	<span class="hljs-function">Info <span class="hljs-title">rangeQuery</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function">	</span>{<br>		<span class="hljs-keyword">return</span> <span class="hljs-built_in">rangeQuery</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, n, l, r);<br>	}<br>	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rangeApply</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">const</span> Tag &amp;v)</span></span><br><span class="hljs-function">	</span>{<br>		<span class="hljs-keyword">if</span> (l &gt;= y || r &lt;= x)<br>		{<br>			<span class="hljs-keyword">return</span>;<br>		}<br>		<span class="hljs-keyword">if</span> (l &gt;= x &amp;&amp; r &lt;= y)<br>		{<br>			<span class="hljs-built_in">apply</span>(p, v);<br>			<span class="hljs-keyword">return</span>;<br>		}<br>		<span class="hljs-type">int</span> m = (l + r) / <span class="hljs-number">2</span>;<br>		<span class="hljs-built_in">push</span>(p);<br>		<span class="hljs-built_in">rangeApply</span>(<span class="hljs-number">2</span> * p, l, m, x, y, v);<br>		<span class="hljs-built_in">rangeApply</span>(<span class="hljs-number">2</span> * p + <span class="hljs-number">1</span>, m, r, x, y, v);<br>		<span class="hljs-built_in">pull</span>(p);<br>	}<br>	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rangeApply</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">const</span> Tag &amp;v)</span></span><br><span class="hljs-function">	</span>{<br>		<span class="hljs-keyword">return</span> <span class="hljs-built_in">rangeApply</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, n, l, r, v);<br>	}<br>	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">half</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function">	</span>{<br>		<span class="hljs-keyword">if</span> (info[p].act == <span class="hljs-number">0</span>)<br>		{<br>			<span class="hljs-keyword">return</span>;<br>		}<br>		<span class="hljs-keyword">if</span> ((info[p].min + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span> == (info[p].max + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>)<br>		{<br>			<span class="hljs-built_in">apply</span>(p, {-(info[p].min + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>});<br>			<span class="hljs-keyword">return</span>;<br>		}<br>		<span class="hljs-type">int</span> m = (l + r) / <span class="hljs-number">2</span>;<br>		<span class="hljs-built_in">push</span>(p);<br>		<span class="hljs-built_in">half</span>(<span class="hljs-number">2</span> * p, l, m);<br>		<span class="hljs-built_in">half</span>(<span class="hljs-number">2</span> * p + <span class="hljs-number">1</span>, m, r);<br>		<span class="hljs-built_in">pull</span>(p);<br>	}<br>	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">half</span><span class="hljs-params">()</span></span><br><span class="hljs-function">	</span>{<br>		<span class="hljs-built_in">half</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, n);<br>	}<br>};<br><br><span class="hljs-keyword">constexpr</span> i64 inf = <span class="hljs-number">1E18</span>;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Tag</span><br>{<br>	i64 add = <span class="hljs-number">0</span>;<br><br>	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">apply</span><span class="hljs-params">(Tag t)</span></span><br><span class="hljs-function">	</span>{<br>		add += t.add;<br>	}<br>};<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Info</span><br>{<br>	i64 min = inf;<br>	i64 max = -inf;<br>	i64 sum = <span class="hljs-number">0</span>;<br>	i64 act = <span class="hljs-number">0</span>;<br><br>	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">apply</span><span class="hljs-params">(Tag t)</span></span><br><span class="hljs-function">	</span>{<br>		min += t.add;<br>		max += t.add;<br>		sum += act * t.add;<br>	}<br>};<br><br>Info <span class="hljs-keyword">operator</span>+(Info a, Info b)<br>{<br>	Info c;<br>	c.min = std::<span class="hljs-built_in">min</span>(a.min, b.min);<br>	c.max = std::<span class="hljs-built_in">max</span>(a.max, b.max);<br>	c.sum = a.sum + b.sum;<br>	c.act = a.act + b.act;<br>	<span class="hljs-keyword">return</span> c;<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>	<span class="hljs-type">int</span> n, m;<br>	cin &gt;&gt; n &gt;&gt; m;<br>	<span class="hljs-function">vector&lt;Info&gt; <span class="hljs-title">a</span><span class="hljs-params">(n)</span></span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>	{<br>		cin &gt;&gt; a[i].sum;<br>		a[i].act = <span class="hljs-number">1</span>;<br>		a[i].max = a[i].min = a[i].sum;<br>	}<br>	<span class="hljs-function">LazySegmentTree&lt;Info, Tag&gt; <span class="hljs-title">sgt</span><span class="hljs-params">(a)</span></span>;<br>	<span class="hljs-keyword">while</span> (m--)<br>	{<br>		<span class="hljs-type">int</span> t, l, r, x;<br>		cin &gt;&gt; t &gt;&gt; l &gt;&gt; r;<br>		l--;<br>		<span class="hljs-keyword">if</span> (t == <span class="hljs-number">1</span>)<br>		{<br>			cin &gt;&gt; x;<br>			sgt.<span class="hljs-built_in">rangeApply</span>(l, r, {x});<br>		}<br>		<span class="hljs-keyword">else</span><br>		{<br>			cout &lt;&lt; sgt.<span class="hljs-built_in">rangeQuery</span>(l, r).sum &lt;&lt; endl;<br>		}<br>	}<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br><br></code></pre></td></tr></tbody></table></figure>
        </div>
      </div>
    </div>

<h2 id="练习题目"><a href="#练习题目" class="headerlink" title="练习题目"></a>练习题目</h2><p><a href="https://www.luogu.com.cn/problem/P3372">P3372 【模板】线段树 1 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
</search>
